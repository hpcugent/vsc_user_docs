{"config": {"lang": ["en"], "separator": "[\\_\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Getting Started", "text": ""}, {"location": "#logging-in", "title": "Logging in", "text": "<p>To get started with the HPC-UGent infrastructure, you need to obtain a VSC account, see HPC manual. Keep in mind that you must keep your private key to yourself!</p> <p>You can look at your public/private key pair as a lock and a key: you give us the lock (your public key), we put it on the door, and then you can use your key to open the door and get access to the HPC infrastructure. Anyone who has your key can use your VSC account!</p> <p>Details on connecting to the HPC infrastructure are available in HPC manual connecting section.</p>"}, {"location": "#getting-help", "title": "Getting help", "text": "<p>To get help:</p> <ol> <li> <p>use the documentation available on the system, through the <code>help</code>,     <code>info</code> and <code>man</code> commands (use <code>q</code> to exit).     <pre><code>help cd\ninfo ls\nman cp\n</code></pre></p> </li> <li> <p>use Google</p> </li> <li> <p>contact hpc@ugent.be in case  of problems or questions (even for basic things!)</p> </li> </ol>"}, {"location": "#errors", "title": "Errors", "text": "<p>Sometimes when executing a command, an error occurs. Most likely there will be error output or a message explaining you this. Read this carefully and try to act on it. Try googling the error first to find any possible solution, but if you can't come up with something in 15 minutes, don't hesitate to mail hpc@ugent.be.</p>"}, {"location": "#basic-terminal-usage", "title": "Basic terminal usage", "text": "<p>The basic interface is the so-called shell prompt, typically ending with <code>$</code> (for <code>bash</code> shells).</p> <p>You use the shell by executing commands, and hitting <code>&lt;enter&gt;</code>. For example:</p> <pre><code>$ echo hello\nhello\n</code></pre> <p>You can go to the start or end of the command line using <code>Ctrl-A</code> or <code>Ctrl-E</code>.</p> <p>To go through previous commands, use <code>&lt;up&gt;</code> and <code>&lt;down&gt;</code>, rather than retyping them.</p>"}, {"location": "#command-history", "title": "Command history", "text": "<p>A powerful feature is that you can \"search\" through your command history, either using the <code>history</code> command, or using <code>Ctrl-R</code>:</p> <pre><code>$ history\n    1 echo hello\n\n# hit Ctrl-R, type 'echo' \n(reverse-i-search)`echo': echo hello\n</code></pre>"}, {"location": "#stopping-commands", "title": "Stopping commands", "text": "<p>If for any reason you want to stop a command from executing, press <code>Ctrl-C</code>. For example, if a command is taking too long, or you want to rerun it with different arguments.</p>"}, {"location": "#variables", "title": "Variables", "text": "<p>At the prompt we also have access to shell variables, which have both a name and a value.</p> <p>They can be thought of as placeholders for things we need to remember.</p> <p>For example, to print the path to your home directory, we can use the shell variable named <code>HOME</code>:</p> <pre><code>$ echo $HOME\n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>This prints the value of this variable.</p>"}, {"location": "#defining-variables", "title": "Defining variables", "text": "<p>There are several variables already defined for you when you start your session, such as <code>$HOME</code> which contains the path to your home directory.</p> <p>For a full overview of defined environment variables in your current session, you can use the <code>env</code> command. You can sort this output with <code>sort</code> to make it easier to search in:</p> <pre><code>$ env | sort\n...\nHOME=/user/home/gent/vsc400/vsc40000\n...\n</code></pre> <p>You can also use the <code>grep</code> command to search for a piece of text. The following command will output all VSC-specific variable names and their values:</p> <pre><code>$ env | sort | grep VSC</code></pre> <p>But we can also define our own. this is done with the <code>export</code> command (note: variables are always all-caps as a convention):</p> <pre><code>$ export MYVARIABLE=\"value\"</code></pre> <p>It is important you don't include spaces around the <code>=</code> sign. Also note the lack of <code>$</code> sign in front of the variable name.</p> <p>If we then do</p> <pre><code>$ echo $MYVARIABLE</code></pre> <p>this will output <code>value</code>. Note that the quotes are not included, they were only used when defining the variable to escape potential spaces in the value.</p>"}, {"location": "#changing-your-prompt-using-ps1", "title": "Changing your prompt using <code>$PS1</code>", "text": "<p>You can change what your prompt looks like by redefining the special-purpose variable <code>$PS1</code>.</p> <p>For example: to include the current location in your prompt:</p> <pre><code>$ export PS1='\\w $'\n~ $ cd test\n~/test $\n</code></pre> <p>Note that <code>~</code> is short representation of your home directory.</p> <p>To make this persistent across session, you can define this custom value for <code>$PS1</code> in your <code>.profile</code> startup script:</p> <pre><code>$ echo 'export PS1=\"\\w $ \" ' &gt;&gt; ~/.profile</code></pre>"}, {"location": "#using-non-defined-variables", "title": "Using non-defined variables", "text": "<p>One common pitfall is the (accidental) use of non-defined variables. Contrary to what you may expect, this does not result in error messages, but the variable is considered to be empty instead.</p> <p>This may lead to surprising results, for example:</p> <pre><code>$ export WORKDIR=/tmp/test\n$ pwd\n/user/home/gent/vsc400/vsc40000\n$ echo $HOME\n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>To understand what's going on here, see the section on <code>cd</code> below.</p> <p>The moral here is: be very careful to not use empty variables unintentionally.</p> <p>Tip for job scripts: use <code>set -e -u</code> to avoid using empty variables accidentally.</p> <p>The <code>-e</code> option will result in the script getting stopped if any command fails.</p> <p>The <code>-u</code> option will result in the script getting stopped if empty variables are used. (see https://ss64.com/bash/set.html for a more detailed explanation and more options)</p> <p>More information can be found at http://www.tldp.org/LDP/abs/html/variables.html.</p>"}, {"location": "#restoring-your-default-environment", "title": "Restoring your default environment", "text": "<p>If you've made a mess of your environment, you shouldn't waste too much time trying to fix it. Just log out and log in again and you will be given a pristine environment.</p>"}, {"location": "#basic-system-information", "title": "Basic system information", "text": "<p>Basic information about the system you are logged into can be obtained in a variety of ways.</p> <p>We limit ourselves to determining the hostname:</p> <pre><code>$ hostname\ngligar01.gligar.os\n\n$ echo $HOSTNAME\ngligar01.gligar.os\n</code></pre> <p>And querying some basic information about the Linux kernel:</p> <pre><code>$ uname -a\nLinux gligar01.gligar.os 2.6.32-573.8.1.el6.ug.x86_64 #1 SMP Mon Nov 16 15:12:09\n    CET 2015 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre>"}, {"location": "#exercises", "title": "Exercises", "text": "<ul> <li> <p>Print the full path to your home directory</p> </li> <li> <p>Determine the name of the environment variable to your personal     scratch directory</p> </li> <li> <p>What's the name of the system you're logged into? Is it the same for     everyone?</p> </li> <li> <p>Figure out how to print the value of a variable without including a     newline</p> </li> <li> <p>How do you get help on using the <code>man</code> command?</p> </li> </ul>"}, {"location": "beyond_the_basics/", "title": "Beyond the basics", "text": "<p>Now that you've seen some of the more basic commands, let's take a look at some of the deeper concepts and commands.</p>"}, {"location": "beyond_the_basics/#inputoutput", "title": "Input/output", "text": "<p>To redirect output to files, you can use the redirection operators: <code>&gt;</code>, <code>&gt;&gt;</code>, <code>&amp;&gt;</code>, and <code>&lt;</code>.</p> <p>First, it's important to make a distinction between two different output channels:</p> <ol> <li> <p><code>stdout</code>: standard output channel, for regular output</p> </li> <li> <p><code>stderr</code>: standard error channel, for errors and warnings</p> </li> </ol>"}, {"location": "beyond_the_basics/#redirecting-stdout", "title": "Redirecting <code>stdout</code>", "text": "<p><code>&gt;</code> writes the (<code>stdout</code>) output of a command to a file and overwrites whatever was in the file before.</p> <pre><code>$ echo hello &gt; somefile\n$ cat somefile\nhello\n$ echo hello2 &gt; somefile\n$ cat somefile\nhello2\n</code></pre> <p><code>&gt;&gt;</code> appends the (<code>stdout</code>) output of a command to a file; it does not clobber whatever was in the file before:</p> <pre><code>$ echo hello &gt; somefile\n$ cat somefile \nhello\n$ echo hello2 &gt;&gt; somefile\n$ cat somefile\nhello\nhello2\n</code></pre>"}, {"location": "beyond_the_basics/#reading-from-stdin", "title": "Reading from <code>stdin</code>", "text": "<p><code>&lt;</code> reads a file from standard input (piped or typed input). So you would use this to simulate typing into a terminal. <code>&lt; somefile.txt</code> is largely equivalent to <code>cat somefile.txt |</code>.</p> <p>One common use might be to take the results of a long-running command and store the results in a file, so you don't have to repeat it while you refine your command line. For example, if you have a large directory structure you might save a list of all the files you're interested in and then reading in the file list when you are done:</p> <pre><code>$ find . -name .txt &gt; files\n$ xargs grep banana &lt; files\n</code></pre>"}, {"location": "beyond_the_basics/#redirecting-stderr", "title": "Redirecting <code>stderr</code>", "text": "<p>To redirect the <code>stderr</code> output (warnings, messages), you can use <code>2&gt;</code>, just like <code>&gt;</code></p> <pre><code>$ ls one.txt nosuchfile.txt 2&gt; errors.txt\none.txt\n$ cat errors.txt\nls: nosuchfile.txt: No such file or directory\n</code></pre>"}, {"location": "beyond_the_basics/#combining-stdout-and-stderr", "title": "Combining <code>stdout</code> and <code>stderr</code>", "text": "<p>To combine both output channels (<code>stdout</code> and <code>stderr</code>) and redirect them to a single file, you can use <code>&amp;&gt;</code></p> <pre><code>$ ls one.txt nosuchfile.txt &amp;&gt; ls.out\n$ cat ls.out\nls: nosuchfile.txt: No such file or directory\none.txt\n</code></pre>"}, {"location": "beyond_the_basics/#command-piping", "title": "Command piping", "text": "<p>Part of the power of the command line is to string multiple commands together to create useful results. The core of these is the pipe: <code>|</code>. For example, to see the number of files in a directory, we can pipe the (<code>stdout</code>) output of <code>ls</code> to <code>wc</code> (word count, but can also be used to count the number of lines with the <code>-l</code> flag).</p> <pre><code>$ ls | wc -l\n    42\n</code></pre> <p>A common pattern is to pipe the output of a command to <code>less</code> so you can examine or search the output:</p> <pre><code>$ find . | less</code></pre> <p>Or to look through your command history:</p> <pre><code>$ history | less</code></pre> <p>You can put multiple pipes in the same line. For example, which <code>cp</code> commands have we run?</p> <pre><code>$ history | grep cp | less</code></pre>"}, {"location": "beyond_the_basics/#shell-expansion", "title": "Shell expansion", "text": "<p>The shell will expand certain things, including:</p> <ol> <li> <p><code>*</code> wildcard: for example <code>ls t*txt</code> will list all files starting     with 't' and ending in 'txt'</p> </li> <li> <p>tab completion: hit the <code>&lt;tab&gt;</code> key to make the shell complete your     command line; works for completing file names, command names, etc.</p> </li> <li> <p><code>$...</code> or <code>${...}</code>: environment variables will be replaced with     their value; example: <code>echo \"I am $USER\"</code> or <code>echo \"I am ${USER}\"</code></p> </li> <li> <p>square brackets can be used to list a number of options for a     particular characters;  example: <code>ls *.[oe][0-9]</code>.  This will list all     files starting with whatever characters (<code>*</code>), then a dot (<code>.</code>),     then either an 'o' or an 'e' (<code>[oe]</code>), then a character from '0' to     '9' (so any digit) (<code>[0-9]</code>). So this filename will match:     <code>anything.o5</code>, but this one won't: <code>anything.o52</code>.</p> </li> </ol>"}, {"location": "beyond_the_basics/#process-information", "title": "Process information", "text": ""}, {"location": "beyond_the_basics/#ps-and-pstree", "title": "<code>ps</code> and <code>pstree</code>", "text": "<p><code>ps</code> lists processes running. By default, it will only show you the processes running in the local shell. To see all of your processes running on the system, use:</p> <pre><code>$ ps -fu $USER</code></pre> <p>To see all the processes:</p> <pre><code>$ ps -elf</code></pre> <p>To see all the processes in a forest view, use:</p> <pre><code>$ ps auxf</code></pre> <p>The last two will spit out a lot of data, so get in the habit of piping it to <code>less</code>.</p> <p><code>pstree</code> is another way to dump a tree/forest view. It looks better than <code>ps auxf</code> but it has much less information so its value is limited.</p> <p><code>pgrep</code> will find all the processes where the name matches the pattern and print the process IDs (PID). This is used in piping the processes together as we will see in the next section.</p>"}, {"location": "beyond_the_basics/#kill", "title": "<code>kill</code>", "text": "<p><code>ps</code> isn't very useful unless you can manipulate the processes. We do this using the <code>kill</code> command. Kill will send a message (SIGINT) to the process to ask it to stop.</p> <pre><code>$ kill 1234\n$ kill $(pgrep misbehaving_process)\n</code></pre> <p>Usually, this ends the process, giving it the opportunity to flush data to files, etc. However, if the process ignored your signal, you can send it a different message (SIGKILL) which the OS will use to unceremoniously terminate the process:</p> <pre><code>$ kill -9 1234\n</code></pre>"}, {"location": "beyond_the_basics/#top", "title": "<code>top</code>", "text": "<p><code>top</code> is a tool to see the current status of the system. You've probably used something similar in Task Manager on Windows or Activity Monitor in macOS. <code>top</code> will update every second and has a few interesting commands.</p> <p>To see only your processes, type <code>u</code> and your username after starting <code>top</code>, (you can also do this with  <code>top -u $USER</code> ). The default is to sort the display by <code>%CPU</code>. To change the sort order, use <code>&lt;</code> and <code>&gt;</code> like arrow keys.</p> <p>There are a lot of configuration options in <code>top</code>, but if you're interested in seeing a nicer view, you can run <code>htop</code> instead. Be aware that it's not installed everywhere, while <code>top</code> is.</p> <p>To exit <code>top</code>, use <code>q</code> (for 'quit').</p> <p>For more information, see Brendan Gregg's excellent site dedicated to performance analysis.</p>"}, {"location": "beyond_the_basics/#ulimit", "title": "ulimit", "text": "<p><code>ulimit</code> is a utility to get or set user limits on the machine. For example, you may be limited to a certain number of processes. To see all the limits that have been set, use:</p> <pre><code>$ ulimit -a</code></pre>"}, {"location": "beyond_the_basics/#counting-wc", "title": "Counting: <code>wc</code>", "text": "<p>To count the number of lines, words, and characters (or bytes) in a file, use <code>wc</code> (word ount):</p> <pre><code>$ wc example.txt\n      90     468     3189   example.txt\n</code></pre> <p>The output indicates that the file named <code>example.txt</code> contains 90 lines, 468 words, and 3189 characters/bytes.</p> <p>To only count the number of lines, use <code>wc -l</code>:</p> <pre><code>$ wc -l example.txt\n      90    example.txt\n</code></pre>"}, {"location": "beyond_the_basics/#searching-file-contents-grep", "title": "Searching file contents: <code>grep</code>", "text": "<p><code>grep</code> is an important command. It was originally an abbreviation for \"globally search a regular expression and print\" but it's entered the common computing lexicon and people use 'grep' to mean searching for anything. To use grep, you give a pattern and a list of files.</p> <pre><code>$ grep banana fruit.txt\n$ grep banana fruit_bowl1.txt fruit_bowl2.txt\n$ grep banana fruit*txt\n</code></pre> <p><code>grep</code> also lets you search for Regular Expressions, but these are not in scope for this introductory text.</p>"}, {"location": "beyond_the_basics/#cut", "title": "<code>cut</code>", "text": "<p><code>cut</code> is used to pull fields out of files or pipes streams. It's a useful glue when you mix it with <code>grep</code> because <code>grep</code> can find the lines where a string occurs and <code>cut</code> can pull out a particular field. For example, to pull the first column (<code>-f 1</code>, the first field) from (an unquoted) CSV (comma-separated values, so <code>-d ','</code>: delimited by <code>,</code>) file, you can use the following:</p> <pre><code>$ cut -f 1 -d ',' mydata.csv</code></pre>"}, {"location": "beyond_the_basics/#sed", "title": "<code>sed</code>", "text": "<p><code>sed</code> is the stream editor. It is used to replace text in a file or piped stream. In this way, it works like grep, but instead of just searching, it can also edit files. This is like \"Search and Replace\" in a text editor. <code>sed</code> has a lot of features, but almost everyone uses the extremely basic version of string replacement:</p> <pre><code>$ sed 's/oldtext/newtext/g' myfile.txt</code></pre> <p>By default, sed will just print the results. If you want to edit the file inplace, use <code>-i</code>, but be very careful that the results will be what you want before you go around destroying your data!</p>"}, {"location": "beyond_the_basics/#awk", "title": "<code>awk</code>", "text": "<p><code>awk</code> is a basic language that builds on <code>sed</code> to do much more advanced stream editing. Going in depth is far out of scope of this tutorial, but there are two examples that are worth knowing.</p> <p>First, <code>cut</code> is very limited in pulling fields apart based on whitespace. For example, if you have padded fields then <code>cut -f 4 -d ' '</code> will almost certainly give you a headache as there might be an uncertain number of spaces between each field. <code>awk</code> does better whitespace splitting. So, pulling out the fourth field in a whitespace delimited file is as follows:</p> <pre><code>$ awk '{print $4}' mydata.dat</code></pre> <p>You can use <code>-F ':'</code> to change the delimiter (F for field separator).</p> <p>The next example is used to sum numbers from a field:</p> <pre><code>$ awk -F ',' '{sum += $1} END {print sum}' mydata.csv</code></pre>"}, {"location": "beyond_the_basics/#basic-shell-scripting", "title": "Basic Shell Scripting", "text": "<p>The basic premise of a script is to execute automate the execution of multiple commands. If you find yourself repeating the same commands over and over again, you should consider writing one script to do the same. A script is nothing special, it is just a text file like any other. Any commands you put in there will be executed from the top to bottom.</p> <p>However, there are some rules you need to abide by.</p> <p>Here is a very detailed guide should you need more information.</p>"}, {"location": "beyond_the_basics/#shebang", "title": "Shebang", "text": "<p>The first line of the script is the so-called shebang (<code>#</code> is sometimes called hash and <code>!</code> is sometimes called bang). This line tells the shell which command should execute the script. In most cases, this will simply be the shell itself. The line itself looks a bit weird, but you can copy-paste this line as you need not worry about it further. It is however very important this is the very first line of the script! These are all valid shebangs, but you should only use one of them:</p> <p><pre><code>#!/bin/sh\n</code></pre> <pre><code>#!/bin/bash\n</code></pre> <pre><code>#!/usr/bin/env bash\n</code></pre></p>"}, {"location": "beyond_the_basics/#conditionals", "title": "Conditionals", "text": "<p>Sometimes you only want certain commands to be executed when a certain condition is met. For example, only move files to a directory if that directory exists. The syntax: <pre><code>if [ -d directory ] &amp;&amp; [ -f file ]\nthen mv file directory fi\n\nOr you only want to do something if a file exists:\n\nif [ -f filename ] then echo \"it exists\" fi\n</code></pre> Or only if a certain variable is bigger than one: <pre><code>if [ $AMOUNT -gt 1 ]\nthen\necho \"More than one\"\n# more commands\nfi\n</code></pre> Several pitfalls exist with this syntax. You need spaces surrounding the brackets, the then needs to be at the beginning of a line. It is best to just copy this example and modify it.</p> <p>In the initial example, we used <code>-d</code> to test if a directory existed. There are several more checks.</p> <p>Another useful example, is to test if a variable contains a value (so it's not empty): <pre><code>if [ -z $PBS_ARRAYID ]\nthen\necho \"Not an array job, quitting.\"\nexit 1\nfi\n</code></pre></p> <p>the <code>-z</code> will check if the length of the variable's value is greater than zero.</p>"}, {"location": "beyond_the_basics/#loops", "title": "Loops", "text": "<p>Are you copy-pasting commands? Are you doing the same thing with just different options? You most likely can simplify your script by using a loop.</p> <p>Let's look at a simple example: <pre><code>for i in 1 2 3\ndo\necho $i\ndone\n</code></pre></p>"}, {"location": "beyond_the_basics/#subcommands", "title": "Subcommands", "text": "<p>Subcommands are used all the time in shell scripts. What they do is storing the output of a command in a variable. So this can later be used in a conditional or a loop for example.</p> <pre><code>CURRENTDIR=`pwd`  # using backticks\nCURRENTDIR=$(pwd)  # recommended (easier to type)\n</code></pre> <p>In the above example you can see the 2 different methods of using a subcommand. <code>pwd</code> will output the current working directory, and its output will be stored in the CURRENTDIR variable. The recommended way to use subcommands is with the <code>$()</code> syntax.</p>"}, {"location": "beyond_the_basics/#errors", "title": "Errors", "text": "<p>Sometimes some things go wrong and a command or script you ran causes an error. How do you properly deal with these situations?</p> <p>Firstly a useful thing to know for debugging and testing is that you can run any command like this:</p> <pre><code>command 2&gt;&amp;1 output.log   # one single output file, both output and errors</code></pre> <p>If you add <code>2&gt;&amp;1 output.log</code> at the end of any command, it will combine <code>stdout</code> and <code>stderr</code>, outputting it into a single file named <code>output.log</code>.</p> <p>If you want regular and error output separated you can use:</p> <pre><code>command &gt; output.log 2&gt; output.err  # errors in a separate file</code></pre> <p>this will write regular output to <code>output.log</code> and error output to <code>output.err</code>.</p> <p>You can then look for the errors with <code>less</code> or search for specific text with <code>grep</code>.</p> <p>In scripts, you can use:</p> <pre><code>set -e</code></pre> <p>This will tell the shell to stop executing any subsequent commands when a single command in the script fails. This is most convenient as most likely this causes the rest of the script to fail as well.</p>"}, {"location": "beyond_the_basics/#advanced-error-checking", "title": "Advanced error checking", "text": "<p>Sometimes you want to control all the error checking yourself, this is also possible. Everytime you run a command, a special variable <code>$?</code> is used to denote successful completion of the command. A value other than zero signifies something went wrong. So an example use case: <pre><code>command_with_possible_error\nexit_code=$?  # capture exit code of last command\nif [ $exit_code -ne 0 ]\nthen\necho \"something went wrong\"\nfi\n</code></pre></p>"}, {"location": "beyond_the_basics/#bashrc-login-script", "title": "<code>.bashrc</code> login script", "text": "<p>If you have certain commands executed every time you log in (which includes every time a job starts), you can add them to your <code>$HOME/.bashrc</code> file. This file is a shell script that gets executed every time you log in.</p> <p>Examples include:</p> <ul> <li> <p>modifying your <code>$PS1</code> (to tweak your shell prompt)</p> </li> <li> <p>printing information about the current/jobs environment (echoing     environment variables, etc.)</p> </li> <li> <p>selecting a specific cluster to run on with     <code>module swap cluster/...</code></p> </li> </ul> <p>Some recommendations:</p> <ul> <li> <p>Avoid using <code>module load</code> statements in your <code>$HOME/.bashrc</code> file</p> </li> <li> <p>Don't directly edit your <code>.bashrc</code> file: if there's an error in your     <code>.bashrc</code> file, you might not be able to log in again. To     prevent that, use another file to test your changes, then copy them     over when you tested the script.</p> </li> </ul>"}, {"location": "beyond_the_basics/#scripting-for-the-cluster", "title": "Scripting for the cluster", "text": "<p>When writing scripts to be submitted on the cluster there are some tricks you need to keep in mind.</p>"}, {"location": "beyond_the_basics/#example-job-script", "title": "Example job script", "text": "<pre><code>#!/bin/bash\n#PBS -l nodes=1:ppn=1\n#PBS -N FreeSurfer_per_subject-time-longitudinal\n#PBS -l walltime=48:00:00\n#PBS -q long\n#PBS -m abe\n#PBS -j oe\nexport DATADIR=$VSC_DATA/example\n# $PBS_JOBID is unique for each job, so this creates a unique directory\nexport WORKDIR=$VSC_SCRATCH_NODE/$PBS_JOBID\nmkdir -p $WORKDIR\n# copy files to local storage\ncp -a $DATADIR/workfiles $WORKDIR/\n\n# load software we need\nmodule load FreeSurfer\ncd $WORKDIR\n# recon-all ... &amp;&gt; output.log  # this command takes too long, let's show a more practical example\necho $PBS_ARRAYID &gt; $WORKDIR/$PBS_ARRAYID.txt\n# create results directory if necessary\nmkdir -p $DATADIR/results\n# copy work files back\ncp $WORKDIR/$PBS_ARRAYID.txt $DATADIR/results/\n</code></pre>"}, {"location": "beyond_the_basics/#pbs-pragmas", "title": "PBS pragmas", "text": "<p>The scheduler needs to know about the requirements of the script, for example: how much memory will it use, and how long will it run. These things can be specified inside a script with what we call PBS pragmas.</p> <p>This pragma (a pragma is a special comment) tells PBS to use 1 node and core: <pre><code>#PBS -l nodes=1:ppn=1 # single-core\n</code></pre></p> <p>For parallel software, you can request multiple cores (OpenMP) and/or multiple nodes (MPI). Only use this when the software you use is capable of working in parallel. Here is an example: <pre><code>#PBS -l nodes=1:ppn=16  # single-node, multi-core\n#PBS -l nodes=5:ppn=16  # multi-node\n</code></pre></p> <p>We intend to submit it on the long queue: <pre><code>#PBS -q long\n</code></pre></p> <p>We request a total running time of 48 hours (2 days). <pre><code>#PBS -l walltime=48:00:00\n</code></pre></p> <p>We specify a desired name of our job: <pre><code>#PBS -N FreeSurfer_per_subject-time-longitudinal\n</code></pre> This specifies mail options: <pre><code>#PBS -m abe\n</code></pre></p> <ol> <li> <p><code>a</code> means mail is sent when the job is aborted.</p> </li> <li> <p><code>b</code> means mail is sent when the job begins.</p> </li> <li> <p><code>e</code> means mail is sent when the job ends.</p> </li> </ol> <p>Joins error output with regular output: <pre><code>#PBS -j oe\n</code></pre></p> <p>All of these options can also be specified on the command-line and will overwrite any pragmas present in the script.</p>"}, {"location": "beyond_the_basics/#exercises", "title": "Exercises", "text": "<ol> <li> <p>Create a file that contains this message: \"Hello, I am &lt;user&gt;\",     where <code>&lt;user&gt;</code> is replaced by your username. Don't cheat by using an     editor, use a command to create the file.</p> </li> <li> <p>Use another command to add this line to the same file: \"I am on     system &lt;hostname&gt; in directory &lt;current\u00a0directory&gt;\". Words     between <code>&lt;&gt;</code> should be replaced with their value (hint: use     environment variables).</p> </li> <li> <p>How many files and directories are in <code>/tmp</code>?</p> </li> <li> <p>What's the name of the 5th file/directory in alphabetical order in     <code>/tmp</code>?</p> </li> <li> <p>List all files that start with <code>t</code> in <code>/tmp</code>.</p> </li> <li> <p>Create a file containing \"My home directory &lt;home&gt; is available     using $HOME\". <code>&lt;home&gt;</code> should be replaced with your home directory,     but <code>$HOME</code> should remain as-is.</p> </li> <li> <p>How many processes are you currently running? How many are you     allowed to run? Where are they coming from?</p> </li> </ol>"}, {"location": "common_pitfalls/", "title": "Common Pitfalls", "text": ""}, {"location": "common_pitfalls/#files", "title": "Files", "text": ""}, {"location": "common_pitfalls/#location", "title": "Location", "text": "<p>If you receive an error message which contains something like the following: <pre><code>No such file or directory\n</code></pre></p> <p>It probably means that you haven't placed your files in the correct directory, or you have mistyped the file name or path.</p> <p>Try and figure out the correct location using <code>ls</code>, <code>cd</code> and using the different <code>$VSC_*</code> variables.</p>"}, {"location": "common_pitfalls/#spaces", "title": "Spaces", "text": "<p>Filenames should not contain any spaces! If you have a long filename you should use underscores or dashes (e.g., <code>very_long_filename</code>).</p> <pre><code>$ cat some file\nNo such file or directory 'some'\n</code></pre> <p>Spaces are permitted, however they result in surprising behaviour. To cat the file <code>'some file'</code> as above, you can escape the space with a backslash (\"<code>\\</code>\") or you can put the filename in quotes:</p> <pre><code>$ cat some\\ file\n...\n$ cat \"some file\"\n...\n</code></pre> <p>This is especially error prone if you are piping results of <code>find</code>:</p> <pre><code>$ find . -type f | xargs cat\nNo such file or directory name \u2019some\u2019\nNo such file or directory name \u2019file\u2019\n</code></pre> <p>This can be worked around using the <code>-print0</code> flag:</p> <pre><code>$ find . -type f -print0 | xargs -0 cat\n...\n</code></pre> <p>But, this is tedious, and you can prevent errors by simply colouring within the lines and not using spaces in filenames.</p>"}, {"location": "common_pitfalls/#missingmistyped-environment-variables", "title": "Missing/mistyped environment variables", "text": "<p>If you use a command like <code>rm -r</code> with environment variables you need to be careful to make sure that the environment variable exists. If you mistype an environment variable then it will resolve into a blank string. This means the following resolves to <code>rm -r ~/*</code> which will remove every file in your home directory!</p> <pre><code>$ rm -r ~/$PROJETC/*</code></pre>"}, {"location": "common_pitfalls/#typing-dangerous-commands", "title": "Typing dangerous commands", "text": "<p>A good habit when typing dangerous commands is to precede the line with <code>#</code>, the comment character. This will let you type out the command without fear of accidentally hitting enter and running something unintended.</p> <pre><code>$ #rm -r ~/$POROJETC/*</code></pre> <p>Then you can go back to the beginning of the line (<code>Ctrl-A</code>) and remove the first character (<code>Ctrl-D</code>) to run the command. You can also just press enter to put the command in your history so you can come back to it later (e.g., while you go check the spelling of your environment variables).</p>"}, {"location": "common_pitfalls/#permissions", "title": "Permissions", "text": "<pre><code>$ ls -l script.sh # File with correct permissions\n-rwxr-xr-x 1 vsc40000 vsc40000 2983 Jan 30 09:13 script.sh\n$ ls -l script.sh # File with incorrect permissions\n-rw-r--r-- 1 vsc40000 vsc40000 2983 Jan 30 09:13 script.sh\n</code></pre> <p>Before submitting the script, you'll need to add execute permissions to make sure it can be executed:</p> <pre><code>$ chmod +x script_name.sh</code></pre>"}, {"location": "common_pitfalls/#help", "title": "Help", "text": "<p>If you stumble upon an error, don't panic! Read the error output, it might contain a clue as to what went wrong. You can copy the error message into Google (selecting a small part of the error without filenames). It can help if you surround your search terms in double quotes (for example <code>\"No such file or directory\"</code>), that way Google will consider the error as one thing, and won't show results just containing these words in random order.</p> <p>If you need help about a certain command, you should consult its so-called \"man page\":</p> <pre><code>$ man command</code></pre> <p>This will open the manual of this command. This manual contains detailed explanation of all the options the command has. Exiting the manual is done by pressing 'q'.</p> <p>Don't be afraid to contact hpc@ugent.be. They are here to help and will do so for even the  smallest of problems!</p>"}, {"location": "common_pitfalls/#more-information", "title": "More information", "text": "<ol> <li> <p>Unix Power Tools - A fantastic  book about most of these tools (see also The Second Edition)</p> </li> <li> <p>http://linuxcommand.org/: A great place to start with many     examples. There is an associated book which gets a lot of good     reviews</p> </li> <li> <p>The Linux Documentation Project -     More guides on various topics relating to the Linux command line</p> </li> <li> <p>basic shell     usage</p> </li> <li> <p>Bash for     beginners</p> </li> <li> <p>MOOC</p> </li> </ol>"}, {"location": "common_pitfalls/#q-a", "title": "Q &amp; A", "text": "<p>Please don't hesitate to contact in case of questions or problems.</p>"}, {"location": "getting_started/", "title": "Getting Started", "text": ""}, {"location": "getting_started/#logging-in", "title": "Logging in", "text": "<p>To get started with the HPC-UGent infrastructure, you need to obtain a VSC account, see HPC manual. Keep in mind that you must keep your private key to yourself!</p> <p>You can look at your public/private key pair as a lock and a key: you give us the lock (your public key), we put it on the door, and then you can use your key to open the door and get access to the HPC infrastructure. Anyone who has your key can use your VSC account!</p> <p>Details on connecting to the HPC infrastructure are available in HPC manual connecting section.</p>"}, {"location": "getting_started/#getting-help", "title": "Getting help", "text": "<p>To get help:</p> <ol> <li> <p>use the documentation available on the system, through the <code>help</code>,     <code>info</code> and <code>man</code> commands (use <code>q</code> to exit).     <pre><code>help cd\ninfo ls\nman cp\n</code></pre></p> </li> <li> <p>use Google</p> </li> <li> <p>contact hpc@ugent.be in case  of problems or questions (even for basic things!)</p> </li> </ol>"}, {"location": "getting_started/#errors", "title": "Errors", "text": "<p>Sometimes when executing a command, an error occurs. Most likely there will be error output or a message explaining you this. Read this carefully and try to act on it. Try googling the error first to find any possible solution, but if you can't come up with something in 15 minutes, don't hesitate to mail hpc@ugent.be.</p>"}, {"location": "getting_started/#basic-terminal-usage", "title": "Basic terminal usage", "text": "<p>The basic interface is the so-called shell prompt, typically ending with <code>$</code> (for <code>bash</code> shells).</p> <p>You use the shell by executing commands, and hitting <code>&lt;enter&gt;</code>. For example:</p> <pre><code>$ echo hello\nhello\n</code></pre> <p>You can go to the start or end of the command line using <code>Ctrl-A</code> or <code>Ctrl-E</code>.</p> <p>To go through previous commands, use <code>&lt;up&gt;</code> and <code>&lt;down&gt;</code>, rather than retyping them.</p>"}, {"location": "getting_started/#command-history", "title": "Command history", "text": "<p>A powerful feature is that you can \"search\" through your command history, either using the <code>history</code> command, or using <code>Ctrl-R</code>:</p> <pre><code>$ history\n    1 echo hello\n\n# hit Ctrl-R, type 'echo' \n(reverse-i-search)`echo': echo hello\n</code></pre>"}, {"location": "getting_started/#stopping-commands", "title": "Stopping commands", "text": "<p>If for any reason you want to stop a command from executing, press <code>Ctrl-C</code>. For example, if a command is taking too long, or you want to rerun it with different arguments.</p>"}, {"location": "getting_started/#variables", "title": "Variables", "text": "<p>At the prompt we also have access to shell variables, which have both a name and a value.</p> <p>They can be thought of as placeholders for things we need to remember.</p> <p>For example, to print the path to your home directory, we can use the shell variable named <code>HOME</code>:</p> <pre><code>$ echo $HOME\n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>This prints the value of this variable.</p>"}, {"location": "getting_started/#defining-variables", "title": "Defining variables", "text": "<p>There are several variables already defined for you when you start your session, such as <code>$HOME</code> which contains the path to your home directory.</p> <p>For a full overview of defined environment variables in your current session, you can use the <code>env</code> command. You can sort this output with <code>sort</code> to make it easier to search in:</p> <pre><code>$ env | sort\n...\nHOME=/user/home/gent/vsc400/vsc40000\n...\n</code></pre> <p>You can also use the <code>grep</code> command to search for a piece of text. The following command will output all VSC-specific variable names and their values:</p> <pre><code>$ env | sort | grep VSC</code></pre> <p>But we can also define our own. this is done with the <code>export</code> command (note: variables are always all-caps as a convention):</p> <pre><code>$ export MYVARIABLE=\"value\"</code></pre> <p>It is important you don't include spaces around the <code>=</code> sign. Also note the lack of <code>$</code> sign in front of the variable name.</p> <p>If we then do</p> <pre><code>$ echo $MYVARIABLE</code></pre> <p>this will output <code>value</code>. Note that the quotes are not included, they were only used when defining the variable to escape potential spaces in the value.</p>"}, {"location": "getting_started/#changing-your-prompt-using-ps1", "title": "Changing your prompt using <code>$PS1</code>", "text": "<p>You can change what your prompt looks like by redefining the special-purpose variable <code>$PS1</code>.</p> <p>For example: to include the current location in your prompt:</p> <pre><code>$ export PS1='\\w $'\n~ $ cd test\n~/test $\n</code></pre> <p>Note that <code>~</code> is short representation of your home directory.</p> <p>To make this persistent across session, you can define this custom value for <code>$PS1</code> in your <code>.profile</code> startup script:</p> <pre><code>$ echo 'export PS1=\"\\w $ \" ' &gt;&gt; ~/.profile</code></pre>"}, {"location": "getting_started/#using-non-defined-variables", "title": "Using non-defined variables", "text": "<p>One common pitfall is the (accidental) use of non-defined variables. Contrary to what you may expect, this does not result in error messages, but the variable is considered to be empty instead.</p> <p>This may lead to surprising results, for example:</p> <pre><code>$ export WORKDIR=/tmp/test\n$ pwd\n/user/home/gent/vsc400/vsc40000\n$ echo $HOME\n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>To understand what's going on here, see the section on <code>cd</code> below.</p> <p>The moral here is: be very careful to not use empty variables unintentionally.</p> <p>Tip for job scripts: use <code>set -e -u</code> to avoid using empty variables accidentally.</p> <p>The <code>-e</code> option will result in the script getting stopped if any command fails.</p> <p>The <code>-u</code> option will result in the script getting stopped if empty variables are used. (see https://ss64.com/bash/set.html for a more detailed explanation and more options)</p> <p>More information can be found at http://www.tldp.org/LDP/abs/html/variables.html.</p>"}, {"location": "getting_started/#restoring-your-default-environment", "title": "Restoring your default environment", "text": "<p>If you've made a mess of your environment, you shouldn't waste too much time trying to fix it. Just log out and log in again and you will be given a pristine environment.</p>"}, {"location": "getting_started/#basic-system-information", "title": "Basic system information", "text": "<p>Basic information about the system you are logged into can be obtained in a variety of ways.</p> <p>We limit ourselves to determining the hostname:</p> <pre><code>$ hostname\ngligar01.gligar.os\n\n$ echo $HOSTNAME\ngligar01.gligar.os\n</code></pre> <p>And querying some basic information about the Linux kernel:</p> <pre><code>$ uname -a\nLinux gligar01.gligar.os 2.6.32-573.8.1.el6.ug.x86_64 #1 SMP Mon Nov 16 15:12:09\n    CET 2015 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre>"}, {"location": "getting_started/#exercises", "title": "Exercises", "text": "<ul> <li> <p>Print the full path to your home directory</p> </li> <li> <p>Determine the name of the environment variable to your personal     scratch directory</p> </li> <li> <p>What's the name of the system you're logged into? Is it the same for     everyone?</p> </li> <li> <p>Figure out how to print the value of a variable without including a     newline</p> </li> <li> <p>How do you get help on using the <code>man</code> command?</p> </li> </ul>"}, {"location": "hpc_infrastructure/", "title": "More on the HPC infrastructure", "text": ""}, {"location": "hpc_infrastructure/#filesystems", "title": "Filesystems", "text": "<p>Multiple different shared filesystems are available on the HPC infrastructure, each with their own purpose. See section Where to store your data on the HPC for a list of available locations.</p>"}, {"location": "hpc_infrastructure/#vo-storage", "title": "VO storage", "text": "<p>If you are a member of a (non-default) virtual organisation (VO), see section Virtual Organisations, you have access to additional directories (with more quota) on the data and scratch filesystems, which you can share with other members in the VO.</p>"}, {"location": "hpc_infrastructure/#quota", "title": "Quota", "text": "<p>Space is limited on the cluster's storage. To check your quota, see section Pre-defined quota.</p> <p>To figure out where your quota is being spent, the <code>du</code> (isk sage) command can come in useful:</p> <pre><code>$ du -sh test\n59M test\n</code></pre> <p>Do not (frequently) run <code>du</code> on directories where large amounts of data are stored, since that will:</p> <ol> <li> <p>take a long time</p> </li> <li> <p>result in increased load on the shared storage since (the metadata     of) every file in those directories will have to be inspected.</p> </li> </ol>"}, {"location": "hpc_infrastructure/#modules", "title": "Modules", "text": "<p>Software is provided through so-called environment modules.</p> <p>The most commonly used commands are:</p> <ol> <li> <p><code>module avail</code>: show all available modules</p> </li> <li> <p><code>module avail &lt;software name&gt;</code>: show available modules for a     specific software name</p> </li> <li> <p><code>module list</code>: show list of loaded modules</p> </li> <li> <p><code>module load &lt;module name&gt;</code>: load a particular module</p> </li> </ol> <p>More information is available in section Modules.</p>"}, {"location": "hpc_infrastructure/#using-the-clusters", "title": "Using the clusters", "text": "<p>The use the clusters beyond the login node(s) which have limited resources, you should create job scripts and submit them to the clusters.</p> <p>Detailed information is available in section submitting your job.</p>"}, {"location": "hpc_infrastructure/#exercises", "title": "Exercises", "text": "<p>Create and submit a job script that computes the sum of 1-100 using Python, and prints the numbers to a unique output file in <code>$VSC_SCRATCH</code>.</p> <p>Hint: <code>python -c \"print(sum(range(1, 101)))\"</code></p> <ul> <li>How many modules are available for Python version 3.6.4?</li> <li>How many modules get loaded when you load the <code>Python/3.6.4-intel-2018a</code> module?</li> <li>Which <code>cluster</code> modules are available?</li> </ul> <ul> <li>What's the full path to your personal home/data/scratch directories?</li> <li>Determine how large your personal directories are.</li> <li>What's the difference between the size reported by <code>du -sh $HOME</code> and by <code>ls -ld $HOME</code>?</li> </ul>"}, {"location": "manipulating_files_and_directories/", "title": "Manipulating files and directories", "text": "<p>Being able to manage your data is an important part of using the HPC infrastructure. The bread and butter commands for doing this are mentioned here. It might seem annoyingly terse at first, but with practice you will realise that it's very practical to have such common commands short to type.</p>"}, {"location": "manipulating_files_and_directories/#file-contents-cat-head-tail-less-more", "title": "File contents: \"cat\", \"head\", \"tail\", \"less\", \"more\"", "text": "<p>To print the contents of an entire file, you can use <code>cat</code>; to only see the first or last N lines, you can use <code>head</code> or <code>tail</code>:</p> <pre><code>$ cat one.txt\n1\n2\n3\n4\n5\n\n$ head -2 one.txt\n1\n2\n\n$ tail -2 one.txt\n4\n5\n</code></pre> <p>To check the contents of long text files, you can use the <code>less</code> or <code>more</code> commands which support scrolling with \"&lt;up&gt;\", \"&lt;down&gt;\", \"&lt;space&gt;\", etc.</p>"}, {"location": "manipulating_files_and_directories/#copying-files-cp", "title": "Copying files: \"cp\"", "text": "<pre><code>$ cp source target\n</code></pre> <p>This is the <code>cp</code> command, which copies a file from source to target. To copy a directory, we use the <code>-r</code> option:</p> <pre><code>$ cp -r sourceDirectory target\n</code></pre> <p>A last more complicated example:</p> <pre><code>$ cp -a sourceDirectory target\n</code></pre> <p>Here we used the same <code>cp</code> command, but instead we gave it the <code>-a</code> option which tells cp to copy all the files and keep timestamps and permissions.</p>"}, {"location": "manipulating_files_and_directories/#creating-directories-mkdir", "title": "Creating directories: \"mkdir\"", "text": "<pre><code>$ mkdir directory\n</code></pre> <p>which will create a directory with the given name inside the current directory.</p>"}, {"location": "manipulating_files_and_directories/#renamingmoving-files-mv", "title": "Renaming/moving files: \"mv\"", "text": "<pre><code>$ mv source target\n</code></pre> <p><code>mv</code> will move the source path to the destination path. Works for both directories as files.</p>"}, {"location": "manipulating_files_and_directories/#removing-files-rm", "title": "Removing files: \"rm\"", "text": "<p>Note: there are NO backups, there is no 'trash bin'. If you remove files/directories, they are gone.</p> <pre><code>$ rm filename\n</code></pre> <p><code>rm</code> will remove a file or directory. (<code>rm -rf directory</code> will remove every file inside a given directory). WARNING: files removed will be lost forever, there are no backups, so beware when using this command!</p>"}, {"location": "manipulating_files_and_directories/#removing-a-directory-rmdir", "title": "Removing a directory: \"rmdir\"", "text": "<p>You can remove directories using <code>rm -r directory</code>, however, this is error prone and can ruin your day if you make a mistake in typing. To prevent this type of error, you can remove the contents of a directory using <code>rm</code> and then finally removing the directory with:</p> <pre><code>$ rmdir directory\n</code></pre>"}, {"location": "manipulating_files_and_directories/#changing-permissions-chmod", "title": "Changing permissions: \"chmod\"", "text": "<p>Every file, directory, and link has a set of permissions. These permissions consist of permission groups and permission types. The permission groups are:</p> <ol> <li> <p>User - a particular user (account)</p> </li> <li> <p>Group - a particular group of users (may be user-specific group with     only one member)</p> </li> <li> <p>Other - other users in the system</p> </li> </ol> <p>The permission types are:</p> <ol> <li> <p>Read - For files, this gives permission to read the contents of a     file</p> </li> <li> <p>Write - For files, this gives permission to write data to the file.     For directories it allows users to add or remove files to a     directory.</p> </li> <li> <p>Execute - For files this gives permission to execute a file as     through it were a script. For directories, it allows users to open     the directory and look at the contents.</p> </li> </ol> <p>Any time you run <code>ls -l</code> you'll see a familiar line of <code>-rwx------</code> or similar combination of the letters <code>r</code>, <code>w</code>, <code>x</code> and <code>-</code> (dashes). These are the permissions for the file or directory. (See also the  previous section on permissions)</p> <pre><code>$ ls -l\ntotal 1\n-rw-r--r--. 1 vsc40000 mygroup 4283648 Apr 12 15:13 articleTable.csv\ndrwxr-x---. 2 vsc40000 mygroup 40 Apr 12 15:00 Project_GoldenDragon\n</code></pre> <p>Here, we see that <code>articleTable.csv</code> is a file (beginning the line with <code>-</code>) has read and write permission for the user <code>vsc40000</code> (<code>rw-</code>), and read permission for the group <code>mygroup</code> as well as all other users (<code>r--</code> and <code>r--</code>).</p> <p>The next entry is <code>Project_GoldenDragon</code>. We see it is a directory because the line begins with a <code>d</code>. It also has read, write, and execute permission for the <code>vsc40000</code> user (<code>rwx</code>). So that user can look into the directory and add or remove files. Users in the <code>mygroup</code> can also look into the directory and read the files. But they can't add or remove files (<code>r-x</code>). Finally, other users can read files in the directory, but other users have no permissions to look in the directory at all (<code>---</code>).</p> <p>Maybe we have a colleague who wants to be able to add files to the directory. We use <code>chmod</code> to change the modifiers to the directory to let people in the group write to the directory:</p> <pre><code>$ chmod g+w Project_GoldenDragon\n$ ls -l\ntotal 1\n-rw-r--r--. 1 vsc40000 mygroup 4283648 Apr 12 15:13 articleTable.csv\ndrwxrwx---. 2 vsc40000 mygroup 40 Apr 12 15:00 Project_GoldenDragon\n</code></pre> <p>The syntax used here is <code>g+x</code> which means roup was given rite permission. To revoke it again, we use <code>g-w</code>. The other roles are <code>u</code> for user and <code>o</code> for other.</p> <p>You can put multiple changes on the same line: <code>chmod o-rwx,g-rxw,u+rx,u-w somefile</code> will take everyone's permission away except the user's ability to read or execute the file.</p> <p>You can also use the <code>-R</code> flag to affect all the files within a directory, but this is dangerous. It's best to refine your search using <code>find</code> and then pass the resulting list to <code>chmod</code> since it's not usual for all files in a directory structure to have the same permissions.</p>"}, {"location": "manipulating_files_and_directories/#access-control-lists-acls", "title": "Access control lists (ACLs)", "text": "<p>However, this means that all users in <code>mygroup</code> can add or remove files. This could be problematic if you only wanted one person to be allowed to help you administer the files in the project. We need a new group. To do this in the HPC environment, we need to use access control lists (ACLs):</p> <pre><code>$ setfacl -m u:otheruser:w Project_GoldenDragon\n$ ls -l Project_GoldenDragon\ndrwxr-x---+ 2 vsc40000 mygroup 40 Apr 12 15:00 Project_GoldenDragon\n</code></pre> <p>This will give the user <code>otheruser</code> permissions to write to <code>Project_GoldenDragon</code></p> <p>Now there is a <code>+</code> at the end of the line. This means there is an ACL attached to the directory. <code>getfacl Project_GoldenDragon</code> will print the ACLs for the directory.</p> <p>Note: most people don't use ACLs, but it's sometimes the right thing and you should be aware it exists.</p> <p>See https://linux.die.net/man/1/setfacl for more information.</p>"}, {"location": "manipulating_files_and_directories/#zipping-gzipgunzip-zipunzip", "title": "Zipping: \"gzip\"/\"gunzip\", \"zip\"/\"unzip\"", "text": "<p>Files should usually be stored in a compressed file if they're not being used frequently. This means they will use less space and thus you get more out of your quota. Some types of files (e.g., CSV files with a lot of numbers) compress as much as 9:1. The most commonly used compression format on Linux is gzip. To compress a file using gzip, we use:</p> <pre><code>$ ls -lh myfile\n-rw-r--r--. 1 vsc40000 vsc40000 4.1M Dec 2 11:14 myfile\n$ gzip myfile\n$ ls -lh myfile.gz\n-rw-r--r--. 1 vsc40000 vsc40000 1.1M Dec 2 11:14 myfile.gz\n</code></pre> <p>Note: if you zip a file, the original file will be removed. If you unzip a file, the compressed file will be removed. To keep both, we send the data to <code>stdout</code> and redirect it to the target file:</p> <pre><code>$ gzip -c myfile &gt; myfile.gz\n$ gunzip -c myfile.gz &gt; myfile\n</code></pre>"}, {"location": "manipulating_files_and_directories/#zip-and-unzip", "title": "\"zip\" and \"unzip\"", "text": "<p>Windows and macOS seem to favour the zip file format, so it's also important to know how to unpack those. We do this using unzip:</p> <pre><code>$ unzip myfile.zip\n</code></pre> <p>If we would like to make our own zip archive, we use zip:</p> <pre><code>$ zip myfiles.zip myfile1 myfile2 myfile3\n</code></pre>"}, {"location": "manipulating_files_and_directories/#working-with-tarballs-tar", "title": "Working with tarballs: \"tar\"", "text": "<p>Tar stands for \"tape archive\" and is a way to bundle files together in a bigger file.</p> <p>You will normally want to unpack these files more often than you make them. To unpack a <code>.tar</code> file you use:</p> <pre><code>$ tar -xf tarfile.tar\n</code></pre> <p>Often, you will find <code>gzip</code> compressed <code>.tar</code> files on the web. These are called tarballs. You can recognize them by the filename ending in <code>.tar.gz</code>. You can uncompress these using <code>gunzip</code> and then unpacking them using <code>tar</code>. But <code>tar</code> knows how to open them using the <code>-z</code> option:</p> <pre><code>$ tar -zxf tarfile.tar.gz\n$ tar -zxf tarfile.tgz\n</code></pre>"}, {"location": "manipulating_files_and_directories/#order-of-arguments", "title": "Order of arguments", "text": "<p>Note: Archive programs like <code>zip</code>, <code>tar</code>, and <code>jar</code> use arguments in the \"opposite direction\" of copy commands.</p> <pre><code># cp, ln: &lt;source(s)&gt; &lt;target&gt;\n$ cp source1 source2 source3 target\n$ ln -s source target\n\n# zip, tar: &lt;target&gt; &lt;source(s)&gt;\n$ zip zipfile.zip source1 source2 source3\n$ tar -cf tarfile.tar source1 source2 source3\n</code></pre> <p>If you use <code>tar</code> with the source files first then the first file will be overwritten. You can control the order of arguments of <code>tar</code> if it helps you remember:</p> <pre><code>$ tar -c source1 source2 source3 -f tarfile.tar</code></pre>"}, {"location": "manipulating_files_and_directories/#exercises", "title": "Exercises", "text": "<ol> <li> <p>Create a subdirectory in your home directory named <code>test</code> containing     a single, empty file named <code>one.txt</code>.</p> </li> <li> <p>Copy <code>/etc/hostname</code> into the <code>test</code> directory and then check what's     in it. Rename the file to <code>hostname.txt</code>.</p> </li> <li> <p>Make a new directory named <code>another</code> and copy the entire <code>test</code>     directory to it. <code>another/test/one.txt</code> should then be an empty     file.</p> </li> <li> <p>Remove the <code>another/test</code> directory with a single command.</p> </li> <li> <p>Rename <code>test</code> to <code>test2</code>. Move <code>test2/hostname.txt</code> to your home     directory.</p> </li> <li> <p>Change the permission of <code>test2</code> so only you can access it.</p> </li> <li> <p>Create an empty job script named <code>job.sh</code>, and make it executable.</p> </li> <li> <p>gzip <code>hostname.txt</code>, see how much smaller it becomes, then unzip it     again.</p> </li> </ol>"}, {"location": "navigating/", "title": "Navigating", "text": ""}, {"location": "navigating/#current-directory-pwd-and-pwd", "title": "Current directory: \"pwd\" and \"\\$PWD\"", "text": "<p>To print the current directory, use <code>pwd</code> or <code>$PWD</code>:</p> <pre><code>$ cd $HOME\n$ pwd\n/user/home/gent/vsc400/vsc40000\n$ echo \"The current directory is: $PWD\"\nThe current directory is: /user/home/gent/vsc400/vsc40000\n</code></pre>"}, {"location": "navigating/#listing-files-and-directories-ls", "title": "Listing files and directories: \"ls\"", "text": "<p>A very basic and commonly used command is <code>ls</code>, which can be used to list files and directories.</p> <p>In it's basic usage, it just prints the names of files and directories in the current directory. For example:</p> <pre><code>$ ls\nafile.txt some_directory\n</code></pre> <p>When provided an argument, it can be used to list the contents of a directory:</p> <pre><code>$ ls some_directory\none.txt two.txt\n</code></pre> <p>A couple of commonly used options include:</p> <ul> <li> <p>detailed listing using <code>ls -l</code>:     <pre><code>$ ls -l\ntotal 4224\n-rw-rw-r-- 1 vsc40000 vsc40000 2157404 Apr 12 13:17 afile.txt\ndrwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory</code></pre></p> </li> <li> <p>To print the size information in human-readable form, use the <code>-h</code>     flag:     <pre><code>$ ls -lh\ntotal 4.1M\n-rw-rw-r-- 1 vsc40000 vsc40000 2.1M Apr 12 13:16 afile.txt\ndrwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory</code></pre></p> </li> <li> <p>also listing hidden files using the <code>-a</code> flag:</p> <p><pre><code>$ ls -lah\ntotal 3.9M\ndrwxrwxr-x 3 vsc40000 vsc40000 512 Apr 12 13:11 .\ndrwx------ 188 vsc40000 vsc40000 128K Apr 12 12:41 ..\n-rw-rw-r-- 1 vsc40000 vsc40000 1.8M Apr 12 13:12 afile.txt\n-rw-rw-r-- 1 vsc40000 vsc40000 0 Apr 12 13:11 .hidden_file.txt\ndrwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory</code></pre></p> </li> <li> <p>ordering files by the most recent change using <code>-rt</code>:</p> <p><pre><code>$ ls -lrth\ntotal 4.0M\ndrwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory\n-rw-rw-r-- 1 vsc40000 vsc40000 2.0M Apr 12 13:15 afile.txt</code></pre></p> </li> </ul> <p>If you try to use <code>ls</code> on a file that doesn't exist, you will get a clear error message:</p> <pre><code>$ ls nosuchfile\nls: cannot access nosuchfile: No such file or directory\n</code></pre>"}, {"location": "navigating/#changing-directory-cd", "title": "Changing directory: \"cd\"", "text": "<p>To change to a different directory, you can use the <code>cd</code> command:</p> <pre><code>$ cd some_directory</code></pre> <p>To change back to the previous directory you were in, there's a shortcut: <code>cd -</code></p> <p>Using <code>cd</code> without an argument results in returning back to your home directory:</p> <pre><code>$ cd\n$ pwd\n/user/home/gent/vsc400/vsc40000\n</code></pre>"}, {"location": "navigating/#inspecting-file-type-file", "title": "Inspecting file type: \"file\"", "text": "<p>The <code>file</code> command can be used to inspect what type of file you're dealing with:</p> <pre><code>$ file afile.txt\nafile.txt: ASCII text\n\n$ file some_directory\nsome_directory: directory\n</code></pre>"}, {"location": "navigating/#absolute-vs-relative-file-paths", "title": "Absolute vs relative file paths", "text": "<p>An absolute filepath starts with <code>/</code> (or a variable which value starts with <code>/</code>), which is also called the root of the filesystem.</p> <p>Example: absolute path to your home directory: <code>/user/home/gent/vsc400/vsc40000</code>.</p> <p>A relative path starts from the current directory, and points to another location up or down the filesystem hierarchy.</p> <p>Example: <code>some_directory/one.txt</code> points to the file <code>one.txt</code> that is located in the subdirectory named <code>some_directory</code> of the current directory.</p> <p>There are two special relative paths worth mentioning:</p> <ul> <li> <p><code>.</code> is a shorthand for the current directory</p> </li> <li> <p><code>..</code> is a shorthand for the parent of the current directory</p> </li> </ul> <p>You can also use <code>..</code> when constructing relative paths, for example:</p> <pre><code>$ cd $HOME/some_directory\n$ ls ../afile.txt\n../afile.txt\n</code></pre>"}, {"location": "navigating/#permissions", "title": "Permissions", "text": "<p>Each file and directory has particular permissions set on it, which can be queried using <code>ls -l</code>.</p> <p>For example:</p> <pre><code>$ ls -l afile.txt\n-rw-rw-r-- 1 vsc40000 agroup 2929176 Apr 12 13:29 afile.txt\n</code></pre> <p>The <code>-rwxrw-r--</code> specifies both the type of file (<code>-</code> for files, <code>d</code> for directories (see first character)), and the permissions for user/group/others:</p> <ol> <li> <p>each triple of characters indicates whether the read (<code>r</code>), write     (<code>w</code>), execute (<code>x</code>) permission bits are set or not</p> </li> <li> <p>the 1st part <code>rwx</code> indicates that the owner \"vsc40000\" of the file has all     the rights</p> </li> <li> <p>the 2nd part <code>rw-</code> indicates the members of the group \"agroup\"     only have read/write permissions (not execute)</p> </li> <li> <p>the 3rd part <code>r--</code> indicates that other users only have read     permissions</p> </li> </ol> <p>The default permission settings for new files/directories are determined by the so-called umask setting, and are by default:</p> <ol> <li> <p>read-write permission on files for user/group (no execute),     read-only for others (no write/execute)</p> </li> <li> <p>read-write-execute permission for directories on user/group,     read/execute-only for others (no write)</p> </li> </ol> <p>See also the chmod command  later in this manual.</p>"}, {"location": "navigating/#finding-filesdirectories-find", "title": "Finding files/directories: \"find\"", "text": "<p><code>find</code> will crawl a series of directories and lists files matching given criteria.</p> <p>For example, to look for the file named <code>one.txt</code>:</p> <pre><code>$ cd $HOME\n$ find . -name one.txt\n./some_directory/one.txt\n</code></pre> <p>To look for files using incomplete names, you can use a wildcard <code>*</code>; note that you need to escape the <code>*</code> to avoid that Bash expands it into <code>afile.txt</code> by adding double quotes:</p> <pre><code>$ find . -name \"*.txt\"\n./.hidden_file.txt\n./afile.txt\n./some_directory/one.txt\n./some_directory/two.txt\n</code></pre> <p>A more advanced use of the <code>find</code> command is to use the <code>-exec</code> flag to perform actions on the found file(s), rather than just printing their paths (see <code>man find</code>).</p>"}, {"location": "navigating/#exercises", "title": "Exercises", "text": "<ul> <li> <p>Go to <code>/tmp</code>, then back to your home directory. How many different     ways to do this can you come up with?</p> </li> <li> <p>When was your home directory created or last changed?</p> </li> <li> <p>Determine the name of the last changed file in <code>/tmp</code>.</p> </li> <li> <p>See how home directories are organised. Can you access the home     directory of other users?</p> </li> </ul>"}, {"location": "uploading_files/", "title": "Uploading/downloading/editing files", "text": ""}, {"location": "uploading_files/#uploadingdownloading-files", "title": "Uploading/downloading files", "text": "<p>To transfer files from and to the HPC, see  the section about transferring files of the HPC manual</p>"}, {"location": "uploading_files/#dos2unix", "title": "<code>dos2unix</code>", "text": "<p>After uploading files from Windows, you may experience some problems due to the difference in line endings between Windows (carriage return + line feed) and Linux (line feed only), see also https://kuantingchen04.github.io/line-endings/.</p> <p>For example, you may see an error when submitting a job script that was edited on Windows:</p> <pre><code>sbatch: error: Batch script contains DOS line breaks (\\r\\n)\nsbatch: error: instead of expected UNIX line breaks (\\n).\n</code></pre> <p>To fix this problem, you should run the <code>dos2unix</code> command on the file:</p> <pre><code>$ dos2unix filename\n</code></pre>"}, {"location": "uploading_files/#symlinks-for-datascratch", "title": "Symlinks for data/scratch", "text": "<p>As we end up in the home directory when connecting, it would be convenient if we could access our data and VO storage. To facilitate this we will create symlinks to them in our home directory.  This will create 4 symbolic links  (they're like \"shortcuts\" on your desktop)  pointing to the respective storages:</p> <pre><code>$ cd $HOME\n$ ln -s $VSC_SCRATCH scratch\n$ ln -s $VSC_DATA data\n$ ls -l scratch data\nlrwxrwxrwx 1 vsc40000 vsc40000 31 Mar 27 2009 data -&gt;\n    /user/data/gent/vsc400/vsc40000\nlrwxrwxrwx 1 vsc40000 vsc40000 34 Jun 5 2012 scratch -&gt;\n    /user/scratch/gent/vsc400/vsc40000\n</code></pre>"}, {"location": "uploading_files/#editing-with-nano", "title": "Editing with <code>nano</code>", "text": "<p>Nano is the simplest editor available on Linux. To open Nano, just type <code>nano</code>. To edit a file, you use <code>nano the_file_to_edit.txt</code>. You will be presented with the contents of the file and a menu at the bottom with commands like <code>^O Write Out</code> The <code>^</code> is the Control key. So <code>^O</code> means <code>Ctrl-O</code>. The main commands are:</p> <ol> <li> <p>Open (\"Read\"): <code>^R</code></p> </li> <li> <p>Save (\"Write Out\"): <code>^O</code></p> </li> <li> <p>Exit: <code>^X</code></p> </li> </ol> <p>More advanced editors (beyond the scope of this page) are <code>vim</code> and <code>emacs</code>. A simple tutorial on how to get started with <code>vim</code> can be found at https://www.openvim.com/.</p>"}, {"location": "uploading_files/#copying-faster-with-rsync", "title": "Copying faster with <code>rsync</code>", "text": "<p><code>rsync</code> is a fast and versatile copying tool. It can be much faster than <code>scp</code> when copying large datasets. It's famous for its \"delta-transfer algorithm\", which reduces the amount of data sent over the network by only sending the differences between files.</p> <p>You will need to run <code>rsync</code> from a computer where it is installed. Installing <code>rsync</code> is the easiest on Linux: it comes pre-installed with a lot of distributions.</p> <p>For example, to copy a folder with lots of CSV files:</p> <pre><code>$ rsync -rzv testfolder vsc40000@login.hpc.ugent.be:data/</code></pre> <p>will copy the folder <code>testfolder</code> and its contents to <code>$VSC_DATA</code> on the , assuming the <code>data</code> symlink is present in your home directory, see  symlinks section.</p> <p>The <code>-r</code> flag means \"recursively\", the <code>-z</code> flag means that compression is enabled (this is especially handy when dealing with CSV files because they compress well) and the <code>-v</code> enables more verbosity (more details about what's going on).</p> <p>To copy large files using <code>rsync</code>, you can use the <code>-P</code> flag: it enables both showing of progress and resuming partially downloaded files.</p> <p>To copy files from the to your local computer, you can also use <code>rsync</code>:</p> <pre><code>$ rsync -rzv vsc40000@login.hpc.ugent.be:data/bioset local_folder</code></pre> <p>This will copy the folder <code>bioset</code> and its contents that on <code>$VSC_DATA</code> of the to a local folder named <code>local_folder</code>.</p> <p>See <code>man rsync</code> or https://linux.die.net/man/1/rsync for more information about rsync.</p>"}, {"location": "uploading_files/#exercises", "title": "Exercises", "text": "<ol> <li> <p>Download the file <code>/etc/hostname</code> to your local computer.</p> </li> <li> <p>Upload a file to a subdirectory of your personal <code>$VSC_DATA</code> space.</p> </li> <li> <p>Create a file named <code>hello.txt</code> and edit it using <code>nano</code>.</p> </li> </ol>"}]}