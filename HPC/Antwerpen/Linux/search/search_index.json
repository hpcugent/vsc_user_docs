{"config": {"lang": ["en"], "separator": "[\\_\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Welcome to the UAntwerpen-HPC documentation", "text": "<p>Use the menu on the left to navigate, or use the search box on the top right.</p> <p>You are viewing documentation intended for people using Linux.</p> <p>Use the OS dropdown in the top bar to switch to a different operating system.</p> <p>Quick links</p> <ul> <li>Getting Started  | Getting Access</li> <li>FAQ | Troubleshooting | Best practices | Known issues</li> </ul> <p></p> <p>If you find any problems in this documentation, please report them by mail to hpc@uantwerpen.be or open a pull request.</p> <p>If you still have any questions, you can contact the UAntwerpen-HPC.</p>"}, {"location": "FAQ/", "title": "Frequently Asked Questions (FAQ)", "text": ""}, {"location": "FAQ/#composing-a-job", "title": "Composing a job", "text": ""}, {"location": "FAQ/#how-many-coresnodes-should-i-request", "title": "How many cores/nodes should I request?", "text": "<p>An important factor in this question is how well your task is being parallelized: does it actually run faster with more resources? You can test this yourself: start with 4 cores, then 8, then 16... The execution time should each time be reduced to around half of what it was before. You can also try this with full nodes: 1 node, 2 nodes. A rule of thumb is that you're around the limit when you double the resources but the execution time is still ~60-70% of what it was before. That's a signal to stop increasing the core count.</p> <p>See also: Running batch jobs.</p>"}, {"location": "FAQ/#which-packages-are-available", "title": "Which packages are available?", "text": "<p>When connected to the HPC, use the commands <code>module avail [search_text]</code> and <code>module spider [module]</code> to find installed modules and get information on them.</p> <p>Among others, many packages for both Python and R are readily available on the HPC. These aren't always easy to find, though, as we've bundled them together.</p> <p>Specifically, the module <code>SciPy-bundle</code> includes numpy, pandas, scipy and a few others. For R, the normal R module has many libraries included. The bundle <code>R-bundle-Bioconductor</code> contains more libraries. Use the command <code>module spider [module]</code> to find the specifics on these bundles.</p>"}, {"location": "FAQ/#how-do-i-choose-the-job-modules", "title": "How do I choose the job modules?", "text": "<p>Modules each come with a suffix that describes the toolchain used to install them.</p> <p>Examples:</p> <ul> <li> <p>AlphaFold/2.2.2-foss-2021a</p> </li> <li> <p>tqdm/4.61.2-GCCcore-10.3.0</p> </li> <li> <p>Python/3.9.5-GCCcore-10.3.0</p> </li> <li> <p>matplotlib/3.4.2-foss-2021a</p> </li> </ul> <p>Modules from the same toolchain always work together, and modules from a *different version of the same toolchain* never work together.</p> <p>The above set of modules works together: an overview of compatible toolchains can be found here: https://docs.easybuild.io/en/latest/Common-toolchains.html#overview-of-common-toolchains.</p> <p>You can use <code>module avail [search_text]</code> to see which versions on which toolchains are available to use.</p> <p>It is possible to use the modules without specifying a version or toolchain. However, this will probably cause incompatible modules to be loaded. Don't do it if you use multiple modules. Even if it works now, as more modules get installed on the HPC, your job can suddenly break.</p>"}, {"location": "FAQ/#troubleshooting", "title": "Troubleshooting", "text": ""}, {"location": "FAQ/#my-modules-dont-work-together", "title": "My modules don't work together", "text": "<p>When incompatible modules are loaded, you might encounter an error like this:</p> <pre><code>{{ lmod_error }}\n</code></pre> <p>You should load another <code>foss</code> module for that is compatible with the currently loaded version of <code>GCC</code>. Use <code>ml spider foss</code> to get an overview of the available versions.</p> <p>Modules from the same toolchain always work together, and modules from a different version of the same toolchain never work together.</p> <p>An overview of compatible toolchains can be found here: https://docs.easybuild.io/en/latest/Common-toolchains.html#overview-of-common-toolchains.</p> <p>See also: How do I choose the job modules?</p>"}, {"location": "FAQ/#my-job-takes-longer-than-72-hours", "title": "My job takes longer than 72 hours", "text": "<p>The 72 hour walltime limit will not be extended. However, you can work around this barrier:</p> <ul> <li>Check that all available resources are being used. See also:<ul> <li>How many cores/nodes should I request?.</li> <li>My job is slow.</li> <li>My job isn't using any GPUs.</li> </ul> </li> <li>Use a faster cluster.</li> <li>Divide the job into more parallel processes.</li> <li>Divide the job into shorter processes, which you can submit as separate jobs.</li> <li>Use the built-in checkpointing of your software.</li> </ul>"}, {"location": "FAQ/#job-failed-segv-segmentation-fault", "title": "Job failed: SEGV Segmentation fault", "text": "<p>Any error mentioning <code>SEGV</code> or <code>Segmentation fault/violation</code> has something to do with a memory error. If you weren't messing around with memory-unsafe applications or programming, your job probably hit its memory limit.</p> <p>When there's no memory amount specified in a job script, your job will get access to a proportional share of the total memory on the node: If you request a full node, all memory will be available. If you request <code>8</code> cores on a cluster where nodes have <code>2x18</code> cores, you will get <code>8/36 = 2/9</code> of the total memory on the node.</p> <p>Try requesting a bit more memory than your proportional share, and see if that solves the issue.</p> <p>See also: Specifying memory requirements.</p>"}, {"location": "FAQ/#my-compilationcommand-fails-on-login-node", "title": "My compilation/command fails on login node", "text": "<p>When logging in, you are using a connection to the login nodes. There are somewhat strict limitations on what you can do in those sessions: check out the output of <code>ulimit -a</code>. Specifically, the memory and the amount of processes you can use may present an issue. This is common with MATLAB compilation and Nextflow. An error caused by the login session limitations can look like this: <code>Aborted (core dumped)</code>.</p> <p>It's easy to get around these limitations: start an interactive session on one of the clusters. Then, you are acting as a node on that cluster instead of a login node. Notably, the debug/interactive cluster will grant such a session immediately, while other clusters might make you wait a bit. Example command: <code>ml swap cluster/donphan &amp;&amp; qsub -I -l nodes=1:ppn=8</code></p> <p>See also: Running interactive jobs.</p>"}, {"location": "FAQ/#my-job-isnt-using-any-gpus", "title": "My job isn't using any GPUs", "text": "<p>Only two clusters have GPUs. Check out the infrastructure overview, to see which one suits your needs. Make sure that you manually switch to the GPU cluster before you submit the job. Inside the job script, you need to explicitly request the GPUs: <code>#PBS -l nodes=1:ppn=24:gpus=2</code></p> <p>Some software modules don't have GPU support, even when running on the GPU cluster. For example, when running <code>module avail alphafold</code> on the joltik cluster, you will find versions on both the foss toolchain and the fossCUDA toolchain. Of these, only the CUDA versions will use GPU power. When in doubt, CUDA means GPU support.</p>"}, {"location": "FAQ/#my-job-runs-slower-than-i-expected", "title": "My job runs slower than I expected", "text": "<p>There are a few possible causes why a job can perform worse than expected.</p> <p>Is your job using all the available cores you've requested? You can test this by increasing and decreasing the core amount: If the execution time stays the same, the job was not using all cores. Some workloads just don't scale well with more cores. If you expect the job to be very parallelizable and you encounter this problem, maybe you missed some settings that enable multicore execution. See also: How many cores/nodes should i request?</p> <p>Does your job have access to the GPUs you requested? See also: My job isn't using any GPUs</p> <p>Not all file locations perform the same. In particular, the <code>$VSC_HOME</code> and <code>$VSC_DATA</code> directories are, relatively, very slow to access. Your jobs should rather use the <code>$VSC_SCRATCH</code> directory, or other fast locations (depending on your needs), described in Where to store your data on the HPC. As an example how to do this: The job can copy the input to the scratch directory, then execute the computations, and lastly copy the output back to the data directory. Using the home and data directories is especially a problem when UGent isn't your home institution: your files may be stored, for example, in Leuven while you're running a job in Ghent.</p>"}, {"location": "FAQ/#my-mpi-job-fails", "title": "My MPI job fails", "text": "<p>Use <code>mympirun</code> in your job script instead of <code>mpirun</code>. It is a tool that makes sure everything gets set up correctly for the HPC infrastructure. You need to load it as a module in your job script: <code>module load vsc-mympirun</code>.</p> <p>To submit the job, use the <code>qsub</code> command rather than <code>sbatch</code>. Although both will submit a job, <code>qsub</code> will correctly interpret the <code>#PBS</code> parameters inside the job script. <code>sbatch</code> might not set the job environment up correctly for mympirun/OpenMPI.</p> <p>See also: Multi core jobs/Parallel Computing and Mympirun.</p>"}, {"location": "FAQ/#mympirun-seems-to-ignore-its-arguments", "title": "<code>mympirun</code> seems to ignore its arguments", "text": "<p>For example, we have a simple script (<code>./hello.sh</code>):</p> <pre><code>#!/bin/bash \necho \"hello world\"\n</code></pre> <p>And we run it like <code>mympirun ./hello.sh --output output.txt</code>.</p> <p>To our surprise, this doesn't output to the file <code>output.txt</code>, but to standard out! This is because <code>mympirun</code> expects the program name and the arguments of the program to be its last arguments. Here, the <code>--output output.txt</code> arguments are passed to <code>./hello.sh</code> instead of to <code>mympirun</code>. The correct way to run it is:</p> <pre><code>mympirun --output output.txt ./hello.sh\n</code></pre>"}, {"location": "FAQ/#when-will-my-job-start", "title": "When will my job start?", "text": "<p>In practice, it's impossible to predict when your job(s) will start, since most currently running jobs will finish before their requested walltime expires.  New jobs may be submitted by other users that are assigned a higher priority than your job(s).  You can use the <code>squeue --start</code> command to get an estimated start time for your jobs in the queue. Keep in mind that this is just an estimate.</p>"}, {"location": "FAQ/#why-do-i-get-a-no-space-left-on-device-error-while-i-still-have-storage-space-left", "title": "Why do I get a \"No space left on device\" error, while I still have storage space left?", "text": "<p>When trying to create files, errors like this can occur:</p> <pre><code>No space left on device\n</code></pre> <p>The error \"<code>No space left on device</code>\" can mean two different things:</p> <ul> <li>all available storage quota on the file system in question has been used;</li> <li>the inode limit has been reached on that file system.</li> </ul> <p>An inode can be seen as a \"file slot\", meaning that when the limit is reached, no more additional files can be created. There is a standard inode limit in place that will be increased if needed.  The number of inodes used per file system can be checked on the VSC account page.</p> <p>Possible solutions to this problem include cleaning up unused files and directories or  compressing directories with a lot of files into zip- or tar-files.</p> <p>If the problem persists, feel free to contact support.</p>"}, {"location": "FAQ/#other", "title": "Other", "text": ""}, {"location": "FAQ/#can-i-share-my-account-with-someone-else", "title": "Can I share my account with someone else?", "text": "<p>NO. You are not allowed to share your VSC account with anyone else, it is strictly personal. </p> <p>See https://pintra.uantwerpen.be/bbcswebdav/xid-23610_1 </p>"}, {"location": "FAQ/#can-i-share-my-data-with-other-uantwerpen-hpc-users", "title": "Can I share my data with other UAntwerpen-HPC users?", "text": "<p>Yes, you can use the <code>chmod</code> or <code>setfacl</code> commands to change permissions of files so other users can access the data. For example, the following command will enable a user named \"otheruser\" to read the file named <code>dataset.txt</code>. See</p> <pre><code>$ setfacl -m u:otheruser:r dataset.txt\n$ ls -l dataset.txt\n-rwxr-x---+ 2 vsc20167 mygroup      40 Apr 12 15:00 dataset.txt\n</code></pre> <p>For more information about <code>chmod</code> or <code>setfacl</code>, see Linux tutorial.</p>"}, {"location": "FAQ/#can-i-use-multiple-different-ssh-key-pairs-to-connect-to-my-vsc-account", "title": "Can I use multiple different SSH key pairs to connect to my VSC account?", "text": "<p>Yes, and this is recommended when working from different computers. Please see Adding multiple SSH public keys on how to do this.</p>"}, {"location": "FAQ/#i-want-to-use-software-that-is-not-available-on-the-clusters-yet", "title": "I want to use software that is not available on the clusters yet", "text": "<p>Please send an e-mail to hpc@uantwerpen.be that includes:</p> <ul> <li> <p>What software you want to install and the required version</p> </li> <li> <p>Detailed installation instructions</p> </li> <li> <p>The purpose for which you want to install the software</p> </li> </ul> <p>If the software is a Python package, you can manually install it in a virtual environment.  More information can be found here. Note that it is still preferred to submit a software installation request,  as the software installed by the HPC team will be optimized for the HPC environment. This can lead to dramatic performance improvements.</p> <p>Warning</p> <p>Do not use <code>pip install --user</code> to install software, as this places packages  in <code>~/.local/lib/python*/site-packages</code>, potentially causing conflicts with software installed by the HPC team. </p> <p>Also, avoid using <code>pip install --prefix</code> or <code>pip install --target</code> with <code>$PYTHONPATH</code>,  since <code>$PYTHONPATH</code> is a global setting that affects all Python versions. When <code>$PYTHONPATH</code> includes directories with packages from different Python versions, it can lead to conflicts. </p> <p>Instead, use a Python virtual environment for package installations in your home directory.  For guidance on setting up virtual environments,  refer to the Python virtual environments setup guide.</p>"}, {"location": "FAQ/#vo-how-does-it-work", "title": "VO: how does it work?", "text": "<p>A Virtual Organisation consists of a number of members and moderators. A moderator can:</p> <ul> <li> <p>Manage the VO members (but can't access/remove their data on the system).</p> </li> <li> <p>See how much storage each member has used, and set limits per member.</p> </li> <li> <p>Request additional storage for the VO.</p> </li> </ul> <p>One person can only be part of one VO, be it as a member or moderator. It's possible to leave a VO and join another one. However, it's not recommended to keep switching between VO's (to supervise groups, for example).</p> <p>See also: Virtual Organisations.</p>"}, {"location": "FAQ/#my-home-directory-is-almost-full-and-i-dont-know-why", "title": "My home directory is (almost) full, and I don't know why", "text": "<p>Your home directory might be full without looking like it due to hidden files. Hidden files and subdirectories have a name starting with a dot and do not show up when running <code>ls</code>. If you want to check where the storage in your home directory is used, you can make use of the <code>du</code> command to find out what the largest files and subdirectories are:</p> <pre><code>du -h --max-depth 1 $VSC_HOME | egrep '[0-9]{3}M|[0-9]G'\n</code></pre> <p>The <code>du</code> command returns the size of every file and subdirectory in the $VSC_HOME directory. This output is then piped into an <code>egrep</code> to filter the lines to the ones that matter the most.</p> <p>The <code>egrep</code> command will only let entries that match with the specified regular expression <code>[0-9]{3}M|[0-9]G</code> through, which corresponds with files that consume more than 100 MB.</p>"}, {"location": "FAQ/#how-can-i-get-more-storage-space", "title": "How can I get more storage space?", "text": "<p>By default you get 3 GB of storage space for your home directory and 25 GB in your personal directories on both the data (<code>$VSC_DATA</code>) and scratch (<code>$VSC_SCRATCH</code>) filesystems. It is not possible to expand the storage quota for these personal directories.</p> <p>You can get more storage space through a Virtual Organisation (VO), which will give you access to the additional directories in a subdirectory specific to that VO (<code>$VSC_DATA_VO</code> and <code>$VSC_SCRATCH_VO</code>). The moderators of a VO can request more storage for their VO.</p>"}, {"location": "FAQ/#why-cant-i-use-the-sudo-command", "title": "Why can't I use the <code>sudo</code> command?", "text": "<p>When you attempt to use sudo, you will be prompted for a password.  However, you cannot enter a valid password because this feature is reserved exclusively for HPC administrators.</p> <p><code>sudo</code> is used to execute a command with administrator rights, which would allow you to make system-wide changes. You are only able to run commands that make changes to the directories that your VSC account has access to, like your home directory, your personal directories like $VSC_DATA and $VSC_SCRATCH,  or shared VO/group directories like $VSC_DATA_VO and $VSC_SCRATCH_VO.</p> <p>A lot of tasks can be performed without <code>sudo</code>, including installing software in your own account.</p> <p>Installing software</p> <ul> <li>If you know how to install the software without using <code>sudo</code>, you are welcome to proceed with the installation.</li> <li>If you are unsure how to install the software, you can submit a software installation request, and the HPC-UGent support team will handle the installation for you.</li> </ul>"}, {"location": "FAQ/#i-have-another-questionproblem", "title": "I have another question/problem", "text": "<p>Who can I contact?</p> <ul> <li> <p>General questions regarding HPC-UGent and VSC: hpc@ugent.be</p> </li> <li> <p>HPC-UGent Tier-2: hpc@ugent.be</p> </li> <li> <p>VSC Tier-1 compute: compute@vscentrum.be</p> </li> <li> <p>VSC Tier-1 cloud: cloud@vscentrum.be</p> </li> </ul>"}, {"location": "MATLAB/", "title": "MATLAB", "text": "<p>Note</p> <p>To run a MATLAB program on the UAntwerpen-HPC you must compile it first, because the MATLAB license server is not accessible from cluster workernodes (except for the interactive debug cluster).</p> <p>Compiling MATLAB programs is only possible on the interactive debug cluster, not on the UAntwerpen-HPC login nodes where resource limits w.r.t. memory and max. number of progress are too strict.</p>"}, {"location": "MATLAB/#why-is-the-matlab-compiler-required", "title": "Why is the MATLAB compiler required?", "text": "<p>The main reason behind this alternative way of using MATLAB is licensing: only a limited number of MATLAB sessions can be active at the same time. However, once the MATLAB program is compiled using the MATLAB compiler, the resulting stand-alone executable can be run without needing to contact the license server.</p> <p>Note that a license is required for the MATLAB Compiler, see https://nl.mathworks.com/help/compiler/index.html. If the <code>mcc</code> command is provided by the MATLAB installation you are using, the MATLAB compiler can be used as explained below.</p>"}, {"location": "MATLAB/#how-to-compile-matlab-code", "title": "How to compile MATLAB code", "text": "<p>Compiling MATLAB code can only be done from the login nodes, because only login nodes can access the MATLAB license server, workernodes on clusters cannot.</p> <p>To access the MATLAB compiler, the <code>MATLAB</code> module should be loaded first. Make sure you are using the same <code>MATLAB</code> version to compile and to run the compiled MATLAB program.</p> <pre><code>$ module avail MATLAB/\n----------------------/apps/gent/RHEL8/zen2-ib/modules/all----------------------\n   MATLAB/2021b    MATLAB/2022b-r5 (D)\n$ module load MATLAB/2021b\n</code></pre> <p>After loading the <code>MATLAB</code> module, the <code>mcc</code> command can be used. To get help on <code>mcc</code>, you can run <code>mcc -?</code>.</p> <p>To compile a standalone application, the <code>-m</code> flag is used (the <code>-v</code> flag means verbose output). To show how <code>mcc</code> can be used, we use the <code>magicsquare</code> example that comes with MATLAB.</p> <p>First, we copy the <code>magicsquare.m</code> example that comes with MATLAB to <code>example.m</code>:</p> <pre><code>cp $EBROOTMATLAB/extern/examples/compiler/magicsquare.m example.m\n</code></pre> <p>To compile a MATLAB program, use <code>mcc -mv</code>:</p> <pre><code>mcc -mv example.m\nOpening log file:  /user/antwerpen/201/vsc20167/java.log.34090\nCompiler version: 8.3 (R2021b)\nDependency analysis by REQUIREMENTS.\nParsing file \"/user/antwerpen/201/vsc20167/example.m\"\n    (Referenced from: \"Compiler Command Line\").\nDeleting 0 temporary MEX authorization files.\nGenerating file \"/user/antwerpen/201/vsc20167/readme.txt\".\nGenerating file \"run\\_example.sh\".\n</code></pre>"}, {"location": "MATLAB/#libraries", "title": "Libraries", "text": "<p>To compile a MATLAB program that needs a library, you can use the <code>-I library_path</code> flag. This will tell the compiler to also look for files in <code>library_path</code>.</p> <p>It's also possible to use the <code>-a path</code> flag. That will result in all files under the <code>path</code> getting added to the final executable.</p> <p>For example, the command <code>mcc -mv example.m -I examplelib -a datafiles</code> will compile <code>example.m</code> with the MATLAB files in <code>examplelib</code>, and will include all files in the <code>datafiles</code> directory in the binary it produces.</p>"}, {"location": "MATLAB/#memory-issues-during-compilation", "title": "Memory issues during compilation", "text": "<p>If you are seeing Java memory issues during the compilation of your MATLAB program on the login nodes, consider tweaking the default maximum heap size (128M) of Java using the <code>_JAVA_OPTIONS</code> environment variable with:</p> <pre><code>export _JAVA_OPTIONS=\"-Xmx64M\"\n</code></pre> <p>The MATLAB compiler spawns multiple Java processes. Because of the default memory limits that are in effect on the login nodes, this might lead to a crash of the compiler if it's trying to create to many Java processes. If we lower the heap size, more Java processes will be able to fit in memory.</p> <p>Another possible issue is that the heap size is too small. This could result in errors like:</p> <pre><code>Error: Out of memory\n</code></pre> <p>A possible solution to this is by setting the maximum heap size to be bigger:</p> <pre><code>export _JAVA_OPTIONS=\"-Xmx512M\"\n</code></pre>"}, {"location": "MATLAB/#multithreading", "title": "Multithreading", "text": "<p>MATLAB can only use the cores in a single workernode (unless the Distributed Computing toolbox is used, see https://nl.mathworks.com/products/distriben.html).</p> <p>The amount of workers used by MATLAB for the parallel toolbox can be controlled via the <code>parpool</code> function: <code>parpool(16)</code> will use 16 workers. It's best to specify the amount of workers, because otherwise you might not harness the full compute power available (if you have too few workers), or you might negatively impact performance (if you have too many workers). By default, MATLAB uses a fixed number of workers (12).</p> <p>You should use a number of workers that is equal to the number of cores you requested when submitting your job script (the <code>ppn</code> value, see Generic resource requirements). You can determine the right number of workers to use via the following code snippet in your MATLAB program:</p> parpool.m<pre><code>% specify the right number of workers (as many as there are cores available in the job) when creating the parpool\nc = parcluster('local')\npool = parpool(c.NumWorkers)\n</code></pre> <p>See also the parpool documentation.</p>"}, {"location": "MATLAB/#java-output-logs", "title": "Java output logs", "text": "<p>Each time MATLAB is executed, it generates a Java log file in the users home directory. The output log directory can be changed using:</p> <pre><code>MATLAB_LOG_DIR=&lt;OUTPUT_DIR&gt;\n</code></pre> <p>where <code>&lt;OUTPUT_DIR&gt;</code> is the name of the desired output directory. To create and use a temporary directory for these logs:</p> <pre><code># create unique temporary directory in $TMPDIR (or /tmp/$USER if\n$TMPDIR is not defined)\n# instruct MATLAB to use this directory for log files by setting $MATLAB_LOG_DIR\n$  export MATLAB_LOG_DIR=$ (mktemp -d -p $TMPDIR:-/tmp/$USER)\n</code></pre> <p>You should remove the directory at the end of your job script:</p> <pre><code>rm -rf $MATLAB_LOG_DIR\n</code></pre>"}, {"location": "MATLAB/#cache-location", "title": "Cache location", "text": "<p>When running, MATLAB will use a cache for performance reasons. This location and size of this cache can be changed through the <code>MCR_CACHE_ROOT</code> and <code>MCR_CACHE_SIZE</code> environment variables.</p> <p>The snippet below would set the maximum cache size to 1024MB and the location to <code>/tmp/testdirectory</code>.</p> <pre><code>export MATLAB_CACHE_ROOT=/tmp/testdirectory \nexport MATLAB_CACHE_SIZE=1024M \n</code></pre> <p>So when MATLAB is running, it can fill up to 1024MB of cache in <code>/tmp/testdirectory</code>.</p>"}, {"location": "MATLAB/#matlab-job-script", "title": "MATLAB job script", "text": "<p>All of the tweaks needed to get MATLAB working have been implemented in an example job script. This job script is also available on the HPC.</p> jobscript.sh<pre><code>#!/bin/bash\n#PBS -l nodes=1:ppn=1\n#PBS -l walltime=1:0:0\n#\n# Example (single-core) MATLAB job script\n#\n\n# make sure the MATLAB version matches with the one used to compile the MATLAB program!\nmodule load MATLAB/2021b\n\n# use temporary directory (not $HOME) for (mostly useless) MATLAB log files\n# subdir in $TMPDIR (if defined, or /tmp otherwise)\nexport MATLAB_LOG_DIR=$(mktemp -d -p  ${TMPDIR:-/tmp})\n\n# configure MATLAB Compiler Runtime cache location &amp; size (1GB)\n# use a temporary directory in /dev/shm (i.e. in memory) for performance reasons\nexport MCR_CACHE_ROOT=$(mktemp -d -p /dev/shm)\nexport MCR_CACHE_SIZE=1024MB\n\n# change to directory where job script was submitted from\ncd $PBS_O_WORKDIR\n\n# run compiled example MATLAB program 'example', provide '5' as input argument to the program\n# $EBROOTMATLAB points to MATLAB installation directory\n./run_example.sh $EBROOTMATLAB 5\n</code></pre>"}, {"location": "VNC/", "title": "Graphical applications with VNC", "text": "<p>We strongly encourage the use of the web portal for graphical use cases.</p>"}, {"location": "account/", "title": "Getting an HPC Account", "text": ""}, {"location": "account/#getting-ready-to-request-an-account", "title": "Getting ready to request an account", "text": "<p>All users of Antwerp University Association (AUHA) can request an account on the UAntwerpen-HPC, which is part of the Flemish Supercomputing Centre (VSC).</p> <p>See HPC policies for more information on who is entitled to an account.</p> <p>The VSC, abbreviation of Flemish Supercomputer Centre, is a virtual supercomputer centre. It is a partnership between the five Flemish associations: the Association KU\u00a0Leuven, Ghent University Association, Brussels University Association, Antwerp University Association and the University Colleges-Limburg. The VSC is funded by the Flemish Government.</p> <p>There are two methods for connecting to UAntwerpen-HPC:</p> <ul> <li>Using a terminal to connect via SSH.</li> <li>Using the web portal</li> </ul> <p>The web portal offers a convenient way to upload files and gain shell access to the UAntwerpen-HPC from a standard web browser (no software installation or configuration required).</p> <p>If you would like use a terminal with SSH as this gives you more flexibility continue reading. However if you prefer to use the web portal, you can skip ahead to the following section: Applying for the account. Once you have successfully obtained an account, you can then delve into the details of utilizing the HPC-UGent web portal by reading Using the HPC-UGent web portal.</p> <p>The UAntwerpen-HPC clusters use public/private key pairs for user authentication (rather than passwords). Technically, the private key is stored on your local computer and always stays there; the public key is stored on the UAntwerpen-HPC. Access to the UAntwerpen-HPC is granted to anyone who can prove to have access to the corresponding private key on his local computer.</p>"}, {"location": "account/#how-do-ssh-keys-work", "title": "How do SSH keys work?", "text": "<ul> <li> <p>an SSH public/private key pair can be seen as a lock and a key</p> </li> <li> <p>the SSH public key is equivalent with a lock: you give it to the     VSC and they put it on the door that gives access to your account.</p> </li> <li> <p>the SSH private key is like a physical key: you don't hand it out     to other people.</p> </li> <li> <p>anyone who has the key (and the optional password) can unlock the     door and log in to the account.</p> </li> <li> <p>the door to your VSC account is special: it can have multiple     locks (SSH public keys) attached to it, and you only need to open     one lock with the corresponding key (SSH private key) to open     the door (log in to the account).</p> </li> </ul> <p>Since all VSC clusters use Linux as their main operating system, you will need to get acquainted with using the command-line interface and using the terminal (see tutorial). Launch a terminal from your desktop's application menu and you will see the bash shell. There are other shells, but most Linux distributions use bash by default.</p>"}, {"location": "account/#test-openssh", "title": "Test OpenSSH", "text": "<p>Secure Shell (ssh) is a cryptographic network protocol for secure data communication, remote command-line login, remote command execution, and other secure network services between two networked computers. In short, ssh provides a secure connection between 2 computers via insecure channels (Network, Internet, telephone lines, ...).</p> <p>\"Secure\" means that:</p> <ol> <li> <p>the User is authenticated to the System; and</p> </li> <li> <p>the System is authenticated to the User; and</p> </li> <li> <p>all data is encrypted during transfer.</p> </li> </ol> <p>OpenSSH is a FREE implementation of the SSH connectivity protocol. Linux comes with its own implementation of OpenSSH, so you don't need to install any third-party software to use it. Just open a terminal window and jump in!</p> <p>On all popular Linux distributions, the OpenSSH software is readily available, and most often installed by default. You can check whether the OpenSSH software is installed by opening a terminal and typing:</p> <pre><code>$ ssh -V\nOpenSSH_7.4p1, OpenSSL 1.0.2k-fips 26 Jan 2017\n</code></pre> <p>To access the clusters and transfer your files, you will use the following commands:</p> <ol> <li> <p><code>ssh-keygen</code>: to generate the SSH key pair (public + private key);</p> </li> <li> <p><code>ssh</code>: to open a shell on a remote machine;</p> </li> <li> <p><code>sftp</code>: a secure equivalent of ftp;</p> </li> <li> <p><code>scp</code>: a secure equivalent of the remote copy command rcp.</p> </li> </ol>"}, {"location": "account/#generate-a-publicprivate-key-pair-with-openssh", "title": "Generate a public/private key pair with OpenSSH", "text": "<p>A key pair might already be present in the default location inside your home directory. Therefore, we first check if a key is available with the \"list short\" (\"ls\") command:</p> <pre><code>ls ~/.ssh\n</code></pre> <p>If a key-pair is already available, you would normally get: <pre><code>authorized_keys     id_rsa      id_rsa.pub      known_hosts\n</code></pre></p> <p>Otherwise, the command will show:</p> <pre><code>ls: .ssh: No such file or directory\n</code></pre> <p>You can recognise a public/private key pair when a pair of files has the same name except for the extension \".pub\" added to one of them. In this particular case, the private key is \"id_rsa\" and public key is \"id_rsa.pub\". You may have multiple keys (not necessarily in the directory \"~/.ssh\") if you or your operating system requires this. Be aware that your existing key pair might be too short, or not the right type.</p> <p>You will need to generate a new key pair, when:</p> <ol> <li> <p>you don't have a key pair yet</p> </li> <li> <p>you forgot the passphrase protecting your private key</p> </li> <li> <p>your private key was compromised</p> </li> <li> <p>your key pair is too short or not the right type</p> </li> </ol> <p>For extra security, the private key itself can be encrypted using a \"passphrase\", to prevent anyone from using your private key even when they manage to copy it. You have to \"unlock\" the private key by typing the passphrase. Be sure to never give away your private key, it is private and should stay private. You should not even copy it to one of your other machines, instead, you should create a new public/private key pair for each machine.</p> <pre><code>ssh-keygen -t rsa -b 4096\n</code></pre> <p>This will ask you for a file name to store the private and public key, and a passphrase to protect your private key. It needs to be emphasised that you really should choose the passphrase wisely! The system will ask you for it every time you want to use the private key that is every time you want to access the cluster or transfer your files.</p> <p>Without your key pair, you won't be able to apply for a personal VSC account.</p>"}, {"location": "account/#using-an-ssh-agent-optional", "title": "Using an SSH agent (optional)", "text": "<p>Most recent Unix derivatives include by default an SSH agent (\"gnome-keyring-daemon\" in most cases) to keep and manage the user SSH keys. If you use one of these derivatives you must include the new keys into the SSH manager keyring to be able to connect to the HPC cluster. If not, SSH client will display an error message (see Connecting) similar to this:</p> <pre><code>Agent admitted failure to sign using the key. \nPermission denied (publickey,gssapi-keyex,gssapi-with-mic).\n</code></pre> <p>This could be fixed using the <code>ssh-add</code> command. You can include the new private keys' identities in your keyring with:</p> <pre><code>ssh-add\n</code></pre> <p>Tip</p> <p>Without extra options <code>ssh-add</code> adds any key located at <code>$HOME/.ssh</code> directory, but you can specify the private key location path as argument, as example: <code>ssh-add /path/to/my/id_rsa</code>.</p> <p>Check that your key is available from the keyring with:</p> <pre><code>ssh-add -l\n</code></pre> <p>After these changes the key agent will keep your SSH key to connect to the clusters as usual.</p> <p>Tip</p> <p>You should execute <code>ssh-add</code> command again if you generate a new SSH key.</p> <p>Visit https://wiki.gnome.org/Projects/GnomeKeyring/Ssh for more information.</p>"}, {"location": "account/#applying-for-the-account", "title": "Applying for the account", "text": "<p>Visit https://account.vscentrum.be/</p> <p>You will be redirected to our WAYF (Where Are You From) service where you have to select your \"Home Organisation\".</p> <p></p> <p>Select \"Universiteit Antwerpen\" in the dropdown box and optionally select \"Save my preference\" and \"permanently\".</p> <p>Click Confirm</p> <p>You will now be taken to the authentication page of your institute. </p> <p>The site is only accessible from within the University of Antwerp domain, so the page won't load from, e.g., home. However, you can also get external access to the University of Antwerp domain using VPN. We refer to the Pintra pages of the ICT Department for more information.</p>"}, {"location": "account/#users-of-the-antwerp-university-association-auha", "title": "Users of the Antwerp University Association (AUHA)", "text": "<p>All users (researchers, academic staff, etc.) from the higher education institutions associated with University of Antwerp can get a VSC account via the University of Antwerp. There is not yet an automated form to request your personal VSC account.</p> <p>Please e-mail the UAntwerpen-HPC staff to get an account (see Contacts information). You will have to provide a public ssh key generated as described above. Please attach your public key (i.e., the file named <code>id_rsa.pub</code>), which you will normally find in your .ssh subdirectory within your HOME Directory. (i.e., <code>/Users/&lt;username&gt;/.ssh/id_rsa.pub</code>).</p> <p>After you log in using your University of Antwerp login and password, you will be asked to upload the file that contains your public key, i.e., the file \"id_rsa.pub\" which you have generated earlier. Make sure that your public key is actually accepted for upload, because if it is in a wrong format, wrong type or too short, then it will be refused.</p> <p>This file has been stored in the directory \"~/.ssh/\".</p> <p>After you have uploaded your public key you will receive an e-mail with a link to confirm your e-mail address. After confirming your e-mail address the VSC staff will review and if applicable approve your account.</p>"}, {"location": "account/#welcome-e-mail", "title": "Welcome e-mail", "text": "<p>Within one day, you should receive a Welcome e-mail with your VSC account details.</p> <pre><code>Dear (Username), \nYour VSC-account has been approved by an administrator.\nYour vsc-username is vsc20167\n\nYour account should be fully active within one hour.\n\nTo check or update your account information please visit\nhttps://account.vscentrum.be/\n\nFor further info please visit https://www.vscentrum.be/user-portal\n\nKind regards,\n-- The VSC administrators\n</code></pre> <p>Now, you can start using the UAntwerpen-HPC. You can always look up your VSC id later by visiting https://account.vscentrum.be.</p>"}, {"location": "account/#adding-multiple-ssh-public-keys-optional", "title": "Adding multiple SSH public keys (optional)", "text": "<p>In case you are connecting from different computers to the login nodes, it is advised to use separate SSH public keys to do so. You should follow these steps.</p> <ol> <li> <p>Create a new public/private SSH key pair from the new computer.     Repeat the process described in     section\u00a0Generate a public/private key pair with OpenSSH.</p> </li> <li> <p>Go to https://account.vscentrum.be/django/account/edit</p> </li> <li> <p>Upload the new SSH public key using the Add public key section. Make sure that your     public key is actually saved, because a public key will be refused     if it is too short, wrong type, or in a wrong format.</p> </li> <li> <p>(optional) If you lost your key, you can delete the old key on the     same page. You should keep at least one valid public SSH key in your     account.</p> </li> <li> <p>Take into account that it will take some time before the new SSH     public key is active in your account on the system; waiting for     15-30 minutes should be sufficient.</p> </li> </ol>"}, {"location": "account/#computation-workflow-on-the-uantwerpen-hpc", "title": "Computation Workflow on the UAntwerpen-HPC", "text": "<p>A typical Computation workflow will be:</p> <ol> <li> <p>Connect to the UAntwerpen-HPC</p> </li> <li> <p>Transfer your files to the UAntwerpen-HPC</p> </li> <li> <p>Compile your code and test it</p> </li> <li> <p>Create a job script</p> </li> <li> <p>Submit your job</p> </li> <li> <p>Wait while</p> <ol> <li> <p>your job gets into the queue</p> </li> <li> <p>your job gets executed</p> </li> <li> <p>your job finishes</p> </li> </ol> </li> <li> <p>Move your results</p> </li> </ol> <p>We'll take you through the different tasks one by one in the following chapters.</p>"}, {"location": "alphafold/", "title": "AlphaFold", "text": ""}, {"location": "alphafold/#what-is-alphafold", "title": "What is AlphaFold?", "text": "<p>AlphaFold is an AI system developed by DeepMind that predicts a protein\u2019s 3D structure from its amino acid sequence.  It aims to achieve accuracy competitive with experimental methods.</p> <p>See https://www.vscentrum.be/alphafold for more information and there you can also find a getting started video recording if you prefer that. </p>"}, {"location": "alphafold/#documentation-extra-material", "title": "Documentation &amp; extra material", "text": "<p>This chapter focuses specifically on the use of AlphaFold on the UAntwerpen-HPC. It is intented to augment the existing AlphaFold documentation rather than replace it. It is therefore recommended to first familiarize yourself with AlphaFold. The following resources can be helpful:</p> <ul> <li>AlphaFold website: https://alphafold.com/</li> <li>AlphaFold repository: https://github.com/deepmind/alphafold/tree/main</li> <li>AlphaFold FAQ: https://alphafold.com/faq</li> <li>VSC webpage about AlphaFold: https://www.vscentrum.be/alphafold</li> <li>Introductory course on AlphaFold by VIB: https://elearning.vib.be/courses/alphafold</li> <li>\"Getting Started with AlphaFold\" presentation by Kenneth Hoste (HPC-UGent)<ul> <li>recording available on YouTube</li> <li>slides available here (PDF)</li> <li>see also https://www.vscentrum.be/alphafold</li> </ul> </li> </ul>"}, {"location": "alphafold/#using-alphafold-on-uantwerpen-hpc", "title": "Using AlphaFold on UAntwerpen-HPC", "text": "<p>Several different versions of AlphaFold are installed on both the CPU and GPU HPC-UGent Tier-2 clusters, see the output of <code>module avail AlphaFold</code>. If you run this command on a GPU cluster, additional CUDA modules will show up:</p> <pre><code>$ module avail AlphaFold\n\n------------ /apps/gent/RHEL8/cascadelake-volta-ib/modules/all -------------\n   AlphaFold/2.0.0-fosscuda-2020b\n   AlphaFold/2.1.1-fosscuda-2020b\n   AlphaFold/2.1.2-foss-2021a-CUDA-11.3.1\n   AlphaFold/2.2.2-foss-2021a-CUDA-11.3.1\n   AlphaFold/2.3.0-foss-2021b-CUDA-11.4.1\n   AlphaFold/2.3.1-foss-2022a-CUDA-11.7.0\n\n--------------- /apps/gent/RHEL8/cascadelake-ib/modules/all ----------------\n   AlphaFold/2.0.0-foss-2020b    AlphaFold/2.3.1-foss-2022a\n   AlphaFold/2.1.2-foss-2021a    AlphaFold/2.3.4-foss-2022a-ColabFold (D)\nAlphaFold/2.2.2-foss-2021a\n</code></pre> <p>To use AlphaFold, you should load a particular module, for example:</p> <pre><code>module load AlphaFold/2.3.1-foss-2022a-CUDA-11.7.0\n</code></pre> <p>We strongly advise loading a specific version of an AlphaFold module, so you know exactly which version is being used.</p> <p>Warning</p> <p>When using AlphaFold, you should submit jobs to a GPU cluster for better performance, see GPU clusters. Later in this chapter, you will find a comparison between running AlphaFold on CPUs or GPUs.</p> <p>Multiple revisions of the large database (~2.5TB) that is also required to run AlphaFold have been made available on the HPC-UGent infrastructure in a central location (/arcanine/scratch/gent/apps/AlphaFold),  so you do not have to download it yourself.</p> <pre><code>$ ls /arcanine/scratch/gent/apps/AlphaFold\n20210812  20211201  20220701  20230310\n</code></pre> <p>The directories located there indicate when the data was downloaded, so that this leaves room for providing updated datasets later.</p> <p>As of writing this documentation the latest version is <code>20230310</code>.</p> <p>Info</p> <p>The <code>arcanine scratch</code> shared filesystem is powered by fast SSD disks,  which is recommended for the AlphaFold data, because of random access I/O patterns. See Pre-defined user directories to get more info about the arcanine filesystem.</p> <p>The AlphaFold installations we provide have been modified a bit to facilitate the usage on UAntwerpen-HPC.</p>"}, {"location": "alphafold/#setting-up-the-environment", "title": "Setting up the environment", "text": "<p>The location to the AlphaFold data can be specified via the <code>$ALPHAFOLD_DATA_DIR</code> environment variable, so you should define this variable in your AlphaFold job script:</p> <pre><code>export ALPHAFOLD_DATA_DIR=/arcanine/scratch/gent/apps/AlphaFold/20230310\n</code></pre> <p>Use newest version</p> <p>Do not forget to replace <code>20230310</code> with a more up to date version if available.</p>"}, {"location": "alphafold/#running-alphafold", "title": "Running AlphaFold", "text": "<p>AlphaFold provides a script called run_alphafold.py</p> <p>A symbolic link named alphafold that points to this script is included, so you can just use <code>alphafold</code> instead of <code>run_alphafold.py</code> or <code>python run_alphafold.py</code> after loading the AlphaFold module.</p> <p>The <code>run_alphafold.py</code> script has also been slightly modified such that defining the <code>$ALPHAFOLD_DATA_DIR</code> (see above) is sufficient to pick up all the data provided in that location, so you don't need to use options like <code>--data_dir</code> to specify the location of the data.</p> <p>Similarly, the script was also tweaked such that the location to commands like <code>hhblits,hhsearch,jackhmmer,kalign</code> are already correctly set, so options like <code>--hhblits_binary_path</code> are not required.</p> <p>For more information about the script and options see this section in the official README.</p> <p>READ README</p> <p>It is strongly advised to read the official README provided by DeepMind before continuing.</p>"}, {"location": "alphafold/#controlling-core-count-for-hhblits-and-jackhmmer", "title": "Controlling core count for <code>hhblits</code> and <code>jackhmmer</code>", "text": "<p>The Python scripts that are used to run hhblits and jackhmmer have been tweaked so you can control how many cores are used for these tools, rather than hardcoding it to 4 and 8 cores, respectively.</p> <p>Using the <code>$ALPHAFOLD_HHBLITS_N_CPU</code> environment variable, you can specify how many cores should be used for running <code>hhblits</code>; the default of 4 cores will be used if <code>$ALPHAFOLD_HHBLITS_N_CPU</code> is not defined. </p> <p>Likewise for <code>jackhmmer</code>, the core count can be controlled via <code>$ALPHAFOLD_JACKHMMER_N_CPU</code>.</p> <p>Info</p> <p>Tweaking this might not yield significant benefits,  as we have noticed that these tools may exhibit slower performance when utilizing more than 4/8 cores (though this behavior could vary based on the workload).</p>"}, {"location": "alphafold/#cpugpu-comparison", "title": "CPU/GPU comparison", "text": "<p>The provided timings were obtained by executing the <code>T1050.fasta</code> example, as outlined in the Alphafold README.  For the corresponding jobscripts, they are available here.</p> <p>Using <code>--db_preset=full_dbs</code>, the following runtime data was collected:</p> <ul> <li>CPU-only, on doduo, using 24 cores (1 node): 9h 9min</li> <li>CPU-only, on doduo, using 96 cores (1 full node): 12h 22min</li> <li>GPU on joltik, using 1 V100 GPU + 8 cores: 2h 20min</li> <li>GPU on joltik, using 2 V100 GPUs + 16 cores: 2h 16min</li> </ul> <p>This highlights a couple of important attention points:</p> <ul> <li>Running AlphaFold on GPU is significantly faster than CPU-only (close to 4x faster for this particular example).</li> <li>Using more CPU cores may lead to longer runtimes, so be careful with using full nodes when running AlphaFold CPU-only.</li> <li>Using multiple GPUs results in barely any speedup (for this particular T1050.fasta example).</li> </ul> <p>With <code>--db_preset=casp14</code>, it is clearly more demanding:</p> <ul> <li>On doduo, with 24 cores (1 node): still running after 48h...</li> <li>On joltik, 1 V100 GPU + 8 cores: 4h 48min</li> </ul> <p>This highlights the difference between CPU and GPU performance even more.</p>"}, {"location": "alphafold/#example-scenario", "title": "Example scenario", "text": "<p>The following example comes from the official Examples section in the Alphafold README. The run command is slightly different (see above: Running AlphaFold).</p> <p>Do not forget to set up the environment (see above: Setting up the environment).</p>"}, {"location": "alphafold/#folding-a-monomer", "title": "Folding a monomer", "text": "<p>Say we have a monomer with the sequence <code>&lt;SEQUENCE&gt;</code>. Create a file <code>monomer.fasta</code> with the following content: <pre><code>&gt;sequence_name\n&lt;SEQUENCE&gt;\n</code></pre></p> <p>Then run the following command in the same directory: <pre><code>alphafold --fasta_paths=monomer.fasta \\\n--max_template_date=2021-11-01 \\\n--model_preset=monomer \\\n--output_dir=.\n</code></pre></p> <p>See AlphaFold output, for information about the outputs.</p> <p>Info</p> <p>For more scenarios see the example section in the official README.</p>"}, {"location": "alphafold/#example-jobscripts", "title": "Example jobscripts", "text": "<p>The following two example job scripts can be used as a starting point for running AlphaFold.</p> <p>The main difference between using a GPU or CPU in a job script is what module to load. For running AlphaFold on GPU, use an AlphaFold module that mentions <code>CUDA</code> (or <code>cuda</code>), for example <code>AlphaFold/2.3.1-foss-2022a-CUDA-11.7.0</code>.</p> <p>To run the job scripts you need to create a file named <code>T1050.fasta</code> with the following content:</p> <p><pre><code>&gt;T1050 A7LXT1, Bacteroides Ovatus, 779 residues|\nMASQSYLFKHLEVSDGLSNNSVNTIYKDRDGFMWFGTTTGLNRYDGYTFKIYQHAENEPGSLPDNYITDIVEMPDGRFWINTARGYVLFDKERDYFITDVTGFMKNLESWGVPEQVFVDREGNTWLSVAGEGCYRYKEGGKRLFFSYTEHSLPEYGVTQMAECSDGILLIYNTGLLVCLDRATLAIKWQSDEIKKYIPGGKTIELSLFVDRDNCIWAYSLMGIWAYDCGTKSWRTDLTGIWSSRPDVIIHAVAQDIEGRIWVGKDYDGIDVLEKETGKVTSLVAHDDNGRSLPHNTIYDLYADRDGVMWVGTYKKGVSYYSESIFKFNMYEWGDITCIEQADEDRLWLGTNDHGILLWNRSTGKAEPFWRDAEGQLPNPVVSMLKSKDGKLWVGTFNGGLYCMNGSQVRSYKEGTGNALASNNVWALVEDDKGRIWIASLGGGLQCLEPLSGTFETYTSNNSALLENNVTSLCWVDDNTLFFGTASQGVGTMDMRTREIKKIQGQSDSMKLSNDAVNHVYKDSRGLVWIATREGLNVYDTRRHMFLDLFPVVEAKGNFIAAITEDQERNMWVSTSRKVIRVTVASDGKGSYLFDSRAYNSEDGLQNCDFNQRSIKTLHNGIIAIGGLYGVNIFAPDHIRYNKMLPNVMFTGLSLFDEAVKVGQSYGGRVLIEKELNDVENVEFDYKQNIFSVSFASDNYNLPEKTQYMYKLEGFNNDWLTLPVGVHNVTFTNLAPGKYVLRVKAINSDGYVGIKEATLGIVVNPPFKLAAALQHHHHHH\n</code></pre> source: https://www.predictioncenter.org/casp14/target.cgi?target=T1050&amp;view=sequence</p>"}, {"location": "alphafold/#job-script-for-running-alphafold-on-gpu", "title": "Job script for running AlphaFold on GPU", "text": "<p>Job script that runs AlphaFold on GPU using 1 V100 GPU + 8 cores.</p> <p>Swap to the <code>joltik</code> GPU before submitting it:</p> <pre><code>module swap cluster/joltik\n</code></pre> AlphaFold-gpu-joltik.sh<pre><code>#!/bin/bash\n#PBS -N AlphaFold-gpu-joltik\n#PBS -l nodes=1:ppn=8,gpus=1\n#PBS -l walltime=10:0:0\n\nmodule load AlphaFold/2.3.1-foss-2022a-CUDA-11.7.0\n\nexport ALPHAFOLD_DATA_DIR=/arcanine/scratch/gent/apps/AlphaFold/20230310\n\nWORKDIR=$VSC_SCRATCH/$PBS_JOBNAME-$PBS_JOBID\nmkdir -p $WORKDIR\n\n# download T1050.fasta via via https://www.predictioncenter.org/casp14/target.cgi?target=T1050&amp;view=sequence\ncp -a $PBS_O_WORKDIR/T1050.fasta $WORKDIR/\n\ncd $WORKDIR\n\nalphafold --fasta_paths=T1050.fasta --max_template_date=2020-05-14 --db_preset=full_dbs --output_dir=$PWD\n\necho \"Output available in $WORKDIR\"\n</code></pre>"}, {"location": "alphafold/#job-script-for-running-alphafold-cpu-only", "title": "Job script for running AlphaFold CPU-only", "text": "<p>Jobscript that runs AlphaFold on CPU using 24 cores on one node.</p> AlphaFold-cpu-doduo.sh<pre><code>#!/bin/bash\n#PBS -N AlphaFold-cpu-doduo\n#PBS -l nodes=1:ppn=24\n#PBS -l walltime=72:0:0\n\nmodule load AlphaFold/2.3.1-foss-2022a export ALPHAFOLD_DATA_DIR=/arcanine/scratch/gent/apps/AlphaFold/20230310\n\nWORKDIR=$VSC_SCRATCH/$PBS_JOBNAME-$PBS_JOBID\nmkdir -p $WORKDIR\n\n# download T1050.fasta via via https://www.predictioncenter.org/casp14/target.cgi?target=T1050&amp;view=sequence\ncp -a $PBS_O_WORKDIR/T1050.fasta $WORKDIR/\n\ncd $WORKDIR\n\nalphafold --fasta_paths=T1050.fasta --max_template_date=2020-05-14 --db_preset=full_dbs --output_dir=$PWD\necho \"Output available in $WORKDIR\"\n</code></pre> <p>In case of problems or questions, don't hesitate to contact use at hpc@uantwerpen.be.</p>"}, {"location": "apptainer/", "title": "Apptainer (formally known as Singularity)", "text": ""}, {"location": "apptainer/#what-is-apptainer", "title": "What is Apptainer?", "text": "<p>Apptainer is an open-source computer program that performs operating-system-level virtualization (also known as containerisation).</p> <p>One of the main uses of Apptainer is to bring containers and reproducibility to scientific computing and the high-performance computing (HPC) world. Using Apptainer/Singularity containers, developers can work in reproducible environments of their choosing and design, and these complete environments can easily be copied and executed on other platforms.</p> <p>For more general information about the use of Apptainer, please see the official documentation at https://apptainer.org/docs/.</p> <p>This documentation only covers aspects of using Apptainer on the UAntwerpen-HPC.</p>"}, {"location": "apptainer/#restrictions-on-image-location", "title": "Restrictions on image location", "text": "<p>Some restrictions have been put in place on the use of Apptainer. This is mainly done for performance reasons and to avoid that the use of Apptainer impacts other users on the system.</p> <p>The Apptainer/Singularity image file must be located on either one of the scratch filesystems, the local disk of the workernode you are using or <code>/dev/shm</code>. The centrally provided <code>apptainer</code> command will refuse to run using images that are located elsewhere, in particular on the <code>$VSC_HOME</code>, <code>/apps</code> or <code>$VSC_DATA</code> filesystems.</p> <p>In addition, this implies that running containers images provided via a URL (e.g., <code>shub://...</code> or <code>docker://...</code>) will not work.</p> <p>If these limitations are a problem for you, please let us know via hpc@uantwerpen.be.</p>"}, {"location": "apptainer/#available-filesystems", "title": "Available filesystems", "text": "<p>All HPC-UGent shared filesystems will be readily available in an Apptainer/Singularity container, including the home, data and scratch filesystems, and they will be accessible via the familiar <code>$VSC_HOME</code>, <code>$VSC_DATA*</code> and <code>$VSC_SCRATCH*</code> environment variables.</p>"}, {"location": "apptainer/#apptainersingularity-images", "title": "Apptainer/Singularity Images", "text": ""}, {"location": "apptainer/#creating-apptainersingularity-images", "title": "Creating Apptainer/Singularity images", "text": "<p>We recommend writing your Apptainer/Singularity image to a globally writable location,  like <code>/tmp</code>, or <code>/local</code> directories.  Once the image is created, you should move it to your desired destination.  An example to make an Apptainer/Singularity container image:</p> <pre><code># avoid that Apptainer uses $HOME/.cache\nexport APPTAINER_CACHEDIR=/tmp/$USER/apptainer/cache\n# instruct Apptainer to use temp dir on local filesystem\nexport APPTAINER_TMPDIR=/tmp/$USER/apptainer/tmpdir\n# specified temp dir must exist, so create it\nmkdir -p $APPTAINER_TMPDIR\n# convert Docker container to Apptainer container image\napptainer build /tmp/$USER/tf.sif docker://nvcr.io/nvidia/tensorflow:21.10-tf1-py3\n# mv container image to $VSC_SCRATCH\nmv /tmp/$USER/tf.sif $VSC_SCRATCH/tf.sif\n</code></pre>"}, {"location": "apptainer/#converting-docker-images", "title": "Converting Docker images", "text": "<p>For more information on converting existing Docker images to Apptainer/Singularity images, see https://apptainer.org/docs/user/main/docker_and_oci.html.</p> <p>We strongly recommend the use of Docker Hub, see https://hub.docker.com/ for more information.</p>"}, {"location": "apptainer/#execute-our-own-script-within-our-container", "title": "Execute our own script within our container", "text": "<p>Copy testing image from <code>/apps/gent/tutorials/Singularity</code> to <code>$VSC_SCRATCH</code>:</p> <pre><code>cp /apps/gent/tutorials/Singularity/CentOS7_EasyBuild.img $VSC_SCRATCH/\n</code></pre> <p>Create a job script like:</p> <pre><code>#!/bin/sh\n\n#PBS -o apptainer.output\n#PBS -e apptainer.error\n#PBS -l nodes=1:ppn=1\n#PBS -l walltime=12:00:00\n\n\napptainer exec $VSC_SCRATCH/CentOS7_EasyBuild.img ~/my_script.sh\n</code></pre> <p>Create an example <code>myscript.sh</code>:</p> <pre><code>#!/bin/bash\n\n# prime factors\nfactor 1234567\n</code></pre>"}, {"location": "apptainer/#tensorflow-example", "title": "Tensorflow example", "text": "<p>We already have a Tensorflow example image, but you can also convert the Docker image (see https://hub.docker.com/r/tensorflow/tensorflow) to an Apptainer/Singularity image yourself</p> <p>Copy testing image from <code>/apps/gent/tutorials</code> to <code>$VSC_SCRATCH</code>:</p> <pre><code>cp /apps/gent/tutorials/Singularity/Ubuntu14.04_tensorflow.img $VSC_SCRATCH/\n</code></pre> <pre><code>#!/bin/sh\n#\n#\n#PBS -o tensorflow.output\n#PBS -e tensorflow.error\n#PBS -l nodes=1:ppn=4\n#PBS -l walltime=12:00:00\n#\n\napptainer exec $VSC_SCRATCH/Ubuntu14.04_tensorflow.img python ~/linear_regression.py\n</code></pre> <p>You can download <code>linear_regression.py</code> from the official Tensorflow repository.</p>"}, {"location": "apptainer/#mpi-example", "title": "MPI example", "text": "<p>It is also possible to execute MPI jobs within a container, but the following requirements apply:</p> <ul> <li> <p>Mellanox IB libraries must be available from the container (install     the <code>infiniband-diags</code>, <code>libmlx5-1</code> and <code>libmlx4-1</code> OS packages)</p> </li> <li> <p>Use modules within the container (install the <code>environment-modules</code>     or <code>lmod</code> package in your container)</p> </li> <li> <p>Load the required module(s) before <code>apptainer</code> execution.</p> </li> <li> <p>Set <code>C_INCLUDE_PATH</code> variable in your container if it is required     during compilation time     (<code>export C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu/:$C_INCLUDE_PATH</code>     for Debian flavours)</p> </li> </ul> <p>Copy the testing image from <code>/apps/gent/tutorials/Singularity</code> to <code>$VSC_SCRATCH</code></p> <pre><code>cp /apps/gent/tutorials/Singularity/Debian8_UGentMPI.img $VSC_SCRATCH/\n</code></pre> <p>For example to compile an MPI example:</p> <pre><code>module load intel\napptainer shell $VSC_SCRATCH/Debian8_UGentMPI.img\nexport LANG=C\nexport C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu/:$C_INCLUDE_PATH\nmpiicc ompi/examples/ring_c.c -o ring_debian\nexit\n</code></pre> <p>Example MPI job script:</p> <pre><code>#!/bin/sh\n\n#PBS -N mpi\n#PBS -o apptainermpi.output\n#PBS -e apptainermpi.error\n#PBS -l nodes=2:ppn=15\n#PBS -l walltime=12:00:00\n\nmodule load intel vsc-mympirun\nmympirun --impi-fallback apptainer exec $VSC_SCRATCH/Debian8_UGentMPI.img ~/ring_debian\n</code></pre>"}, {"location": "best_practices/", "title": "Best Practices", "text": ""}, {"location": "best_practices/#sec:general-best-practices", "title": "General Best Practices", "text": "<ol> <li> <p>Before starting, you should always check:</p> <ul> <li> <p>Are there any errors in the script?</p> </li> <li> <p>Are the required modules loaded?</p> </li> <li> <p>Is the correct executable used?</p> </li> </ul> </li> <li> <p>Check your computer requirements upfront, and request the correct     resources in your batch job script.</p> <ul> <li> <p>Number of requested cores</p> </li> <li> <p>Amount of requested memory</p> </li> <li> <p>Requested network type</p> </li> </ul> </li> <li> <p>Check your jobs at runtime. You could login to the node and check     the proper execution of your jobs with, e.g., <code>top</code> or <code>vmstat</code>.     Alternatively you could run an interactive job (<code>qsub -I</code>).</p> </li> <li> <p>Try to benchmark the software for scaling issues when using MPI or     for I/O issues.</p> </li> <li> <p>Use the scratch file system (<code>$VSC_SCRATCH_NODE</code>, which is mapped to     the local /tmp) whenever possible. Local disk I/O is always much     faster as it does not have to use the network.</p> </li> <li> <p>When your job starts, it will log on to the compute node(s) and     start executing the commands in the job script. It will start in     your home directory <code>$VSC_HOME</code>, so going to the current directory     with <code>cd $PBS_O_WORKDIR</code> is the first thing which needs to be done.     You will have your default environment, so don't forget to load the     software with <code>module load</code>.</p> </li> <li> <p>In case your job not running, use \"checkjob\". It will show why your     job is not yet running. Sometimes commands might timeout with an     overloaded scheduler.</p> </li> <li> <p>Submit your job and wait (be patient) ...</p> </li> <li> <p>Submit small jobs by grouping them together. See chapter Multi-job submission for      how this is done.</p> </li> <li> <p>The runtime is limited by the maximum walltime of the queues.</p> </li> <li> <p>Requesting many processors could imply long queue times. It's     advised to only request the resources you'll be able to use.</p> </li> <li> <p>For all multi-node jobs, please use a cluster that has an     \"InfiniBand\" interconnect network.</p> </li> <li> <p>And above all, do not hesitate to contact the UAntwerpen-HPC staff at hpc@uantwerpen.be. We're here     to help you.</p> </li> </ol>"}, {"location": "compiling_your_software/", "title": "Compiling and testing your software on the HPC", "text": "<p>All nodes in the UAntwerpen-HPC cluster are running the \"CentOS Linux release 7.8.2003 (Core)\"  Operating system, which is a specific version of RedHat Enterprise Linux. This means that all the  software programs (executable) that the end-user wants to run on the UAntwerpen-HPC first must be compiled for CentOS Linux release 7.8.2003 (Core). It also means that you first have to install all the required external software packages on the UAntwerpen-HPC.</p> <p>Most commonly used compilers are already pre-installed on the UAntwerpen-HPC and can be used straight away. Also, many popular external software packages, which are regularly used in the scientific community, are also pre-installed.</p>"}, {"location": "compiling_your_software/#check-the-pre-installed-software-on-the-uantwerpen-hpc", "title": "Check the pre-installed software on the UAntwerpen-HPC", "text": "<p>In order to check all the available modules and their version numbers, which are pre-installed on the UAntwerpen-HPC enter:</p> <pre><code>$ module av 2&gt;&amp;1 | more\n------------- /apps/antwerpen/modules/hopper/2015a/all ------------\nABINIT/7.10.2-intel-2015a\nADF/2014.05\nAdvisor/2015_update1\nBison/3.0.4-intel-2015a\nBoost/1.57.0-foss-2015a-Python-2.7.9\nBoost/1.57.0-intel-2015a-Python-2.7.9\nbzip2/1.0.6-foss-2015a\nbzip2/1.0.6-intel-2015a\n...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., LAMMPS) is installed on the UAntwerpen-HPC.</p> <pre><code>$ module av 2&gt;&amp;1 | grep -i -e \"LAMMPS\"\nLAMMPS/9Dec14-intel-2015a\nLAMMPS/30Oct14-intel-2014a\nLAMMPS/5Sep14-intel-2014a\n</code></pre> <p>As you are not aware of the capitals letters in the module name, we looked for a case-insensitive name with the \"-i\" option.</p> <p>When your required application is not available on the UAntwerpen-HPC please contact any UAntwerpen-HPC member. Be aware of potential \"License Costs\". \"Open Source\" software is often preferred.</p>"}, {"location": "compiling_your_software/#porting-your-code", "title": "Porting your code", "text": "<p>To port a software-program is to translate it from the operating system in which it was developed (e.g., Windows 7) to another operating system (e.g., RedHat Enterprise Linux on our UAntwerpen-HPC) so that it can be used there. Porting implies some degree of effort, but not nearly as much as redeveloping the program in the new environment. It all depends on how \"portable\" you wrote your code.</p> <p>In the simplest case the file or files may simply be copied from one machine to the other. However, in many cases the software is installed on a computer in a way, which depends upon its detailed hardware, software, and setup, with device drivers for particular devices, using installed operating system and supporting software components, and using different directories.</p> <p>In some cases software, usually described as \"portable software\" is specifically designed to run on different computers with compatible operating systems and processors without any machine-dependent installation; it is sufficient to transfer specified directories and their contents. Hardware- and software-specific information is often stored in configuration files in specified locations (e.g., the registry on machines running MS Windows).</p> <p>Software, which is not portable in this sense, will have to be transferred with modifications to support the environment on the destination machine.</p> <p>Whilst programming, it would be wise to stick to certain standards (e.g., ISO/ANSI/POSIX). This will ease the porting of your code to other platforms.</p> <p>Porting your code to the CentOS Linux release 7.8.2003 (Core) platform is the responsibility of the end-user.</p>"}, {"location": "compiling_your_software/#compiling-and-building-on-the-uantwerpen-hpc", "title": "Compiling and building on the UAntwerpen-HPC", "text": "<p>Compiling refers to the process of translating code written in some programming language, e.g., Fortran, C, or C++, to machine code. Building is similar, but includes gluing together the machine code resulting from different source files into an executable (or library). The text below guides you through some basic problems typical for small software projects. For larger projects it is more appropriate to use makefiles or even an advanced build system like CMake.</p> <p>All the UAntwerpen-HPC nodes run the same version of the Operating System, i.e. CentOS Linux release 7.8.2003 (Core). So, it is sufficient to compile your program on any compute node. Once you have generated an executable with your compiler, this executable should be able to run on any other compute-node.</p> <p>A typical process looks like:</p> <ol> <li> <p>Copy your software to the login-node of the UAntwerpen-HPC</p> </li> <li> <p>Start an interactive session on a compute node;</p> </li> <li> <p>Compile it;</p> </li> <li> <p>Test it locally;</p> </li> <li> <p>Generate your job scripts;</p> </li> <li> <p>Test it on the UAntwerpen-HPC</p> </li> <li> <p>Run it (in parallel);</p> </li> </ol> <p>We assume you've copied your software to the UAntwerpen-HPC. The next step is to request your private compute node.</p> <pre><code>$ qsub -I\nqsub: waiting for job 433253.leibniz to start\n</code></pre>"}, {"location": "compiling_your_software/#compiling-a-sequential-program-in-c", "title": "Compiling a sequential program in C", "text": "<p>Go to the examples for chapter  Compiling and testing your software on the HPC and load the  foss module: <pre><code>cd ~/examples/Compiling-and-testing-your-software-on-the-HPC\nmodule load foss\n</code></pre></p> <p>We now list the directory and explore the contents of the \"hello.c\" program: <pre><code>$ ls -l\ntotal 512\n-rw-r--r-- 1 vsc20167 214 Sep 16 09:42 hello.c\n-rw-r--r-- 1 vsc20167 130 Sep 16 11:39 hello.pbs*\n-rw-r--r-- 1 vsc20167 359 Sep 16 13:55 mpihello.c\n-rw-r--r-- 1 vsc20167 304 Sep 16 13:55 mpihello.pbs\n</code></pre></p> hello.c<pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: Print 500 numbers, whilst waiting 1 second in between\n */\n#include \"stdio.h\"\nint main( int argc, char *argv[] )\n{\nint i;\nfor (i=0; i&lt;500; i++)\n{\nprintf(\"Hello #%d\\n\", i);\nfflush(stdout);\nsleep(1);\n}\n}\n</code></pre> <p>The \"hello.c\" program is a simple source file, written in C. It'll print 500 times \"Hello #&lt;num&gt;\", and waits one second between 2 printouts.</p> <p>We first need to compile this C-file into an executable with the gcc-compiler.</p> <p>First, check the command line options for \"gcc\" (GNU C-Compiler), then we compile. the <code>O2</code> option enables a moderate level of optimization when compiling the code.  It instructs the compiler to optimize the code for better performance without significantly increasing compilation time. Finally, list the contents of the directory again: <pre><code>$ gcc -help\n$ gcc -O2 -o hello hello.c\n$ ls -l\ntotal 512\n-rwxrwxr-x 1 vsc20167 7116 Sep 16 11:43 hello*\n-rw-r--r-- 1 vsc20167  214 Sep 16 09:42 hello.c\n-rwxr-xr-x 1 vsc20167  130 Sep 16 11:39 hello.pbs*\n</code></pre></p> <p>A new file \"hello\" has been created. Note that this file has \"execute\" rights, i.e., it is an executable. More often than not, calling gcc -- or any other compiler for that matter -- will provide you with a list of errors and warnings referring to mistakes the programmer made, such as typos, syntax errors. You will have to correct them first in order to make the code compile. Warnings pinpoint less crucial issues that may relate to performance problems, using unsafe or obsolete language features, etc. It is good practice to remove all warnings from a compilation process, even if they seem unimportant so that a code change that produces a warning does not go unnoticed.</p> <p>Let's test this program on the local compute node, which is at your disposal after the <code>qsub --I</code> command: <pre><code>$ ./hello\nHello #0\nHello #1\nHello #2\nHello #3\nHello #4\n...\n</code></pre></p> <p>It seems to work, now run it on the UAntwerpen-HPC <pre><code>qsub hello.pbs\n</code></pre></p>"}, {"location": "compiling_your_software/#compiling-a-parallel-program-in-cmpi", "title": "Compiling a parallel program in C/MPI", "text": "<pre><code>cd ~/examples/Compiling-and-testing-your-software-on-the-HPC\n</code></pre> <p>List the directory and explore the contents of the \"mpihello.c\" program: <pre><code>$ ls -l\ntotal 512\ntotal 512\n-rw-r--r-- 1 vsc20167 214 Sep 16 09:42 hello.c\n-rw-r--r-- 1 vsc20167 130 Sep 16 11:39 hello.pbs*\n-rw-r--r-- 1 vsc20167 359 Sep 16 13:55 mpihello.c\n-rw-r--r-- 1 vsc20167 304 Sep 16 13:55 mpihello.pbs\n</code></pre></p> mpihello.c<pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: Example program, to compile with MPI\n */\n#include &lt;stdio.h&gt;\n#include &lt;mpi.h&gt;\n\nmain(int argc, char **argv)\n{\nint node, i, j;\nfloat f;\n\nMPI_Init(&amp;argc,&amp;argv);\nMPI_Comm_rank(MPI_COMM_WORLD, &amp;node);\n\nprintf(\"Hello World from Node %d.\\n\", node);\nfor (i=0; i&lt;=100000; i++)\nf=i*2.718281828*i+i+i*3.141592654;\n\nMPI_Finalize();\n}\n</code></pre> <p>The \"mpi_hello.c\" program is a simple source file, written in C with MPI library calls.</p> <p>Then, check the command line options for \"mpicc\" (GNU C-Compiler with MPI extensions), then we compile and list the contents of the directory again:</p> <pre><code>mpicc --help\nmpicc -o mpihello mpihello.c\nls -l\n</code></pre> <p>A new file \"hello\" has been created. Note that this program has \"execute\" rights.</p> <p>Let's test this program on the \"login\" node first:</p> <pre><code>$ ./mpihello\nHello World from Node 0.\n</code></pre> <p>It seems to work, now run it on the UAntwerpen-HPC.</p> <pre><code>qsub mpihello.pbs\n</code></pre>"}, {"location": "compiling_your_software/#compiling-a-parallel-program-in-intel-parallel-studio-cluster-edition", "title": "Compiling a parallel program in Intel Parallel Studio Cluster Edition", "text": "<p>We will now compile the same program, but using the Intel Parallel Studio Cluster Edition compilers. We stay in the examples directory for this chapter:</p> <pre><code>cd ~/examples/Compiling-and-testing-your-software-on-the-HPC\n</code></pre> <p>We will compile this C/MPI -file into an executable with the Intel Parallel Studio Cluster Edition. First, clear the modules (purge) and then load the latest \"intel\" module:</p> <pre><code>module purge\nmodule load intel\n</code></pre> <p>Then, compile and list the contents of the directory again. The Intel equivalent of mpicc is mpiicc. <pre><code>mpiicc -o mpihello mpihello.c\nls -l\n</code></pre></p> <p>Note that the old \"mpihello\" file has been overwritten. Let's test this program on the \"login\" node first: <pre><code>$ ./mpihello\nHello World from Node 0.\n</code></pre></p> <p>It seems to work, now run it on the UAntwerpen-HPC.</p> <pre><code>qsub mpihello.pbs\n</code></pre> <p>Note: The Antwerp University Association (AUHA) only has a license for the Intel Parallel Studio Cluster Edition for a fixed number of users. As such, it might happen that you have to wait a few minutes before a floating license becomes available for your use.</p> <p>Note: The Intel Parallel Studio Cluster Edition contains equivalent compilers for all GNU compilers. Hereafter the overview for C, C++ and Fortran compilers.</p> Sequential Program Parallel Program (with MPI) GNU Intel GNU Intel C gcc icc mpicc mpiicc C++ g++ icpc mpicxx mpiicpc Fortran gfortran ifort mpif90 mpiifort"}, {"location": "connecting/", "title": "Connecting to the HPC infrastructure", "text": "<p>Before you can really start using the UAntwerpen-HPC clusters, there are several things you need to do or know:</p> <ol> <li> <p>You need to log on to the cluster using an SSH client to one of     the login nodes or by using the HPC web portal.     This will give you command-line access.     A standard web browser like Firefox or Chrome for the web portal will suffice.</p> </li> <li> <p>Before you can do some work, you'll have to transfer the files     that you need from your desktop computer to the cluster. At the end     of a job, you might want to transfer some files back.</p> </li> <li> <p>Optionally, if you wish to use programs with a graphical user     interface, you will need an X-server on your client system and log     in to the login nodes with X-forwarding enabled.</p> </li> <li> <p>Often several versions of software packages and libraries are     installed, so you need to select the ones you need. To manage     different versions efficiently, the VSC clusters use so-called     modules, so you will need to select and load the modules that     you need.</p> </li> </ol>"}, {"location": "connecting/#connection-restrictions", "title": "Connection restrictions", "text": "<p>Since March 20th 2020, restrictions are in place that limit from where you can connect to the VSC HPC infrastructure, in response to security incidents involving several European HPC centres.</p> <p>VSC login nodes are only directly accessible from within university networks, and from (most) Belgian commercial internet providers.</p> <p>All other IP domains are blocked by default. If you are connecting from an IP address that is not allowed direct access, you have the following options to get access to VSC login nodes:</p> <ul> <li> <p>Use an VPN connection to connect to University of Antwerp the network (recommended).</p> </li> <li> <p>Whitelist your IP address automatically by accessing     https://firewall.vscentrum.be and log in with your University of Antwerp account.</p> <ul> <li> <p>While this web connection is active new SSH sessions can be     started.</p> </li> <li> <p>Active SSH sessions will remain active even when this web page     is closed.</p> </li> </ul> </li> <li> <p>Contact your HPC support team (via hpc@uantwerpen.be) and ask them to whitelist your     IP range (e.g., for industry access, automated processes).</p> </li> </ul> <p>Trying to establish an SSH connection from an IP address that does not adhere to these restrictions will result in an immediate failure to connect, with an error message like:</p> <pre><code>ssh_exchange_identification: read: Connection reset by peer\n</code></pre>"}, {"location": "connecting/#first-time-connection-to-the-hpc-infrastructure", "title": "First Time connection to the HPC infrastructure", "text": "<p>The remaining content in this chapter is primarily focused for people utilizing a terminal with SSH. If you are instead using the web portal, the corresponding chapter might be more helpful: Using the HPC-UGent web portal.</p> <p>If you have any issues connecting to the UAntwerpen-HPC after you've followed these steps, see Issues connecting to login node to troubleshoot. When connecting from outside Belgium, you need a VPN client to connect to the network first.</p>"}, {"location": "connecting/#connect", "title": "Connect", "text": "<p>Open up a terminal and enter the following command to connect to the UAntwerpen-HPC.</p> <pre><code>ssh vsc20167@login.hpc.uantwerpen.be\n</code></pre> <p>Here, user vsc20167 wants to make a connection to the \"Leibniz\" cluster at University of Antwerp via the login node \"login.hpc.uantwerpen.be\", so replace vsc20167 with your own VSC id in the above command.</p> <p>The first time you make a connection to the login node, you will be asked to verify the authenticity of the login node. Please check Warning message when first connecting to new host on how to do this.</p> <p>A possible error message you can get if you previously saved your private key somewhere else than the default location (<code>$HOME/.ssh/id_rsa</code>):</p> <pre><code>Permission denied (publickey,gssapi-keyex,gssapi-with-mic).\n</code></pre> <p>In this case, use the <code>-i</code> option for the <code>ssh</code> command to specify the location of your private key. For example:</p> <pre><code>ssh -i /home/example/my_keys\n</code></pre> <p>Congratulations, you're on the UAntwerpen-HPC infrastructure now! To find out where you have landed you can print the current working directory:</p> <pre><code>$ pwd\n/user/antwerpen/201/vsc20167\n</code></pre> <p>Your new private home directory is \"/user/antwerpen/201/vsc20167\". Here you can create your own subdirectory structure, copy and prepare your applications, compile and test them and submit your jobs on the UAntwerpen-HPC.</p> <pre><code>$ cd /apps/antwerpen/tutorials\n$ ls\nIntro-HPC/\n</code></pre> <p>This directory currently contains all training material for the Introduction to the UAntwerpen-HPC. More relevant training material to work with the UAntwerpen-HPC can always be added later in this directory.</p> <p>You can now explore the content of this directory with the \"ls --l\" (lists long) and the \"cd\" (change directory) commands:</p> <p>As we are interested in the use of the HPC, move further to Intro-HPC and explore the contents up to 2 levels deep:</p> <pre><code>$ cd Intro-HPC\n$ tree -L 2\n.\n'-- examples\n    |-- Compiling-and-testing-your-software-on-the-HPC\n    |-- Fine-tuning-Job-Specifications\n    |-- Multi-core-jobs-Parallel-Computing\n    |-- Multi-job-submission\n    |-- Program-examples\n    |-- Running-batch-jobs\n    |-- Running-jobs-with-input\n    |-- Running-jobs-with-input-output-data\n    |-- example.pbs\n    '-- example.sh\n9 directories, 5 files\n</code></pre> <p>This directory contains:</p> <ol> <li> <p>This HPC Tutorial (in either a Mac, Linux or      Windows version).</p> </li> <li> <p>An examples subdirectory, containing all the examples that you need in this     Tutorial, as well as examples that might be useful for your specific applications.</p> </li> </ol> <pre><code>cd examples\n</code></pre> <p>Tip</p> <p>Typing <code>cd ex</code> followed by Tab (the Tab-key) will generate the <code>cd examples</code> command. Command-line completion (also tab completion) is a common feature of the bash command line interpreter, in which the program automatically fills in partially typed commands.</p> <p>Tip</p> <p>For more exhaustive tutorials about Linux usage, see Appendix Useful Linux Commands</p> <p>The first action is to copy the contents of the UAntwerpen-HPC examples directory to your home directory, so that you have your own personal copy and that you can start using the examples. The \"-r\" option of the copy command will also copy the contents of the sub-directories \"recursively\".</p> <p><pre><code>cp -r /apps/antwerpen/tutorials/Intro-HPC/examples ~/\n</code></pre> Upon connection, you will get a welcome message containing your last login timestamp and some pointers to information about the system. On Leibniz, the system will also show your disk quota.</p> <pre><code>Last login: Mon Feb  2 17:58:13 2015 from mylaptop.uantwerpen.be\n\n---------------------------------------------------------------\n\nWelcome to LEIBNIZ !\n\nUseful links:\n  https://vscdocumentation.readthedocs.io\n  https://vscdocumentation.readthedocs.io/en/latest/antwerp/tier2_hardware.html\n  https://www.uantwerpen.be/hpc\n\nQuestions or problems? Do not hesitate and contact us:\n  hpc@uantwerpen.be\n\nHappy computing!\n\n---------------------------------------------------------------\n\nYour quota is:\n\n                   Block Limits\n   Filesystem       used      quota      limit    grace\n   user             740M         3G       3.3G     none\n   data           3.153G        25G      27.5G     none\n   scratch        12.38M        25G      27.5G     none\n   small          20.09M        25G      27.5G     none\n\n                   File Limits\n   Filesystem      files      quota      limit    grace\n   user            14471      20000      25000     none\n   data             5183     100000     150000     none\n   scratch            59     100000     150000     none\n   small            1389     100000     110000     none\n\n---------------------------------------------------------------\n</code></pre> <p>You can exit the connection at anytime by entering:</p> <pre><code>$ exit\nlogout\nConnection to login.hpc.uantwerpen.be closed.\n</code></pre> <p>tip: Setting your Language right</p> <p>You may encounter a warning message similar to the following one during connecting:</p> <p><pre><code>perl: warning: Setting locale failed.\nperl: warning: Please check that your locale settings:\nLANGUAGE = (unset),\nLC_ALL = (unset),\nLC_CTYPE = \"UTF-8\",\nLANG = (unset)\n    are supported and installed on your system.\nperl: warning: Falling back to the standard locale (\"C\").\n</code></pre> or any other error message complaining about the locale.</p> <p>This means that the correct \"locale\" has not yet been properly specified on your local machine. Try: <pre><code>LANG=\nLC_COLLATE=\"C\"\nLC_CTYPE=\"UTF-8\"\nLC_MESSAGES=\"C\"\nLC_MONETARY=\"C\"\nLC_NUMERIC=\"C\"\nLC_TIME=\"C\"\nLC_ALL=\n</code></pre></p> <p>A locale is a set of parameters that defines the user's language, country and any special variant preferences that the user wants to see in their user interface. Usually a locale identifier consists of at least a language identifier and a region identifier. Open the <code>.bashrc</code> on your local machine with your favourite editor and add the following lines:</p> <pre><code>$ nano ~/.bashrc\n...\nexport LANGUAGE=\"en_US.UTF-8\"\nexport LC_ALL=\"en_US.UTF-8\"\nexport LC_CTYPE=\"en_US.UTF-8\"\nexport LANG=\"en_US.UTF-8\"\n...\n</code></pre> <p>tip: vi</p> <p>To start entering text in vi: move to the place you want to start entering text with the arrow keys and type \"i\" to switch to insert mode. You can easily exit vi by entering: \"ESC :wq\" To exit vi without saving your changes, enter \"ESC:q!\"</p> <p>or alternatively (if you are not comfortable with the Linux editors), again on your local machine:</p> <pre><code>echo \"export LANGUAGE=\\\"en_US.UTF-8\\\"\" &gt;&gt; ~/.profile\necho \"export LC_ALL=\\\"en_US.UTF-8\\\"\" &gt;&gt; ~/.profile\necho \"export LC_CTYPE=\\\"en_US.UTF-8\\\"\" &gt;&gt; ~/.profile\necho \"export LANG=\\\"en_US.UTF-8\\\"\" &gt;&gt; ~/.profile\n</code></pre> <p>You can now log out, open a new terminal/shell on your local machine and reconnect to the login node, and you should not get these warnings anymore.</p>"}, {"location": "connecting/#transfer-files-tofrom-the-hpc", "title": "Transfer Files to/from the HPC", "text": "<p>Before you can do some work, you'll have to transfer the files you need from your desktop or department to the cluster. At the end of a job, you might want to transfer some files back. The preferred way to transfer files is by using an scp or sftp via the secure OpenSSH protocol. Linux ships with an implementation of OpenSSH, so you don't need to install any third-party software to use it. Just open a terminal window and jump in!</p>"}, {"location": "connecting/#using-scp", "title": "Using scp", "text": "<p>Secure copy or SCP is a tool (command) for securely transferring files between a local host (= your computer) and a remote host (the UAntwerpen-HPC). It is based on the Secure Shell (SSH) protocol. The scp command is the equivalent of the cp (i.e., copy) command, but can copy files to or from remote machines.</p> <p>It's easier to copy files directly to <code>$VSC_DATA</code> and <code>$VSC_SCRATCH</code> if you have symlinks to them in your home directory. See  the chapter titled \"Uploading/downloading/editing files\", section \"Symlinks for data/scratch\" in the intro to Linux  for how to do this.</p> <p>Open an additional terminal window and check that you're working on your local machine.</p> <pre><code>$ hostname\n&lt;local-machine-name&gt;\n</code></pre> <p>If you're still using the terminal that is connected to the UAntwerpen-HPC, close the connection by typing \"exit\" in the terminal window.</p> <p>For example, we will copy the (local) file \"localfile.txt\" to your home directory on the UAntwerpen-HPC cluster. We first generate a small dummy \"localfile.txt\", which contains the word \"Hello\". Use your own VSC account, which is something like \"vsc20167\". Don't forget the colon (<code>:</code>) at the end: if you forget it, it will just create a file named vsc20167@login.hpc.uantwerpen.be on your local filesystem. You can even specify where to save the file on the remote filesystem by putting a path after the colon.</p> <pre><code>$ echo \"Hello\" &gt; localfile.txt\n$ ls -l \n...\n-rw-r--r-- 1 user  staff   6 Sep 18 09:37 localfile.txt\n$ scp localfile.txt vsc20167@login.hpc.uantwerpen.be:\nlocalfile.txt     100%   6     0.0KB/s     00:00\n</code></pre> <p>Connect to the UAntwerpen-HPC via another terminal, print the working directory (to make sure you're in the home directory) and check whether the file has arrived:</p> <pre><code>$ pwd\n/user/antwerpen/201/vsc20167\n$ ls -l \ntotal 1536\ndrwxrwxr-x 2\ndrwxrwxr-x 2\ndrwxrwxr-x 10\n-rw-r--r-- 1\n$ cat localfile.txt\nHello\n</code></pre> <p>The scp command can also be used to copy files from the cluster to your local machine. Let us copy the remote file \"intro-HPC-Linux-Antwerpen.pdf\" from your \"docs\" subdirectory on the cluster to your local computer.</p> <p>First, we will confirm that the file is indeed in the \"docs\" subdirectory. In the terminal on the login node, enter:</p> <pre><code>$ cd ~/docs\n$ ls -l\ntotal 1536\n-rw-r--r-- 1 vsc20167 Sep 11 09:53 intro-HPC-Linux-Antwerpen.pdf\n</code></pre> <p>Now we will copy the file to the local machine. On the terminal on your own local computer, enter:</p> <pre><code>$ scp vsc20167@login.hpc.uantwerpen.be:./docs/intro-HPC-Linux-Antwerpen.pdf .\nintro-HPC-Linux-Antwerpen.pdf 100% 725KB 724.6KB/s 00:01\n$ ls -l\ntotal 899\n-rw-r--r-- 1 user staff 741995 Sep 18 09:53\n-rw-r--r-- 1 user staff      6 Sep 18 09:37 localfile.txt\n</code></pre> <p>The file has been copied from the HPC to your local computer.</p> <p>It's also possible to copy entire directories (and their contents) with the <code>-r</code> flag. For example, if we want to copy the local directory <code>dataset</code> to <code>$VSC_SCRATCH</code>, we can use the following command (assuming you've created the <code>scratch</code> symlink):</p> <pre><code>scp -r dataset vsc20167@login.hpc.uantwerpen.be:scratch\n</code></pre> <p>If you don't use the <code>-r</code> option to copy a directory, you will run into the following error:</p> <pre><code>$ scp dataset vsc20167@login.hpc.uantwerpen.be:scratch\ndataset: not a regular file\n</code></pre>"}, {"location": "connecting/#using-sftp", "title": "Using sftp", "text": "<p>The SSH File Transfer Protocol (also Secure File Transfer Protocol, or SFTP) is a network protocol that provides file access, file transfer and file management functionalities over any reliable data stream. It was designed as an extension of the Secure Shell protocol (SSH) version 2.0. This protocol assumes that it is run over a secure channel, such as SSH, that the server has already authenticated the client, and that the identity of the client user is available to the protocol.</p> <p>The sftp is an equivalent of the ftp command, with the difference that it uses the secure ssh protocol to connect to the clusters.</p> <p>One easy way of starting a sftp session is</p> <pre><code>sftp vsc20167@login.hpc.uantwerpen.be\n</code></pre> <p>Typical and popular commands inside an sftp session are:</p> cd ~/exmples/fibo Move to the examples/fibo subdirectory on the (i.e., the UAntwerpen-HPC remote machine) ls Get a list of the files in the current directory on the UAntwerpen-HPC. get fibo.py Copy the file \"fibo.py\" from the UAntwerpen-HPC get tutorial/HPC.pdf Copy the file \"HPC.pdf\" from the UAntwerpen-HPC, which is in the \"tutorial\" subdirectory. lcd test Move to the \"test\" subdirectory on your local machine. lcd .. Move up one level in the local directory. lls Get local directory listing. put test.py Copy the local file test.py to the UAntwerpen-HPC. put test1.py test2.py Copy the local file test1.py to the and rename it to test2.py. bye Quit the sftp session mget *.cc Copy all the remote files with extension \".cc\" to the local directory. mput *.h Copy all the local files with extension \".h\" to the UAntwerpen-HPC."}, {"location": "connecting/#using-a-gui", "title": "Using a GUI", "text": "<p>If you prefer a GUI to transfer files back and forth to the UAntwerpen-HPC, you can use your file browser. Open your file browser and press Ctrl+l</p> <p>This should open up a address bar where you can enter a URL. Alternatively, look for the \"connect to server\" option in your file browsers menu.</p> <p>Enter: sftp://vsc20167@login.hpc.uantwerpen.be/ and press enter.</p> <p>You should now be able to browse files on the UAntwerpen-HPC in your file browser.</p>"}, {"location": "connecting/#fast-file-transfer-for-large-datasets", "title": "Fast file transfer for large datasets", "text": "<p>See the section on <code>rsync</code> in chapter 5 of the Linux intro manual.</p>"}, {"location": "connecting/#changing-login-nodes", "title": "Changing login nodes", "text": "<p>It can be useful to have control over which login node you are on. However, when you connect to the HPC (High-Performance Computing) system, you are directed to a random login node, which might not be the one where you already have an active session. To address this, there is a way to manually switch your active login node.</p> <p>For instance, if you want to switch to the login node named <code>ln2.leibniz.uantwerpen.vsc</code>, you can use the following command while you are connected to the <code>ln1.leibniz.uantwerpen.vsc</code> login node on the HPC: <pre><code>ssh ln2.leibniz.uantwerpen.vsc\n</code></pre> This is also possible the other way around.</p> <p>If you want to find out which login host you are connected to, you can use the <code>hostname</code> command. <pre><code>$ hostname\nln2.leibniz.uantwerpen.vsc\n$ ssh ln1.leibniz.uantwerpen.vsc\n\n$ hostname\nln1.leibniz.uantwerpen.vsc\n</code></pre></p> <p>Rather than always starting a new session on the HPC, you can also use a terminal multiplexer like <code>screen</code> or <code>tmux</code>. These can make sessions that 'survives' across disconnects. You can find more information on how to use these tools here (or on other online sources):</p> <ul> <li>screen</li> <li>tmux</li> </ul>"}, {"location": "crontab/", "title": "Cron scripts", "text": ""}, {"location": "crontab/#cron-scripts-configuration", "title": "Cron scripts configuration", "text": "<p>It is possible to run automated cron scripts as regular user on the Ugent login nodes. Due to the high availability setup users should add their cron scripts on the same login node to avoid any cron job script duplication.</p> <p>In order to create a new cron script first login to HPC-UGent login node as usual with your vsc user's account (see section Connecting).</p> <p>Check if any cron script is already set in the current login node with:</p> <pre><code>crontab -l\n</code></pre> <p>At this point you can add/edit (with <code>vi</code> editor) any cron script running the command:</p> <pre><code>crontab -e\n</code></pre>"}, {"location": "crontab/#example-cron-job-script", "title": "Example cron job script", "text": "<pre><code> 15 5 * * * ~/runscript.sh &gt;&amp; ~/job.out\n</code></pre> <p>where <code>runscript.sh</code> has these lines in this example:</p> runscript.sh<pre><code>#!/bin/bash\n\nmodule swap cluster/donphan\nexport SLURM_CLUSTERS=\"donphan\"\n/usr/libexec/jobcli/qsub ~/job_scripts/test.sh &gt;&amp; ~/job.out\n</code></pre> <p>In the previous example a cron script was set to be executed every day at 5:15 am. More information about crontab and cron scheduling format at https://www.redhat.com/sysadmin/automate-linux-tasks-cron.</p> <p>Please note that you should login into the same login node to edit your previously generated crontab tasks. If that is not the case you can always jump from one login node to another with:</p> <pre><code>ssh gligar09    # or gligar10\n</code></pre>"}, {"location": "easybuild/", "title": "Easybuild", "text": ""}, {"location": "easybuild/#what-is-easybuild", "title": "What is Easybuild?", "text": "<p>You can use EasyBuild to build and install supported software in your own VSC account, rather than requesting a central installation by the HPC support team.</p> <p>EasyBuild (https://easybuilders.github.io/easybuild) is the software build and installation framework that was created by the HPC-UGent team, and has recently been picked up by HPC sites around the world. It allows you to manage (scientific) software on High Performance Computing (HPC) systems in an efficient way.</p>"}, {"location": "easybuild/#when-should-i-use-easybuild", "title": "When should I use Easybuild?", "text": "<p>For general software installation requests, please see I want to use software that is not available on the clusters yet. However, there might be reasons to install the software yourself:</p> <ul> <li> <p>applying custom patches to the software that only you or your group     are using</p> </li> <li> <p>evaluating new software versions prior to requesting a central     software installation</p> </li> <li> <p>installing (very) old software versions that are no longer eligible     for central installation (on new clusters)</p> </li> </ul>"}, {"location": "easybuild/#configuring-easybuild", "title": "Configuring EasyBuild", "text": "<p>Before you use EasyBuild, you need to configure it:</p>"}, {"location": "easybuild/#path-to-sources", "title": "Path to sources", "text": "<p>This is where EasyBuild can find software sources:</p> <pre><code>EASYBUILD_SOURCEPATH=$VSC_DATA/easybuild/sources:/apps/gent/source\n</code></pre> <ul> <li> <p>the first directory <code>$VSC_DATA/easybuild/sources</code> is where EasyBuild     will (try to) automatically download sources if they're not     available yet</p> </li> <li> <p><code>/apps/gent/source</code> is the central \"cache\" for already downloaded     sources, and will be considered by EasyBuild before downloading     anything</p> </li> </ul>"}, {"location": "easybuild/#build-directory", "title": "Build directory", "text": "<p>This directory is where EasyBuild will build software in. To have good performance, this needs to be on a fast filesystem.</p> <pre><code>export EASYBUILD_BUILDPATH=${TMPDIR:-/tmp/$USER}\n</code></pre> <p>On cluster nodes, you can use the fast, in-memory <code>/dev/shm/$USER</code> location as a build directory.</p>"}, {"location": "easybuild/#software-install-location", "title": "Software install location", "text": "<p>This is where EasyBuild will install the software (and accompanying modules) to.</p> <p>For example, to let it use <code>$VSC_DATA/easybuild</code>, use:</p> <pre><code>export EASYBUILD_INSTALLPATH=$VSC_DATA/easybuild/$VSC_OS_LOCAL/$VSC_ARCH_LOCAL$VSC_ARCH_SUFFIX\n</code></pre> <p>Using the <code>$VSC_OS_LOCAL</code>, <code>$VSC_ARCH</code> and <code>$VSC_ARCH_SUFFIX</code> environment variables ensures that your install software to a location that is specific to the cluster you are building for.</p> <p>Make sure you do not build software on the login nodes, since the loaded <code>cluster</code> module determines the location of the installed software. Software built on the login nodes may not work on the cluster you want to use the software on (see also Running software that is incompatible with host).</p> <p>To share custom software installations with members of your VO, replace <code>$VSC_DATA</code> with <code>$VSC_DATA_VO</code> in the example above.</p>"}, {"location": "easybuild/#using-easybuild", "title": "Using EasyBuild", "text": "<p>Before using EasyBuild, you first need to load the <code>EasyBuild</code> module. We don't specify a version here (this is an exception, for most other modules you should see Using explicit version numbers) because newer versions might include important bug fixes.</p> <pre><code>module load EasyBuild\n</code></pre>"}, {"location": "easybuild/#installing-supported-software", "title": "Installing supported software", "text": "<p>EasyBuild provides a large collection of readily available software versions, combined with a particular toolchain version. Use the <code>--search</code> (or <code>-S</code>) functionality to see which different 'easyconfigs' (build recipes, see https://docs.easybuild.io/terminology/#easyconfig_files) are available:</p> <pre><code>$ eb -S example-1.2\nCFGS1=/apps/gent/CO7/sandybridge/software/EasyBuild/3.6.2/lib/python2.7/site-packages/easybuild_easyconfigs-3.6.2-py2.7.egg/easybuild/easyconfigs\n * $CFGS1/e/example/example-1.2.1-foss-2025a.eb\n * $CFGS1/e/example/example-1.2.3-foss-2025b.eb\n * $CFGS1/e/example/example-1.2.5-intel-2025a.eb\n</code></pre> <p>For readily available easyconfigs, just specify the name of the easyconfig file to build and install the corresponding software package:</p> <pre><code>eb example-1.2.1-foss-2024a.eb --robot\n</code></pre>"}, {"location": "easybuild/#installing-variants-on-supported-software", "title": "Installing variants on supported software", "text": "<p>To install small variants on supported software, e.g., a different software version, or using a different compiler toolchain, use the corresponding <code>--try-X</code> options:</p> <p>To try to install <code>example v1.2.6</code>, based on the easyconfig file for <code>example v1.2.5</code>:</p> <pre><code>eb example-1.2.5-intel-2025a.eb --try-software-version=1.2.6\n</code></pre> <p>To try to install example v1.2.5 with a different compiler toolchain:</p> <pre><code>eb example-1.2.5-intel-2025a.eb --robot --try-toolchain=intel,2025b\n</code></pre>"}, {"location": "easybuild/#install-other-software", "title": "Install other software", "text": "<p>To install other, not yet supported, software, you will need to provide the required easyconfig files yourself. See https://docs.easybuild.io/writing-easyconfig-files/. for more information.</p>"}, {"location": "easybuild/#using-the-installed-modules", "title": "Using the installed modules", "text": "<p>To use the modules you installed with EasyBuild, extend <code>$MODULEPATH</code> to make them accessible for loading:</p> <pre><code>module use $EASYBUILD_INSTALLPATH/modules/all\n</code></pre> <p>It makes sense to put this <code>module use</code> command and all <code>export</code> commands in your <code>.bashrc</code> login script. That way, you don't have to type these commands every time you want to use EasyBuild or you want to load modules generated with EasyBuild. See also the section on <code>.bashrc</code> in the \"Beyond the basics\" chapter of the intro to Linux</p>"}, {"location": "fine_tuning_job_specifications/", "title": "Fine-tuning Job Specifications", "text": "<p>As UAntwerpen-HPC system administrators, we often observe that the UAntwerpen-HPC resources are not optimally (or wisely) used. For example, we regularly notice that several cores on a computing node are not utilised, due to the fact that one sequential program uses only one core on the node. Or users run I/O intensive applications on nodes with \"slow\" network connections.</p> <p>Users often tend to run their jobs without specifying specific PBS Job parameters. As such, their job will automatically use the default parameters, which are not necessarily (or rarely) the optimal ones. This can slow down the run time of your application, but also block UAntwerpen-HPC resources for other users.</p> <p>Specifying the \"optimal\" Job Parameters requires some knowledge of your application (e.g., how many parallel threads does my application use, is there a lot of inter-process communication, how much memory does my application need) and also some knowledge about the UAntwerpen-HPC infrastructure (e.g., what kind of multi-core processors are available, which nodes have InfiniBand).</p> <p>There are plenty of monitoring tools on Linux available to the user, which are useful to analyse your individual application. The UAntwerpen-HPC environment as a whole often requires different techniques, metrics and time goals, which are not discussed here. We will focus on tools that can help to optimise your Job Specifications.</p> <p>Determining the optimal computer resource specifications can be broken down into different parts. The first is actually determining which metrics are needed and then collecting that data from the hosts. Some of the most commonly tracked metrics are CPU usage, memory consumption, network bandwidth, and disk I/O stats. These provide different indications of how well a system is performing, and may indicate where there are potential problems or performance bottlenecks. Once the data have actually been acquired, the second task is analysing the data and adapting your PBS Job Specifications.</p> <p>Another different task is to monitor the behaviour of an application at run time and detect anomalies or unexpected behaviour. Linux provides a large number of utilities to monitor the performance of its components.</p> <p>This chapter shows you how to measure:</p> <ol> <li>Walltime</li> <li>Memory usage</li> <li>CPU usage</li> <li>Disk (storage) needs</li> <li>Network bottlenecks</li> </ol> <p>First, we allocate a compute node and move to our relevant directory:</p> <pre><code>qsub -I\ncd ~/examples/Fine-tuning-Job-Specifications\n</code></pre>"}, {"location": "fine_tuning_job_specifications/#specifying-walltime", "title": "Specifying Walltime", "text": "<p>One of the most important and also easiest parameters to measure is the duration of your program. This information is needed to specify the walltime.</p> <p>The time utility executes and times your application. You can just add the time command in front of your normal command line, including your command line options. After your executable has finished, time writes the total time elapsed, the time consumed by system overhead, and the time used to execute your executable to the standard error stream. The calculated times are reported in seconds.</p> <p>Test the time command:</p> <pre><code>$ time sleep 75\nreal 1m15.005s\nuser 0m0.001s\nsys 0m0.002s\n</code></pre> <p>It is a good practice to correctly estimate and specify the run time (duration) of an application. Of course, a margin of 10% to 20% can be taken to be on the safe side.</p> <p>It is also wise to check the walltime on different compute nodes or to select the \"slowest\" compute node for your walltime tests. Your estimate should be appropriate in case your application will run on the \"slowest\" (oldest) compute nodes.</p> <p>The walltime can be specified in a job scripts as:</p> <pre><code>#PBS -l walltime=3:00:00:00\n</code></pre> <p>or on the command line <pre><code>qsub -l walltime=3:00:00:00\n</code></pre></p> <p>It is recommended to always specify the walltime for a job.</p>"}, {"location": "fine_tuning_job_specifications/#specifying-memory-requirements", "title": "Specifying memory requirements", "text": "<p>In many situations, it is useful to monitor the amount of memory an application is using. You need this information to determine the characteristics of the required compute node, where that application should run on. Estimating the amount of memory an application will use during execution is often non-trivial, especially when one uses third-party software.</p> <p>The \"eat_mem\" application in the HPC examples directory just consumes and then releases memory, for the purpose of this test. It has one parameter, the amount of gigabytes of memory which needs to be allocated.</p> <p>First compile the program on your machine and then test it for 1 GB:</p> <pre><code>$ gcc -o eat_mem eat_mem.c\n$ ./eat_mem 1\nConsuming 1 gigabyte of memory.\n</code></pre>"}, {"location": "fine_tuning_job_specifications/#available-memory-on-the-machine", "title": "Available Memory on the machine", "text": "<p>The first point is to be aware of the available free memory in your computer. The \"free\" command displays the total amount of free and used physical and swap memory in the system, as well as the buffers used by the kernel. We also use the options \"-m\" to see the results expressed in Mega-Bytes and the \"-t\" option to get totals.</p> <pre><code>$ free -m -t\n                total   used   free  shared  buffers  cached\nMem:            16049   4772  11277       0      107     161\n-/+ buffers/cache:      4503  11546\nSwap:           16002   4185  11816\nTotal:          32052   8957  23094\n</code></pre> <p>Important is to note the total amount of memory available in the machine (i.e., 16 GB in this example) and the amount of used and free memory (i.e., 4.7 GB is used and another 11.2 GB is free here).</p> <p>It is not a good practice to use swap-space for your computational applications. A lot of \"swapping\" can increase the execution time of your application tremendously.</p>"}, {"location": "fine_tuning_job_specifications/#checking-the-memory-consumption", "title": "Checking the memory consumption", "text": "<p>The \"Monitor\" tool monitors applications in terms of memory and CPU usage, as well as the size of temporary files. Note that currently only single node jobs are supported, MPI support may be added in a future release.</p> <p>To start using monitor, first load the appropriate module. Then we study the \"eat_mem.c\" program and compile it:</p> <pre><code>$ module load monitor\n$ cat eat_mem.c\n$ gcc -o eat_mem eat_mem.c\n</code></pre> <p>Starting a program to monitor is very straightforward; you just add the \"monitor\" command before the regular command line.</p> <pre><code>$ monitor ./eat_mem 3\ntime (s) size (kb) %mem %cpu\nConsuming 3 gigabyte of memory.\n5  252900 1.4 0.6\n10  498592 2.9 0.3\n15  743256 4.4 0.3\n20  988948 5.9 0.3\n25  1233612 7.4 0.3\n30  1479304 8.9 0.2\n35  1723968 10.4 0.2\n40  1969660 11.9 0.2\n45  2214324 13.4 0.2\n50  2460016 14.9 0.2\n55  2704680 16.4 0.2\n60  2950372 17.9 0.2\n65  3167280 19.2 0.2\n70  3167280 19.2 0.2\n75  9264  0 0.5\n80  9264  0 0.4\n</code></pre> <p>Whereby:</p> <ol> <li>The first column shows you the elapsed time in seconds. By default,     all values will be displayed every 5\u00a0seconds.</li> <li>The second column shows you the used memory in kb. We note that the     memory slowly increases up to just over 3\u00a0GB (3GB is 3,145,728\u00a0KB),     and is released again.</li> <li>The third column shows the memory utilisation, expressed in     percentages of the full available memory. At full memory     consumption, 19.2% of the memory was being used by our application.     With the <code>free</code> command, we have previously seen that we had a     node of 16\u00a0GB in this example. 3\u00a0GB is indeed more or less 19.2% of     the full available memory.</li> <li>The fourth column shows you the CPU utilisation, expressed in     percentages of a full CPU load. As there are no computations done in     our exercise, the value remains very low (i.e.\u00a00.2%).</li> </ol> <p>Monitor will write the CPU usage and memory consumption of simulation to standard error.</p> <p>This is the rate at which monitor samples the program's metrics. Since monitor's output may interfere with that of the program to monitor, it is often convenient to use a\u00a0log file. The latter can be specified as follows:</p> <pre><code>$ monitor -l test1.log eat_mem 2\nConsuming 2 gigabyte of memory.\n$ cat test1.log\n</code></pre> <p>For long-running programs, it may be convenient to limit the output to, e.g., the last minute of the programs' execution. Since monitor provides metrics every 5 seconds, this implies we want to limit the output to the last 12 values to cover a minute:</p> <pre><code>$ monitor -l test2.log -n 12 eat_mem 4\nConsuming 4 gigabyte of memory.\n</code></pre> <p>Note that this option is only available when monitor writes its metrics to a\u00a0log file, not when standard error is used.</p> <p>The interval at\u00a0which monitor will show the metrics can be modified by specifying delta, the sample rate:</p> <pre><code>$ monitor -d 1 ./eat_mem\nConsuming 3 gigabyte of memory.\n</code></pre> <p>Monitor will now print the program's metrics every second. Note that the\u00a0minimum delta value is 1\u00a0second.</p> <p>Alternative options to monitor the memory consumption are the \"top\" or the \"htop\" command.</p> top <p>provides an ongoing look at processor activity in real time. It displays a listing of the most CPU-intensive tasks on the system, and can provide an interactive interface for manipulating processes. It can sort the tasks by memory usage, CPU usage and run time.</p> htop <p>is similar to top, but shows the CPU-utilisation for all the CPUs in the machine and allows to scroll the list vertically and horizontally to see all processes and their full command lines.</p>"}, {"location": "fine_tuning_job_specifications/#pbs_mem", "title": "Setting the memory parameter", "text": "<p>Once you gathered a good idea of the overall memory consumption of your application, you can define it in your job script. It is wise to foresee a margin of about 10%.</p> <p>Sequential or single-node applications:</p> <p>The maximum amount of physical memory used by the job can be specified in a job script as:</p> <pre><code>#PBS -l mem=4gb\n</code></pre> <p>or on the command line</p> <pre><code>qsub -l mem=4gb\n</code></pre> <p>This setting is ignored if the number of nodes is not\u00a01.</p> <p>Parallel or multi-node applications:</p> <p>When you are running a parallel application over multiple cores, you can also specify the memory requirements per processor (pmem). This directive specifies the maximum amount of physical memory used by any process in the job.</p> <p>For example, if the job would run four processes and each would use up to 2 GB (gigabytes) of memory, then the memory directive would read:</p> <pre><code>#PBS -l pmem=2gb\n</code></pre> <p>or on the command line</p> <pre><code>$ qsub -l pmem=2gb\n</code></pre> <p>(and of course this would need to be combined with a CPU cores directive such as nodes=1:ppn=4). In this example, you request 8\u00a0GB of memory in total on the node.</p>"}, {"location": "fine_tuning_job_specifications/#specifying-processors-requirements", "title": "Specifying processors requirements", "text": "<p>Users are encouraged to fully utilise all the available cores on a certain compute node. Once the required numbers of cores and nodes are decently specified, it is also good practice to monitor the CPU utilisation on these cores and to make sure that all the assigned nodes are working at full load.</p>"}, {"location": "fine_tuning_job_specifications/#number-of-processors", "title": "Number of processors", "text": "<p>The number of core and nodes that a user shall request fully depends on the architecture of the application. Developers design their applications with a strategy for parallelization in mind. The application can be designed for a certain fixed number or for a configurable number of nodes and cores. It is wise to target a specific set of compute nodes (e.g., Westmere, Harpertown) for your computing work and then to configure your software to nicely fill up all processors on these compute nodes.</p> <p>The /proc/cpuinfo stores info about your CPU architecture like number of CPUs, threads, cores, information about CPU caches, CPU family, model and much more. So, if you want to detect how many cores are available on a specific machine:</p> <pre><code>$ less /proc/cpuinfo\nprocessor       : 0\nvendor_id       : GenuineIntel\ncpu family      : 6\nmodel           : 23\nmodel name      : Intel(R) Xeon(R) CPU  E5420  @ 2.50GHz\nstepping        : 10\ncpu MHz         : 2500.088\ncache size      : 6144 KB\n...\n</code></pre> <p>Or if you want to see it in a more readable format, execute:</p> <pre><code>$ grep processor /proc/cpuinfo\nprocessor : 0\nprocessor : 1\nprocessor : 2\nprocessor : 3\nprocessor : 4\nprocessor : 5\nprocessor : 6\nprocessor : 7\n</code></pre> <p>Note</p> <p>Unless you want information of the login nodes, you'll have to issue these commands on one of the workernodes. This is most easily achieved in an interactive job, see the chapter on Running interactive jobs.</p> <p>In order to specify the number of nodes and the number of processors per node in your job script, use:</p> <pre><code>#PBS -l nodes=N:ppn=M\n</code></pre> <p>or with equivalent parameters on the command line</p> <pre><code>qsub -l nodes=N:ppn=M\n</code></pre> <p>This specifies the number of nodes (nodes=N) and the number of processors per node (ppn=M) that the job should use. PBS treats a processor core as a processor, so a system with eight cores per compute node can have ppn=8 as its maximum ppn request.</p> <p>Note that unless a job has some inherent parallelism of its own through something like MPI or OpenMP, requesting more than a single processor on a single node is usually wasteful and can impact the job start time.</p>"}, {"location": "fine_tuning_job_specifications/#monitoring-the-cpu-utilisation", "title": "Monitoring the CPU-utilisation", "text": "<p>The previously used \"monitor\" tool also shows the overall CPU-load. The \"eat_cpu\" program performs a multiplication of 2 randomly filled a (1500 \\times 1500) matrices and is just written to consume a lot of \"cpu\".</p> <p>We first load the monitor modules, study the \"eat_cpu.c\" program and compile it:</p> <pre><code>$ module load monitor\n$ cat eat_cpu.c\n$ gcc -o eat_cpu eat_cpu.c\n</code></pre> <p>And then start to monitor the eat_cpu program:</p> <pre><code>$ monitor -d 1 ./eat_cpu\ntime  (s) size (kb) %mem %cpu\n1  52852  0.3 100\n2  52852  0.3 100\n3  52852  0.3 100\n4  52852  0.3 100\n5  52852  0.3  99\n6  52852  0.3 100\n7  52852  0.3 100\n8  52852  0.3 100\n</code></pre> <p>We notice that it the program keeps its CPU nicely busy at 100%.</p> <p>Some processes spawn one or more sub-processes. In that case, the metrics shown by monitor are aggregated over the process and all of its sub-processes (recursively). The reported CPU usage is the sum of all these processes, and can thus exceed 100%.</p> <p>Some (well, since this is a UAntwerpen-HPC Cluster, we hope most) programs use more than one core to perform their computations. Hence, it should not come as a surprise that the CPU usage is reported as larger than 100%. When programs of this type are running on a computer with n cores, the CPU usage can go up to (\\text{n} \\times 100\\%).</p> <p>This could also be monitored with the htop command:</p> <p><pre><code>htop\n</code></pre> Example output: <pre><code>  1  [|||   11.0%]   5  [||     3.0%]     9  [||     3.0%]   13 [       0.0%]\n  2  [|||||100.0%]   6  [       0.0%]     10 [       0.0%]   14 [       0.0%]\n  3  [||     4.9%]   7  [||     9.1%]     11 [       0.0%]   15 [       0.0%]\n  4  [||     1.8%]   8  [       0.0%]     12 [       0.0%]   16 [       0.0%]\n  Mem[|||||||||||||||||59211/64512MB]     Tasks: 323, 932 thr; 2 running\n  Swp[||||||||||||      7943/20479MB]     Load average: 1.48 1.46 1.27\n                                          Uptime: 211 days(!), 22:12:58\n\n  PID USER      PRI  NI  VIRT   RES   SHR S CPU% MEM%   TIME+  Command\n22350 vsc00000   20   0 1729M 1071M   704 R 98.0  1.7 27:15.59 bwa index\n 7703 root        0 -20 10.1G 1289M 70156 S 11.0  2.0 36h10:11 /usr/lpp/mmfs/bin\n27905 vsc00000   20   0  123M  2800  1556 R  7.0  0.0  0:17.51 htop\n</code></pre></p> <p>The advantage of htop is that it shows you the cpu utilisation for all processors as well as the details per application. A nice exercise is to start 4 instances of the \"cpu_eat\" program in 4 different terminals, and inspect the cpu utilisation per processor with monitor and htop.</p> <p>If htop reports that your program is taking 75% CPU on a certain processor, it means that 75% of the samples taken by top found your process active on the CPU. The rest of the time your application was in a wait. (It is important to remember that a CPU is a discrete state machine. It really can be at only 100%, executing an instruction, or at 0%, waiting for something to do. There is no such thing as using 45% of a CPU. The CPU percentage is a function of time.) However, it is likely that your application's rest periods include waiting to be dispatched on a CPU and not on external devices. That part of the wait percentage is then very relevant to understanding your overall CPU usage pattern.</p>"}, {"location": "fine_tuning_job_specifications/#fine-tuning-your-executable-andor-job-script", "title": "Fine-tuning your executable and/or job script", "text": "<p>It is good practice to perform a number of run time stress tests, and to check the CPU utilisation of your nodes. We (and all other users of the UAntwerpen-HPC) would appreciate that you use the maximum of the CPU resources that are assigned to you and make sure that there are no CPUs in your node who are not utilised without reasons.</p> <p>But how can you maximise?</p> <ol> <li>Configure your software. (e.g., to exactly use the available amount     of processors in a node)</li> <li>Develop your parallel program in a smart way.</li> <li>Demand a specific type of compute node (e.g., Harpertown, Westmere),     which have a specific number of cores.</li> <li>Correct your request for CPUs in your job script.</li> </ol>"}, {"location": "fine_tuning_job_specifications/#the-system-load", "title": "The system load", "text": "<p>On top of the CPU utilisation, it is also important to check the system load. The system load is a measure of the amount of computational work that a computer system performs.</p> <p>The system load is the number of applications running or waiting to run on the compute node. In a system with for example four CPUs, a load average of 3.61 would indicate that there were, on average, 3.61 processes ready to run, and each one could be scheduled into a CPU.</p> <p>The load averages differ from CPU percentage in two significant ways:</p> <ol> <li>\"load averages\" measure the trend of processes waiting to be run     (and not only an instantaneous snapshot, as does CPU percentage);     and</li> <li>\"load averages\" include all demand for all resources, e.g., CPU     and also I/O and network (and not only how much was active at the     time of measurement).</li> </ol>"}, {"location": "fine_tuning_job_specifications/#optimal-load", "title": "Optimal load", "text": "<p>What is the \"optimal load\" rule of thumb?</p> <p>The load averages tell us whether our physical CPUs are over- or under-utilised. The point of perfect utilisation, meaning that the CPUs are always busy and, yet, no process ever waits for one, is the average matching the number of CPUs. Your load should not exceed the number of cores available. E.g., if there are four CPUs on a machine and the reported one-minute load average is 4.00, the machine has been utilising its processors perfectly for the last 60 seconds. The \"100% utilisation\" mark is 1.0 on a single-core system, 2.0 on a dual-core, 4.0 on a quad-core, etc. The optimal load shall be between 0.7 and 1.0 per processor.</p> <p>In general, the intuitive idea of load averages is the higher they rise above the number of processors, the more processes are waiting and doing nothing, and the lower they fall below the number of processors, the more untapped CPU capacity there is.</p> <p>Load averages do include any processes or threads waiting on I/O, networking, databases or anything else not demanding the CPU. This means that the optimal number of applications running on a system at the same time, might be more than one per processor.</p> <p>The \"optimal number of applications\" running on one machine at the same time depends on the type of the applications that you are running.</p> <ol> <li>When you are running computational intensive applications, one application per processor will generate     the optimal load.</li> <li>For I/O intensive applications (e.g., applications which perform a lot of disk-I/O), a higher     number of applications can generate the optimal load. While some     applications are reading or writing data on disks, the processors     can serve other applications.</li> </ol> <p>The optimal number of applications on a machine could be empirically calculated by performing a number of stress tests, whilst checking the highest throughput. There is however no manner in the UAntwerpen-HPC at the moment to specify the maximum number of applications that shall run per core dynamically. The UAntwerpen-HPC scheduler will not launch more than one process per core.</p> <p>The manner how the cores are spread out over CPUs does not matter for what regards the load. Two quad-cores perform similar to four dual-cores, and again perform similar to eight single-cores. It's all eight cores for these purposes.</p>"}, {"location": "fine_tuning_job_specifications/#monitoring-the-load", "title": "Monitoring the load", "text": "<p>The load average represents the average system load over a period of time. It conventionally appears in the form of three numbers, which represent the system load during the last one-, five-, and fifteen-minute periods.</p> <p>The uptime command will show us the average load</p> <pre><code>$ uptime\n10:14:05 up 86 days, 12:01, 11 users, load average: 0.60, 0.41, 0.41\n</code></pre> <p>Now, compile and start a few instances of the \"eat_cpu\" program in the background, and check the effect on the load again:</p> <p><pre><code>$ gcc -O2 eat_cpu.c -o eat_cpu\n$ ./eat_cpu&amp;\n$ ./eat_cpu&amp;\n$ ./eat_cpu&amp;\n$ uptime\n10:14:42 up 86 days, 12:02, 11 users, load average: 2.60, 0.93, 0.58\n</code></pre> You can also read it in the htop command.</p>"}, {"location": "fine_tuning_job_specifications/#fine-tuning-your-executable-andor-job-script_1", "title": "Fine-tuning your executable and/or job script", "text": "<p>It is good practice to perform a number of run time stress tests, and to check the system load of your nodes. We (and all other users of the UAntwerpen-HPC) would appreciate that you use the maximum of the CPU resources that are assigned to you and make sure that there are no CPUs in your node who are not utilised without reasons.</p> <p>But how can you maximise?</p> <ol> <li>Profile your software to improve its performance.</li> <li>Configure your software (e.g., to exactly use the available amount     of processors in a node).</li> <li>Develop your parallel program in a smart way, so that it fully     utilises the available processors.</li> <li>Demand a specific type of compute node (e.g., Harpertown, Westmere),     which have a specific number of cores.</li> <li>Correct your request for CPUs in your job script.</li> </ol> <p>And then check again.</p>"}, {"location": "fine_tuning_job_specifications/#checking-file-sizes-disk-io", "title": "Checking File sizes &amp; Disk I/O", "text": ""}, {"location": "fine_tuning_job_specifications/#monitoring-file-sizes-during-execution", "title": "Monitoring File sizes during execution", "text": "<p>Some programs generate intermediate or output files, the size of which may also be a useful metric.</p> <p>Remember that your available disk space on the UAntwerpen-HPC online storage is limited, and that you have environment variables which point to these directories available (i.e., $VSC_DATA, $VSC_SCRATCH and $VSC_DATA). On top of those, you can also access some temporary storage (i.e., the /tmp directory) on the compute node, which is defined by the $VSC_SCRATCH_NODE environment variable.</p> <p>We first load the monitor modules, study the \"eat_disk.c\" program and compile it:</p> <pre><code>$ module load monitor\n$ cat eat_disk.c\n$ gcc -o eat_disk eat_disk.c\n</code></pre> <p>The monitor tool provides an option (-f) to display the size of one or more files:</p> <pre><code>$ monitor -f $VSC_SCRATCH/test.txt ./eat_disk\ntime (s) size (kb) %mem %cpu\n5  1276  0 38.6 168820736\n10  1276  0 24.8 238026752\n15  1276  0 22.8 318767104\n20  1276  0 25 456130560\n25  1276  0 26.9 614465536\n30  1276  0 27.7 760217600\n...\n</code></pre> <p>Here, the size of the file \"test.txt\" in directory $VSC_SCRATCH will be monitored. Files can be specified by absolute as well as relative path, and multiple files are separated by \",\".</p> <p>It is important to be aware of the sizes of the file that will be generated, as the available disk space for each user is limited. We refer to section  How much disk space do I get? on Quotas to check your quota and tools to find which files consumed the \"quota\".</p> <p>Several actions can be taken, to avoid storage problems:</p> <ol> <li>Be aware of all the files that are generated by your program. Also     check out the hidden files.</li> <li>Check your quota consumption regularly.</li> <li>Clean up your files regularly.</li> <li>First work (i.e., read and write) with your big files in the local     /tmp directory. Once finished, you can move your files once to the     VSC_DATA directories.</li> <li>Make sure your programs clean up their temporary files after     execution.</li> <li>Move your output results to your own computer regularly.</li> <li>Anyone can request more disk space to the UAntwerpen-HPC staff, but you will have     to duly justify your request.</li> </ol>"}, {"location": "fine_tuning_job_specifications/#specifying-network-requirements", "title": "Specifying network requirements", "text": "<p>Users can examine their network activities with the htop command. When your processors are 100% busy, but you see a lot of red bars and only limited green bars in the htop screen, it is mostly an indication that they lose a lot of time with inter-process communication.</p> <p>Whenever your application utilises a lot of inter-process communication (as is the case in most parallel programs), we strongly recommend to request nodes with an \"InfiniBand\" network. The InfiniBand is a specialised high bandwidth, low latency network that enables large parallel jobs to run as efficiently as possible.</p> <p>The parameter to add in your job script would be:</p> <pre><code>#PBS -l ib\n</code></pre> <p>If for some other reasons, a user is fine with the gigabit Ethernet network, he can specify:</p> <pre><code>#PBS -l gbe\n</code></pre>"}, {"location": "fine_tuning_job_specifications/#some-more-tips-on-the-monitor-tool", "title": "Some more tips on the Monitor tool", "text": ""}, {"location": "fine_tuning_job_specifications/#command-lines-arguments", "title": "Command Lines arguments", "text": "<p>Many programs, e.g., MATLAB, take command line options. To make sure these do not interfere with those of monitor and vice versa, the program can for instance be started in the following way:</p> <pre><code>$ monitor -delta 60 -- matlab -nojvm -nodisplay computation.m\n</code></pre> <p>The use of <code>--</code> will ensure that monitor does not get confused by MATLAB's <code>-nojvm</code> and <code>-nodisplay</code> options.</p>"}, {"location": "fine_tuning_job_specifications/#exit-code", "title": "Exit Code", "text": "<p>Monitor will propagate the exit code of the program it is watching. Suppose the latter ends normally, then monitor's exit code will be 0. On the other hand, when the program terminates abnormally with a non-zero exit code, e.g., 3, then this will be monitor's exit code as well.</p> <p>When monitor terminates in an abnormal state, for instance if it can't create the log file, its exit code will be 65. If this interferes with an exit code of the program to be monitored, it can be modified by setting the environment variable MONITOR_EXIT_ERROR to a more suitable value.</p>"}, {"location": "fine_tuning_job_specifications/#monitoring-a-running-process", "title": "Monitoring a running process", "text": "<p>It is also possible to \"attach\" monitor to a program or process that is already running. One simply determines the relevant process ID using the ps command, e.g., 18749, and starts monitor:</p> <pre><code>$ monitor -p 18749\n</code></pre> <p>Note that this feature can be (ab)used to monitor specific sub-processes.</p>"}, {"location": "getting_started/", "title": "Getting Started", "text": "<p>Welcome to the \"Getting Started\" guide. This chapter will lead you through the initial steps of logging into the UAntwerpen-HPC and submitting your very first job. We'll also walk you through the process step by step using a practical example.</p> <p>In addition to this chapter, you might find the recording of the Introduction to HPC-UGent training session to be a useful resource.</p> <p>Before proceeding, read the introduction to HPC to gain an understanding of the UAntwerpen-HPC and related terminology.</p>"}, {"location": "getting_started/#getting-access", "title": "Getting Access", "text": "<p>To get access to the UAntwerpen-HPC, visit Getting an HPC Account.</p> <p>If you have not used Linux before, please learn some basics first before continuing. (see Appendix C - Useful Linux Commands)</p>"}, {"location": "getting_started/#a-typical-workflow-looks-like-this", "title": "A typical workflow looks like this:", "text": "<ol> <li>Connect to the login nodes </li> <li>Transfer your files to the UAntwerpen-HPC</li> <li>Optional: compile your code and test it </li> <li>Create a job script and submit your job</li> <li>Wait for job to be executed</li> <li>Study the results generated by your jobs, either on the cluster or     after downloading them locally.</li> </ol> <p>We will walk through an illustrative workload to get you started. In this example, our objective is to train a deep learning model for recognizing hand-written digits (MNIST dataset) using TensorFlow; see the example scripts.</p>"}, {"location": "getting_started/#getting-connected", "title": "Getting Connected", "text": "<p>There are two options to connect</p> <ul> <li>Using a terminal to connect via SSH (for power users) (see First Time connection to the UAntwerpen-HPC)</li> <li>Using the web portal</li> </ul> <p>Considering your operating system is Linux, it is recommended to make use of the <code>ssh</code> command in a terminal to get the most flexibility. </p> <p>Assuming you have already generated SSH keys in the previous step (Getting Access), and that they are in a default location, you should now be able to login by running the following command:</p> <pre><code>ssh vsc20167@login.hpc.uantwerpen.be\n</code></pre> <p>User your own VSC account id</p> <p>Replace vsc20167 with your VSC account id (see https://account.vscentrum.be)</p> <p>Tip</p> <p>You can also still use the web portal (see shell access on web portal)</p> <p>Info</p> <p>When having problems see the connection issues section on the troubleshooting page.</p>"}, {"location": "getting_started/#transfer-your-files", "title": "Transfer your files", "text": "<p>Now that you can login, it is time to transfer files from your local computer to your home directory on the UAntwerpen-HPC.</p> <p>Download tensorflow_mnist.py  and run.sh example scripts to your computer (from here).</p> <p>On your local machine you can run: <pre><code>curl -OL https://raw.githubusercontent.com/hpcugent/vsc_user_docs/main/mkdocs/docs/HPC/examples/Getting_Started/tensorflow_mnist/tensorflow_mnist.py\ncurl -OL https://raw.githubusercontent.com/hpcugent/vsc_user_docs/main/mkdocs/docs/HPC/examples/Getting_Started/tensorflow_mnist/run.sh\n</code></pre></p> <p>Using the <code>scp</code> command, the files can be copied from your local host to your home directory (<code>~</code>) on the remote host (HPC). <pre><code>scp tensorflow_mnist.py run.sh vsc20167login.hpc.uantwerpen.be:~\n</code></pre></p> <pre><code>ssh  vsc20167@login.hpc.uantwerpen.be\n</code></pre> <p>User your own VSC account id</p> <p>Replace vsc20167 with your VSC account id (see https://account.vscentrum.be)</p> <p>Info</p> <p>For more information about transfering files or <code>scp</code>, see tranfer files from/to hpc.</p> <p>When running <code>ls</code> in your session on the UAntwerpen-HPC, you should see the two files listed in your home directory (<code>~</code>):</p> <pre><code>$ ls ~\nrun.sh tensorflow_mnist.py\n</code></pre> <p>When you do not see these files, make sure you uploaded the files to your home directory.</p>"}, {"location": "getting_started/#submitting-a-job", "title": "Submitting a job", "text": "<p>Jobs are submitted and executed using job scripts. In our case run.sh can be used as a (very minimal) job script.</p> <p>A job script is a shell script, a text file that specifies the resources,  the software that is used (via <code>module load</code> statements),  and the steps that should be executed to run the calculation.</p> <p>Our job script looks like this:</p> <p>run.sh<pre><code>#!/bin/bash\n\nmodule load TensorFlow/2.15.1-foss-2023a\n\npython tensorflow_mnist.py\n</code></pre> As you can see this job script will run the Python script named tensorflow_mnist.py.</p> <p>The jobs you submit are per default executed on cluser/{{ defaultcluster }}, you can swap to another cluster by issuing the following command.</p> <pre><code>module swap cluster/{{ othercluster }}\n</code></pre> <p>Tip</p> <p>When submitting jobs with limited amount of resources, it is recommended to use the debug/interactive cluster: <code>donphan</code>.</p> <p>This job script can now be submitted to the cluster's job system for execution, using the qsub (queue submit) command:</p> <pre><code>$ qsub run.sh\n433253.leibniz\n</code></pre> <p>This command returns a job identifier (433253.leibniz) on the HPC cluster. This is a unique identifier for the job which can be used to monitor and manage your job.</p> <p>Make sure you understand what the <code>module</code> command does</p> <p>Note that the module commands only modify environment variables. For instance, running <code>module swap cluster/{{ othercluster }}</code> will update your shell environment so that <code>qsub</code> submits a job to the <code>{{ othercluster }}</code> cluster,  but our active shell session is still running on the login node.</p> <p>It is important to understand that while <code>module</code> commands affect your session environment, they do not change where the commands your are running are being executed: they will still be run on the login node you are on.</p> <p>When you submit a job script however, the commands in the job script will be run on a workernode of the cluster the job was submitted to (like <code>{{ othercluster }}</code>).</p> <p>For detailed information about <code>module</code> commands, read the running batch jobs chapter.</p>"}, {"location": "getting_started/#wait-for-job-to-be-executed", "title": "Wait for job to be executed", "text": "<p>Your job is put into a queue before being executed, so it may take a while before it actually starts. (see when will my job start? for scheduling policy).</p> <p>You can get an overview of the active jobs using the <code>qstat</code> command: <pre><code>$ qstat\nJob ID     Name             User            Time Use S Queue\n---------- ---------------- --------------- -------- - -------\n433253.leibniz     run.sh           vsc20167        0:00:00  Q {{ othercluster }}\n</code></pre></p> <p>Eventually, after entering <code>qstat</code> again you should see that your job has started running: <pre><code>$ qstat\nJob ID     Name             User            Time Use S Queue\n---------- ---------------- --------------- -------- - -------\n433253.leibniz     run.sh           vsc20167        0:00:01  R {{ othercluster }}\n</code></pre></p> <p>If you don't see your job in the output of the <code>qstat</code> command anymore, your job has likely completed.</p> <p>Read this section on how to interpret the output.</p>"}, {"location": "getting_started/#inspect-your-results", "title": "Inspect your results", "text": "<p>When your job finishes it generates 2 output files:</p> <ul> <li>One for normal output messages (stdout output channel).</li> <li>One for warning and error messages (stderr output channel).</li> </ul> <p>By default located in the directory where you issued <code>qsub</code>.</p> <p>In our example when running <code>ls</code> in the current directory you should see 2 new files:</p> <ul> <li>run.sh.o433253.leibniz, containing normal output messages produced by job 433253.leibniz;</li> <li>run.sh.e433253.leibniz, containing errors and warnings produced by job 433253.leibniz.</li> </ul> <p>Info</p> <p>run.sh.e433253.leibniz should be empty (no errors or warnings).</p> <p>Use your own job ID</p> <p>Replace 433253.leibniz with the jobid you got from the <code>qstat</code> command (see above) or simply look for added files in your current directory by running <code>ls</code>.</p> <p>When examining the contents of <code>run.sh.o433253.leibniz</code> you will see something like this: <pre><code>Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/mnist.npz\n11493376/11490434 [==============================] - 1s 0us/step\nEpoch 1/5\n1875/1875 [==============================] - 2s 823us/step - loss: 0.2960 - accuracy: 0.9133\nEpoch 2/5\n1875/1875 [==============================] - 1s 771us/step - loss: 0.1427 - accuracy: 0.9571\nEpoch 3/5\n1875/1875 [==============================] - 1s 767us/step - loss: 0.1070 - accuracy: 0.9675\nEpoch 4/5\n1875/1875 [==============================] - 1s 764us/step - loss: 0.0881 - accuracy: 0.9727\nEpoch 5/5\n1875/1875 [==============================] - 1s 764us/step - loss: 0.0741 - accuracy: 0.9768\n313/313 - 0s - loss: 0.0782 - accuracy: 0.9764\n</code></pre></p> <p>Hurray \ud83c\udf89, we trained a deep learning model and achieved 97,64 percent accuracy.</p> <p>Warning</p> <p>When using TensorFlow specifically, you should actually submit jobs to a GPU cluster for better performance, see GPU clusters.</p> <p>For the purpose of this example, we are running a very small TensorFlow workload on a CPU-only cluster.</p>"}, {"location": "getting_started/#next-steps", "title": "Next steps", "text": "<ul> <li>Running interactive jobs</li> <li>Running jobs with input/output data</li> <li>Multi core jobs/Parallel Computing</li> <li>Interactive and debug cluster</li> </ul> <p>For more examples see Program examples and Job script examples</p>"}, {"location": "gpu/", "title": "GPU clusters", "text": ""}, {"location": "gpu/#submitting-jobs", "title": "Submitting jobs", "text": "<p>To submit jobs to the <code>joltik</code> GPU cluster, where each node provides 4 NVIDIA V100 GPUs (each with 32GB of GPU memory), use:</p> <pre><code>module swap cluster/joltik\n</code></pre> <p>To submit to the <code>accelgor</code> GPU cluster, where each node provides 4 NVIDIA A100 GPUs (each with 80GB GPU memory), use:</p> <pre><code>module swap cluster/accelgor\n</code></pre> <p>Then use the familiar <code>qsub</code>, <code>qstat</code>, etc.\u00a0commands, taking into account the guidelines outlined in section Requesting (GPU) resources.</p>"}, {"location": "gpu/#interactive-jobs", "title": "Interactive jobs", "text": "<p>To interactively experiment with GPUs, you can submit an interactive job using <code>qsub -I</code> (and request one or more GPUs, see section\u00a0Requesting (GPU) resources).</p> <p>Note that due to a bug in Slurm you will currently not be able to be able to interactively use MPI software that requires access to the GPUs. If you need this, please contact use via hpc@uantwerpen.be.</p>"}, {"location": "gpu/#hardware", "title": "Hardware", "text": "<p>See https://www.ugent.be/hpc/en/infrastructure.</p>"}, {"location": "gpu/#requesting-gpu-resources", "title": "Requesting (GPU) resources", "text": "<p>There are 2 main ways to ask for GPUs as part of a job:</p> <ul> <li> <p>Either as a node property (similar to the number of cores per node     specified via <code>ppn</code>) using <code>-l nodes=X:ppn=Y:gpus=Z</code> (where the     <code>ppn=Y</code> is optional), or as a separate resource request (similar to     the amount of memory) via <code>-l gpus=Z</code>. Both notations give exactly     the same result. The <code>-l gpus=Z</code> is convenient if you only need one     node and you are fine with the default number of cores per GPU. The     <code>-l nodes=...:gpus=Z</code> notation is required if you want to run with     full control or in multinode cases like MPI jobs. If you do not     specify the number of GPUs by just using <code>-l gpus</code>, you get by     default 1 GPU.</p> </li> <li> <p>As a resource of its own, via <code>--gpus X</code>. In this case however, you     are not guaranteed that the GPUs are on the same node, so your     script or code must be able to deal with this.</p> </li> </ul> <p>Some background:</p> <ul> <li> <p>The GPUs are constrained to the jobs (like the CPU cores), but do     not run in so-called \"exclusive\" mode.</p> </li> <li> <p>The GPUs run with the so-called \"persistence daemon\", so the GPUs is     not re-initialised between jobs.</p> </li> </ul>"}, {"location": "gpu/#attention-points", "title": "Attention points", "text": "<p>Some important attention points:</p> <ul> <li> <p>For MPI jobs, we recommend the (new) wrapper <code>mypmirun</code> from the     <code>vsc-mympirun</code> module (<code>pmi</code> is the background mechanism to start     the MPI tasks, and is different from the usual <code>mpirun</code> that is used     by the <code>mympirun</code> wrapper). At some later point, we might promote     the <code>mypmirun</code> tool or rename it, to avoid the confusion in the     naming.</p> </li> <li> <p>Sharing GPUs requires MPS. The Slurm built-in MPS does not really do     want you want, so we will provide integration with <code>mypmirun</code> and     <code>wurker</code>.</p> </li> <li> <p>For parallel work, we are working on a <code>wurker</code> wrapper from the     <code>vsc-mympirun</code> module that supports GPU placement and MPS, without     any limitations wrt the requested resources (i.e. also support the     case where GPUs are spread heterogeneous over nodes from using the     <code>--gpus Z</code> option).</p> </li> <li> <p>Both <code>mypmirun</code> and <code>wurker</code> will try to do the most optimised     placement of cores and tasks, and will provide 1 (optimal) GPU per     task/MPI rank, and set one so-called visible device (i.e.     <code>CUDA_VISIBLE_DEVICES</code> only has 1 ID). The actual devices are not     constrained to the ranks, so you can access all devices requested in     the job. We know that at this moment, this is not working properly, but we are working on this. We advise against trying to fix this yourself.</p> </li> </ul>"}, {"location": "gpu/#software-with-gpu-support", "title": "Software with GPU support", "text": "<p>Use <code>module avail</code> to check for centrally installed software.</p> <p>The subsections below only cover a couple of installed software packages, more are available.</p>"}, {"location": "gpu/#gromacs", "title": "GROMACS", "text": "<p>Please consult <code>module avail GROMACS</code> for a list of installed versions.</p>"}, {"location": "gpu/#horovod", "title": "Horovod", "text": "<p>Horovod can be used for (multi-node) multi-GPU TensorFlow/PyTorch calculations.</p> <p>Please consult <code>module avail Horovod</code> for a list of installed versions.</p> <p>Horovod supports TensorFlow, Keras, PyTorch and MxNet (see https://github.com/horovod/horovod#id9), but should be run as an MPI application with <code>mypmirun</code>. (Horovod also provides its own wrapper <code>horovodrun</code>, not sure if it handles placement and others correctly).</p> <p>At least for simple TensorFlow benchmarks, it looks like Horovod is a bit faster than usual autodetect multi-GPU TensorFlow without horovod, but it comes at the cost of the code modifications to use horovod.</p>"}, {"location": "gpu/#pytorch", "title": "PyTorch", "text": "<p>Please consult <code>module avail PyTorch</code> for a list of installed versions.</p>"}, {"location": "gpu/#tensorflow", "title": "TensorFlow", "text": "<p>Please consult <code>module avail TensorFlow</code> for a list of installed versions.</p> <p>Note: for running TensorFlow calculations on multiple GPUs and/or on more than one workernode, use <code>Horovod</code>, see section Horovod.</p>"}, {"location": "gpu/#example-tensorflow-job-script", "title": "Example TensorFlow job script", "text": "TensorFlow_GPU.sh<pre><code>#!/bin/bash\n#PBS -l walltime=5:0:0\n#PBS -l nodes=1:ppn=quarter:gpus=1\n\nmodule load TensorFlow/2.6.0-foss-2021a-CUDA-11.3.1\n\ncd $PBS_O_WORKDIR\npython example.py\n</code></pre>"}, {"location": "gpu/#alphafold", "title": "AlphaFold", "text": "<p>Please consult <code>module avail AlphaFold</code> for a list of installed versions.</p> <p>For more information on using AlphaFold, we strongly recommend the VIB-UGent course available at https://elearning.bits.vib.be/courses/alphafold.</p>"}, {"location": "gpu/#getting-help", "title": "Getting help", "text": "<p>In case of questions or problems, please contact the UAntwerpen-HPC via hpc@uantwerpen.be, and clearly indicate that your question relates to the <code>joltik</code> cluster by adding <code>[joltik]</code> in the email subject.</p>"}, {"location": "infrastructure/", "title": "Infrastructure", "text": ""}, {"location": "infrastructure/#tier2-clusters-of-ghent-university", "title": "Tier2 clusters of Ghent University", "text": "<p>The Stevin computing infrastructure consists of several Tier2 clusters which are hosted in the S10 datacenter of Ghent University.</p> <p>This infrastructure is co-financed by FWO and Department of Economy, Science and Innovation (EWI).</p>"}, {"location": "infrastructure/#tier-2-login-nodes", "title": "Tier-2 login nodes", "text": "<p>Log in to the HPC-UGent Tier-2 infrastructure via https://login.hpc.ugent.be or using SSH via <code>login.hpc.ugent.be</code>.</p> <p>more info on using the web portal you can find here, and about connection with SSH here.</p>"}, {"location": "infrastructure/#tier-2-compute-clusters", "title": "Tier-2 compute clusters", "text": ""}, {"location": "infrastructure/#cpu-clusters", "title": "CPU clusters", "text": "<p>The HPC-UGent Tier-2 infrastructure currently included several standard CPU-only clusters, of different generations (listed from old to new).</p> <p>For basic information on using these clusters, see our documentation.</p> cluster name # nodes Processor architecture Usable memory/node Local diskspace/node Interconnect Operating system doduo (default cluster) 128 2x 48-core AMD EPYC 7552 (Rome @ 2.2 GHz) 250 GiB 180GB SSD HDR-100 InfiniBand RHEL 9 gallade (*) 16 2x 64-core AMD EPYC 7773X (Milan-X @ 2.2 GHz) 940 GiB 1.5 TB NVME HDR-100 InfiniBand RHEL 9 shinx 48 2x 96-core AMD EPYC 9654 (Genoa @ 2.4 GHz) 370 GiB 500GB NVME NDR-200 InfiniBand RHEL 9 <p>(*) also see this extra information</p>"}, {"location": "infrastructure/#interactive-debug-cluster", "title": "Interactive debug cluster", "text": "<p>A special-purpose interactive debug cluster is available, where you should always be able to get a job running quickly, without waiting in the queue.</p> <p>Intended usage is mainly for interactive work, either via an interactive job or using the HPC-UGent web portal.</p> <p>This cluster is heavily over-provisioned, so jobs may run slower if the cluster is used more heavily.</p> <p>Strict limits are in place per user:  * max. 5 jobs in queue  * max. 3 jobs running  * max. of 8 cores and 27GB of memory in total for running jobs</p> <p>For more information, see our documentation.</p> cluster name # nodes Processor architecture Usable memory/node Local diskspace/node Interconnect Operating system donphan (*) 16 2 x 18-core Intel Xeon Gold 6240 (Cascade Lake @ 2.6 GHz) + 1x shared NVIDIA Ampere A2 GPU (16GB GPU memory) 738 GiB 1.6 TB NVME HDR-100 Infiniband RHEL 9 <p>(*) also see this extra information</p>"}, {"location": "infrastructure/#gpu-clusters", "title": "GPU clusters", "text": "<p>GPU clusters are available in the HPC-UGent Tier-2 infrastructure, with different generations of NVIDIA GPUs.</p> <p>These are well suited for specific workloads, with software that can leverage the GPU resources (like TensorFlow, PyTorch, GROMACS, AlphaFold, etc.).</p> <p>For more information on using these clusters, see our documentation.</p> cluster name # nodes Processor architecture &amp; GPUs Usable memory/node Local diskspace/node Interconnect Operating system joltik 10 2x 16-core Intel Xeon Gold 6242 (Cascade Lake @ 2.8 GHz) + 4x NVIDIA Volta V100 GPUs (32GB GPU memory) 256 GiB 800GB SSD double EDR Infiniband RHEL 9 accelgor 9 2x 24-core AMD EPYC 7413 (Milan @ 2.2 GHz) + 4x NVIDIA Ampere A100 GPUs (80GB GPU memory) 500 GiB 180GB SSD HDR InfiniBand RHEL 9 litleo 8 1x 48 core AMD EPYC 9454P (Genoa @ 2.75 GHz) + 2x NVIDIA H100 NVL (96GB GPU memory) 315 GiB 1.4TB SSD NDR-200 Infiniband RHEL 9"}, {"location": "infrastructure/#tier-2-shared-storage", "title": "Tier-2 shared storage", "text": "Filesystem name Intended usage Total storage space Personal storage space VO storage space (^) $VSC_HOME Home directory, entry point to the system 90 TB 3GB (fixed) (none) $VSC_DATA Long-term storage of large data files 1.9 PB 25GB (fixed) 250GB $VSC_SCRATCH Temporary fast storage of 'live' data for calculations 1.7 PB 25GB (fixed) 250GB $VSC_SCRATCH_ARCANINE Temporary very fast storage of 'live' data for calculations (recommended for very I/O-intensive jobs) 70 TB NVME (none) upon request <p>^ Storage space for a group of users (Virtual Organisation or VO for short) can be increased significantly on request. For more information, see our documentation.</p>"}, {"location": "infrastructure/#infrastructure-status", "title": "Infrastructure status", "text": "<p>Check the system status</p>"}, {"location": "interactive_debug/", "title": "Interactive and debug cluster", "text": ""}, {"location": "interactive_debug/#purpose", "title": "Purpose", "text": "<p>The purpose of this cluster is to give the user an environment where there should be no waiting in the queue to get access to a limited number of resources. This environment allows a user to immediately start working, and is the ideal place for interactive work such as development, debugging and light production workloads (typically sufficient for training and/or courses).</p> <p>This environment should be seen as an extension or even replacement of the login nodes, instead of a dedicated compute resource. The interactive cluster is overcommitted, which means that more CPU cores can be requested for jobs than physically exist in the cluster. Obviously, the performance of this cluster heavily depends on the workloads and the actual overcommit usage. Be aware that jobs can slow down or speed up during their execution.</p> <p>Due to the restrictions and sharing of the CPU resources (see section\u00a0Restrictions and overcommit factor) jobs on this cluster should normally start more or less immediately. The tradeoff is that performance must not be an issue for the submitted jobs. This means that typical workloads for this cluster should be limited to:</p> <ul> <li> <p>Interactive jobs (see     chapter\u00a0Running interactive jobs)</p> </li> <li> <p>Cluster desktop sessions (see     chapter\u00a0Using the HPC-UGent web portal)</p> </li> <li> <p>Jobs requiring few resources</p> </li> <li> <p>Debugging programs</p> </li> <li> <p>Testing and debugging job scripts</p> </li> </ul>"}, {"location": "interactive_debug/#submitting-jobs", "title": "Submitting jobs", "text": "<p>To submit jobs to the HPC-UGent interactive and debug cluster nicknamed <code>donphan</code>, first use:</p> <pre><code>module swap cluster/donphan\n</code></pre> <p>Then use the familiar <code>qsub</code>, <code>qstat</code>, etc. commands (see chapter\u00a0Running batch jobs).</p>"}, {"location": "interactive_debug/#restrictions-and-overcommit-factor", "title": "Restrictions and overcommit factor", "text": "<p>Some limits are in place for this cluster:</p> <ul> <li> <p>each user may have at most 5 jobs in the queue (both running and     waiting to run);</p> </li> <li> <p>at most 3 jobs per user can be running at the same time;</p> </li> <li> <p>running jobs may allocate no more than 8 CPU cores and no more than     27200 MiB of memory in total, per user;</p> </li> </ul> <p>In addition, the cluster has an overcommit factor of 6. This means that 6 times more cores can be allocated than physically exist. Simultaneously, the default memory per core is 6 times less than what would be available on a non-overcommitted cluster.</p> <p>Please note that based on the (historical) workload of the interactive and debug cluster, the above restrictions and the overcommitment ratio might change without prior notice.</p>"}, {"location": "interactive_debug/#shared-gpus", "title": "Shared GPUs", "text": "<p>Each node in the <code>donphan</code> cluster has a relatively small GPU that is shared between all jobs. This means that you don't need to reserve it and thus possibly wait for it. But this also has a downside for performance and security: jobs might be competing for the same GPU resources (cores, memory or encoders) without any preset fairshare and there is no guarantee one job cannot access another job's memory (as opposed to having reserved GPUs in the GPU clusters).</p> <p>All software should behave the same as on the dedicated GPU clusters (e.g. using CUDA or OpenGL acceleration from a cluster desktop via the webportal).</p>"}, {"location": "introduction/", "title": "Introduction to HPC", "text": ""}, {"location": "introduction/#what-is-hpc", "title": "What is HPC?", "text": "<p>\"High Performance Computing\" (HPC) is computing on a \"Supercomputer\", a computer with at the frontline of contemporary processing capacity -- particularly speed of calculation and available memory.</p> <p>While the supercomputers in the early days (around 1970) used only a few processors, in the 1990s machines with thousands of processors began to appear and, by the end of the 20th century, massively parallel supercomputers with tens of thousands of \"off-the-shelf\" processors were the norm. A large number of dedicated processors are placed in close proximity to each other in a computer cluster.</p> <p>A computer cluster consists of a set of loosely or tightly connected computers that work together so that in many respects they can be viewed as a single system.</p> <p>The components of a cluster are usually connected to each other through fast local area networks (\"LAN\") with each node (computer used as a server) running its own instance of an operating system. Computer clusters emerged as a result of convergence of a number of computing trends including the availability of low cost microprocessors, high-speed networks, and software for high performance distributed computing.</p> <p>Compute clusters are usually deployed to improve performance and availability over that of a single computer, while typically being more cost-effective than single computers of comparable speed or availability.</p> <p>Supercomputers play an important role in the field of computational science, and are used for a wide range of computationally intensive tasks in various fields, including quantum mechanics, weather forecasting, climate research, oil and gas exploration, molecular modelling (computing the structures and properties of chemical compounds, biological macromolecules, polymers, and crystals), and physical simulations (such as simulations of the early moments of the universe, airplane and spacecraft aerodynamics, the detonation of nuclear weapons, and nuclear fusion). 1</p>"}, {"location": "introduction/#what-is-the-uantwerpen-hpc", "title": "What is the UAntwerpen-HPC?", "text": "<p>The UAntwerpen-HPC is a collection of computers with AMD and/or Intel CPUs, running a Linux operating system, shaped like pizza boxes and stored above and next to each other in racks, interconnected with copper and fiber cables. Their number crunching power is (presently) measured in hundreds of billions of floating point operations (gigaflops) and even in teraflops.</p> <p> </p> <p>The UAntwerpen-HPC relies on parallel-processing technology to offer University of Antwerp researchers an extremely fast solution for all their data processing needs.</p> <p>The UAntwerpen-HPC consists of:</p> In technical terms ... in human terms over 280 nodes and over 11000 cores ...\u00a0or the equivalent of 2750 quad-core PCs over 500 Terabyte of online storage ...\u00a0or the equivalent of over 60000 DVDs up to 100 Gbit InfiniBand fiber connections ...\u00a0or allowing to transfer 3 DVDs per second <p>The UAntwerpen-HPC currently consists of:</p> <p>Leibniz:</p> <ol> <li> <p>144 compute nodes with 2 14-core Intel E5-2680v4 CPUs (Broadwell     generation, 2.4 GHz) and 128 GB RAM, 120 GB local disk</p> </li> <li> <p>8 compute nodes with 2 14-core Intel E5-2680v4 CPUs (Broadwell     generation, 2.4 GHz) and 256 GB RAM, 120 GB local disk</p> </li> <li> <p>24 \"hopper\" compute nodes (recovered from the former Hopper cluster)     with 2 ten core Intel E5-2680v2 CPUs (Ivy Bridge generation, 2.8     GHz), 256 GB memory, 500 GB local disk</p> </li> <li> <p>2 GPGPU nodes with 2 14-core Intel E5-2680v4 CPUs (Broadwell     generation, 2.4 GHz), 128 GB RAM and two NVIDIA Tesla P100 GPUs with     16 GB HBM2 memory per GPU, 120 GB local disk</p> </li> <li> <p>1 vector computing node with 1 12-core Intel Xeon Gold 6126 (Skylake     generation, 2.6 GHz), 96 GB RAM and 2 NEC SX-Aurora Vector Engines     type 10B (per card 8 cores @1.4 GHz, 48 GB HBM2), 240 GB local disk</p> </li> <li> <p>1 Xeon Phi node with 2 14-core Intel E5-2680v4 CPUs (Broadwell     generation, 2.4 GHz), 128 GB RAM and Intel Xeon Phi 7220P PCIe card     with 16 GB of RAM, 120 GB local disk</p> </li> <li> <p>1 visualisation node with 2 14-core Intel E5-2680v4 CPUs (Broadwell     generation, 2.4 GHz), 256 GB RAM and with a NVIDIA P5000 GPU, 120 GB     local disk</p> </li> </ol> <p>The nodes are connected using an InfiniBand EDR network except for the \"hopper\" compute nodes that utilize FDR10 InfiniBand.</p> <p>Vaughan:</p> <ol> <li>104 compute nodes with 2 32-core AMD Epyc 7452 (2.35 GHz) and 256 GB     RAM, 240 GB local disk</li> </ol> <p>The nodes are connected using an InfiniBand HDR100 network.</p> <p>All the nodes in the UAntwerpen-HPC run under the \"CentOS Linux release 7.8.2003 (Core)\" operating system, which is a clone of \"RedHat Enterprise Linux\", with cgroups support.</p> <p>Two tools perform the Job management and job scheduling:</p> <ol> <li> <p>TORQUE: a resource manager (based on PBS);</p> </li> <li> <p>Moab: job scheduler and management tools.</p> </li> </ol> <p>For maintenance and monitoring, we use:</p> <ol> <li> <p>Ganglia: monitoring software;</p> </li> <li> <p>Icinga and Nagios: alert manager.</p> </li> </ol>"}, {"location": "introduction/#what-the-hpc-infrastucture-is-not", "title": "What the HPC infrastucture is not", "text": "<p>The HPC infrastructure is not a magic computer that automatically:</p> <ol> <li> <p>runs your PC-applications much faster for bigger problems;</p> </li> <li> <p>develops your applications;</p> </li> <li> <p>solves your bugs;</p> </li> <li> <p>does your thinking;</p> </li> <li> <p>...</p> </li> <li> <p>allows you to play games even faster.</p> </li> </ol> <p>The UAntwerpen-HPC does not replace your desktop computer.</p>"}, {"location": "introduction/#is-the-uantwerpen-hpc-a-solution-for-my-computational-needs", "title": "Is the UAntwerpen-HPC a solution for my computational needs?", "text": ""}, {"location": "introduction/#batch-or-interactive-mode", "title": "Batch or interactive mode?", "text": "<p>Typically, the strength of a supercomputer comes from its ability to run a huge number of programs (i.e., executables) in parallel without any user interaction in real time. This is what is called \"running in batch mode\".</p> <p>It is also possible to run programs at the UAntwerpen-HPC, which require user interaction. (pushing buttons, entering input data, etc.). Although technically possible, the use of the UAntwerpen-HPC might not always be the best and smartest option to run those interactive programs. Each time some user interaction is needed, the computer will wait for user input. The available computer resources (CPU, storage, network, etc.) might not be optimally used in those cases. A more in-depth analysis with the UAntwerpen-HPC staff can unveil whether the UAntwerpen-HPC is the desired solution to run interactive programs. Interactive mode is typically only useful for creating quick visualisations of your data without having to copy your data to your desktop and back.</p>"}, {"location": "introduction/#what-are-cores-processors-and-nodes", "title": "What are cores, processors and nodes?", "text": "<p>In this manual, the terms core, processor and node will be frequently used, so it's useful to understand what they are.</p> <p>Modern servers, also referred to as (worker)nodes in the context of HPC, include one or more sockets, each housing a multi-core processor (next to memory, disk(s), network cards, ...). A modern processor consists of multiple CPUs or cores that are used to execute computations.</p>"}, {"location": "introduction/#parallel-or-sequential-programs", "title": "Parallel or sequential programs?", "text": ""}, {"location": "introduction/#parallel-programs", "title": "Parallel programs", "text": "<p>Parallel computing is a form of computation in which many calculations are carried out simultaneously. They are based on the principle that large problems can often be divided into smaller ones, which are then solved concurrently (\"in parallel\").</p> <p>Parallel computers can be roughly classified according to the level at which the hardware supports parallelism, with multicore computers having multiple processing elements within a single machine, while clusters use multiple computers to work on the same task. Parallel computing has become the dominant computer architecture, mainly in the form of multicore processors.</p> <p>The two parallel programming paradigms most used in HPC are:</p> <ul> <li> <p>OpenMP for shared memory systems (multithreading): on multiple cores     of a single node</p> </li> <li> <p>MPI for distributed memory systems (multiprocessing): on multiple     nodes</p> </li> </ul> <p>Parallel programs are more difficult to write than sequential ones, because concurrency introduces several new classes of potential software bugs, of which race conditions are the most common. Communication and synchronisation between the different subtasks are typically some of the greatest obstacles to getting good parallel program performance.</p>"}, {"location": "introduction/#sequential-programs", "title": "Sequential programs", "text": "<p>Sequential software does not do calculations in parallel, i.e., it only uses one single core of a single workernode. It does not become faster by just throwing more cores at it: it can only use one core.</p> <p>It is perfectly possible to also run purely sequential programs on the UAntwerpen-HPC.</p> <p>Running your sequential programs on the most modern and fastest computers in the UAntwerpen-HPC can save you a lot of time. But it also might be possible to run multiple instances of your program (e.g., with different input parameters) on the UAntwerpen-HPC, in order to solve one overall problem (e.g., to perform a parameter sweep). This is another form of running your sequential programs in parallel.</p>"}, {"location": "introduction/#what-programming-languages-can-i-use", "title": "What programming languages can I use?", "text": "<p>You can use any programming language, any software package and any library provided it has a version that runs on Linux, specifically, on the version of Linux that is installed on the compute nodes, CentOS Linux release 7.8.2003 (Core).</p> <p>For the most common programming languages, a compiler is available on CentOS Linux release 7.8.2003 (Core). Supported and common programming languages on the UAntwerpen-HPC are C/C++, FORTRAN, Java, Perl, Python, MATLAB, R, etc.</p> <p>Supported and commonly used compilers are GCC, clang, J2EE and Intel</p> <p>Commonly used software packages are:</p> <ul> <li> <p>in bioinformatics: beagle, Beast, bowtie, MrBayes, SAMtools</p> </li> <li> <p>in chemistry: ABINIT, CP2K, Gaussian, Gromacs, LAMMPS, NWChem,     Quantum Espresso, Siesta, VASP</p> </li> <li> <p>in engineering: COMSOL, OpenFOAM, Telemac</p> </li> <li> <p>in mathematics: JAGS, MATLAB, R</p> </li> <li> <p>for visuzalization: Gnuplot, ParaView.</p> </li> </ul> <p>Commonly used libraries are Intel MKL, FFTW, HDF5, PETSc and Intel MPI, OpenMPI. Additional software can be installed \"on demand\". Please contact the UAntwerpen-HPC staff to see whether the UAntwerpen-HPC can handle your specific requirements.</p>"}, {"location": "introduction/#what-operating-systems-can-i-use", "title": "What operating systems can I use?", "text": "<p>All nodes in the UAntwerpen-HPC cluster run under CentOS Linux release 7.8.2003 (Core), which is a specific version of RedHat Enterprise Linux. This means that all programs (executables) should be compiled for CentOS Linux release 7.8.2003 (Core).</p> <p>Users can connect from any computer in the University of Antwerp network to the UAntwerpen-HPC, regardless of the Operating System that they are using on their personal computer. Users can use any of the common Operating Systems (such as Windows, macOS or any version of Linux/Unix/BSD) and run and control their programs on the UAntwerpen-HPC.</p> <p>A user does not need to have prior knowledge about Linux; all of the required knowledge is explained in this tutorial.</p>"}, {"location": "introduction/#what-does-a-typical-workflow-look-like", "title": "What does a typical workflow look like?", "text": "<p>A typical workflow looks like:</p> <ol> <li> <p>Connect to the login nodes with SSH (see First Time connection to the HPC infrastructure)</p> </li> <li> <p>Transfer your files to the cluster (see Transfer Files to/from the HPC)</p> </li> <li> <p>Optional: compile your code and test it (for compiling, see Compiling and testing your software on the HPC)</p> </li> <li> <p>Create a job script and submit your job (see Running batch jobs)</p> </li> <li> <p>Get some coffee and be patient:</p> <ol> <li> <p>Your job gets into the queue</p> </li> <li> <p>Your job gets executed</p> </li> <li> <p>Your job finishes</p> </li> </ol> </li> <li> <p>Study the results generated by your jobs, either on the cluster or     after downloading them locally.</p> </li> </ol>"}, {"location": "introduction/#what-is-the-next-step", "title": "What is the next step?", "text": "<p>When you think that the UAntwerpen-HPC is a useful tool to support your computational needs, we encourage you to acquire a VSC-account (as explained in Getting a HPC Account), read Connecting to the HPC infrastructure, \"Setting up the environment\", and explore chapters\u00a0Running interactive jobs to\u00a0Fine-tuning Job Specifications which will help you to transfer and run your programs on the UAntwerpen-HPC cluster.</p> <p>Do not hesitate to contact the UAntwerpen-HPC staff for any help.</p> <ol> <li> <p>Wikipedia: http://en.wikipedia.org/wiki/Supercomputer \u21a9</p> </li> </ol>"}, {"location": "jobscript_examples/", "title": "Job script examples", "text": ""}, {"location": "jobscript_examples/#simple-job-script-template", "title": "Simple job script template", "text": "<p>This is a template for a job script, with commonly used parameters. The basic parameters should always be used. Some notes on the situational parameters:</p> <ul> <li> <p><code>-l mem</code>: If no memory parameter is given, the job gets access to an amount of     memory proportional to the amount of cores requested.     See also: Job failed: SEGV Segmentation fault</p> </li> <li> <p><code>-m/-M</code>: the <code>-m</code> option will send emails to your email address registerd with VSC.     Only if you want emails at some other address, you should use the <code>-M</code> option.</p> </li> <li> <p>Replace the \"<code>-placeholder text-</code>\" with real entries.     This notation is used to ensure <code>qsub</code> rejects invalid options.</p> </li> <li> <p>To use a situational parameter, remove one '<code>#</code>' at the beginning of the line.</p> </li> </ul> simple_jobscript.sh<pre><code>#!/bin/bash\n\n# Basic parameters\n#PBS -N jobname           ## Job name\n#PBS -l nodes=1:ppn=2     ## 1 node, 2 processors per node (ppn=all to get a full node)\n#PBS -l walltime=01:00:00 ## Max time your job will run (no more than 72:00:00)\n\n# Situational parameters: remove one '#' at the front to use\n##PBS -l gpus=1            ## GPU amount (only on accelgor or joltik)\n##PBS -l mem=32gb          ## If not used, memory will be available proportional to the max amount\n##PBS -m abe               ## Email notifications (abe=aborted, begin and end)\n##PBS -M -email_address-   ## ONLY if you want to use a different email than your VSC address\n##PBS -A -project-         ## Project name when credits are required (only Tier 1)\n\n##PBS -o -filename-        ## Output log\n##PBS -e -filename-        ## Error log\n\n\nmodule load [module]\nmodule load [module]\n\ncd $PBS_O_WORKDIR         # Change working directory to the location where the job was submmitted\n\n[commands]\n</code></pre>"}, {"location": "jobscript_examples/#single-core-job", "title": "Single-core job", "text": "<p>Here's an example of a single-core job script:</p> single_core.sh<pre><code>#!/bin/bash\n#PBS -N count_example         ## job name\n#PBS -l nodes=1:ppn=1         ## single-node job, single core\n#PBS -l walltime=2:00:00      ## max. 2h of wall time\nmodule load Python/3.6.4-intel-2018a\n# copy input data from location where job was submitted from\ncp $PBS_O_WORKDIR/input.txt $TMPDIR\n# go to temporary working directory (on local disk) &amp; run\ncd $TMPDIR\npython -c \"print(len(open('input.txt').read()))\" &gt; output.txt\n# copy back output data, ensure unique filename using $PBS_JOBID\ncp output.txt $VSC_DATA/output_${PBS_JOBID}.txt\n</code></pre> <ol> <li> <p>Using <code>#PBS</code> header lines, we specify the resource requirements for     the job, see Apendix B for a list of these options.</p> </li> <li> <p>A module for <code>Python 3.6</code> is loaded, see also section Modules.</p> </li> <li> <p>We stage the data in: the file <code>input.txt</code> is copied into the     \"working\" directory, see chapter Running jobs with input/output data.</p> </li> <li> <p>The main part of the script runs a small Python program that counts     the number of characters in the provided input file <code>input.txt</code>.</p> </li> <li> <p>We stage the results out: the output file <code>output.txt</code> is copied     from the \"working directory\" (<code>$TMPDIR</code>|) to a unique directory in     <code>$VSC_DATA</code>. For a list of possible storage locations, see subsection  Pre-defined user directories.</p> </li> </ol>"}, {"location": "jobscript_examples/#multi-core-job", "title": "Multi-core job", "text": "<p>Here's an example of a multi-core job script that uses <code>mympirun</code>:</p> multi_core.sh<pre><code>#!/bin/bash\n#PBS -N mpi_hello             ## job name\n#PBS -l nodes=2:ppn=all       ## 2 nodes, all cores per node\n#PBS -l walltime=2:00:00      ## max. 2h of wall time\nmodule load intel/2017b\nmodule load vsc-mympirun      ## We don't use a version here, this is on purpose\n# go to working directory, compile and run MPI hello world\ncd $PBS_O_WORKDIR\nmpicc mpi_hello.c -o mpi_hello\nmympirun ./mpi_hello\n</code></pre> <p>An example MPI hello world program can be downloaded from https://github.com/hpcugent/vsc-mympirun/blob/master/testscripts/mpi_helloworld.c.</p>"}, {"location": "jobscript_examples/#running-a-command-with-a-maximum-time-limit", "title": "Running a command with a maximum time limit", "text": "<p>If you want to run a job, but you are not sure it will finish before the job runs out of walltime and you want to copy data back before, you have to stop the main command before the walltime runs out and copy the data back.</p> <p>This can be done with the <code>timeout</code> command. This command sets a limit of time a program can run for, and when this limit is exceeded, it kills the program. Here's an example job script using <code>timeout</code>:</p> timeout.sh<pre><code>#!/bin/bash\n#PBS -N timeout_example\n#PBS -l nodes=1:ppn=1        ## single-node job, single core\n#PBS -l walltime=2:00:00     ## max. 2h of wall time\n\n# go to temporary working directory (on local disk)\ncd $TMPDIR\n# This command will take too long (1400 minutes is longer than our walltime)\n# $PBS_O_WORKDIR/example_program.sh 1400 output.txt\n\n# So we put it after a timeout command\n# We have a total of 120 minutes (2 x 60) and we instruct the script to run for\n# 100 minutes, but timeout after 90 minute,\n# so we have 30 minutes left to copy files back. This should\n#  be more than enough.\ntimeout -s SIGKILL 90m $PBS_O_WORKDIR/example_program.sh 100 output.txt\n# copy back output data, ensure unique filename using $PBS_JOBID\ncp output.txt $VSC_DATA/output_${PBS_JOBID}.txt\n</code></pre> <p>The example program used in this script is a dummy script that simply sleeps a specified amount of minutes:</p> example_program.sh<pre><code>#!/bin/bash\n# This is an example program\n# It takes two arguments: a number of times to loop and a file to write to\n# In total, it will run for (the number of times to loop) minutes\n\nif [ $# -ne 2 ]; then\necho \"Usage: ./example_program amount filename\" &amp;&amp; exit 1\nfi\n\nfor ((i = 0; i &lt; $1; i++ )); do\necho \"${i} =&gt; $(date)\" &gt;&gt; $2\nsleep 60\ndone\n</code></pre>"}, {"location": "jupyter/", "title": "Jupyter notebook", "text": ""}, {"location": "jupyter/#what-is-a-jupyter-notebook", "title": "What is a Jupyter notebook", "text": "<p>A Jupyter notebook is an interactive, web-based environment that allows you to create documents that contain live code, equations, visualizations, and plaintext. The code blocks in these documents can be used to write Python, Java, R and Julia code, among others. The combination of code executions with text and visual outputs make it a useful tool for data analysis, machine learning and educational purposes.</p>"}, {"location": "jupyter/#using-jupyter-notebooks-on-the-hpc", "title": "Using Jupyter Notebooks on the HPC", "text": ""}, {"location": "jupyter/#launching-a-notebook-using-the-web-portal", "title": "Launching a notebook using the web portal", "text": "<p>Through the HPC-UGent web portal you can easily start a Jupyter notebook on a workernode, via the Jupyter Notebook button under the Interactive Apps menu item.</p> <p></p> <p>After starting the Jupyter notebook using the Launch button, you will see it being added in state Queued in the overview of interactive sessions (see My Interactive Sessions menu item):</p> <p></p> <p>When your job hosting the Jupyter notebook starts running, the status will first change the Starting:</p> <p></p> <p>and eventually the status will change to Running, and you will be able to connect to the Jupyter environment using the blue Connect to Jupyter button:</p> <p></p> <p>This will launch the Jupyter environment in a new browser tab, where you can open an existing notebook by navigating to the directory where it is located and clicking it. You can also create a new notebook by clicking on <code>File</code>&gt;<code>New</code>&gt;<code>Notebook</code>:</p> <p></p>"}, {"location": "jupyter/#using-extra-python-packages", "title": "Using extra Python packages", "text": "<p>A number of Python packages are readily available in modules on the HPC. To illustrate how to use them in a Jupyter notebook, we will make use of an example where we want to use numpy in our notebook. The first thing we need to do is finding the modules that contain our package of choice. For numpy, this would be the <code>SciPy-bundle</code> modules.</p> <p>To find the appropriate modules, it is recommended to use the shell within the web portal under <code>Clusters</code>&gt;<code>&gt;_login Shell Access</code>.</p> <p></p> <p>We can see all available versions of the SciPy module by using <code>module avail SciPy-bundle</code>:</p> <pre><code>$ module avail SciPy-bundle\n\n------------------ /apps/gent/RHEL8/zen2-ib/modules/all ------------------\n    SciPy-bundle/2022.05-foss-2022a    SciPy-bundle/2023.11-gfbf-2023b (D)\nSciPy-bundle/2023.07-gfbf-2023a\n\n  Where:\n   D:  Default Module\n...\n</code></pre> <p>Not all modules will work for every notebook, we need to use the one that uses the same toolchain as the notebook we want to launch. To find that toolchain, we can look at the <code>JupyterNotebook version</code> field when creating a notebook. In our example <code>7.2.0</code> is the version of the notebook and <code>GCCcore/13.2.0</code> is the toolchain used.</p> <p></p> <p>Module names include the toolchain that was used to install the module (for example <code>gfbf-2023b</code> in <code>SciPy-bundle/2023.11-gfbf-2023b</code> means that that module uses the toolchain <code>gfbf/2023</code>). To see which modules are compatible with each other, you can check the table on the page about Module conflicts. Another way to find out which <code>GCCcore</code> subtoolchain goes with the particular toolchain of the module (such as <code>gfbf/2023b</code>) is to use <code>module show</code>. In particular using <code>module show &lt;toolchain of the module&gt; | grep GCC</code> (before the module has been loaded) will return this <code>GCCcore</code> version.</p> <pre><code>$ module show gfbf/2023b | grep GCC\nGNU Compiler Collection (GCC) based compiler toolchain, including\nwhatis(\"Description: GNU Compiler Collection (GCC) based compiler toolchain, including\nload(\"GCC/13.2.0\")\nload(\"FlexiBLAS/3.3.1-GCC-13.2.0\")\nload(\"FFTW/3.3.10-GCC-13.2.0\")\n</code></pre> <p>The toolchain used can then for example be found within the line <code>load(\"GCC/13.2.0\")</code> and the included Python packages under the line <code>Included extensions</code>.</p> <p>It is also recommended to doublecheck the compatibility of the Jupyter notebook version and the extra modules by loading them all in a shell environment.  To do so, find the module containing the correct Jupyter notebook version (for our example case this is <code>JupyterNotebook/7.2.0-GCCcore-13.2.0</code>) and then use <code>module load &lt;module_name&gt;</code> for every module as follows:</p> <p><pre><code>$ module load JupyterNotebook/7.2.0-GCCcore-13.2.0\n$ module load SciPy-bundle/2023.11-gfbf-2023b\n</code></pre> This throws no errors, since this module uses a toolchain that is compatible with the toolchain used by the notebook</p> <p>If we use a different SciPy module that uses an incompatible toolchain, we will get a module load conflict when trying to load it (For more info on these errors, see here).</p> <pre><code>$ module load JupyterNotebook/7.2.0-GCCcore-13.2.0\n$ module load SciPy-bundle/2023.07-gfbf-2023a\nLmod has detected the following error:  ...\n</code></pre> <p>Now that we found the right module for the notebook, add <code>module load &lt;module_name&gt;</code> in the <code>Custom code</code> field when creating a notebook and you can make use of the packages within that notebook.</p> <p></p>"}, {"location": "known_issues/", "title": "Known issues", "text": "<p>This page provides details on a couple of known problems, and the workarounds that are available for them.</p> <p>If you have any questions related to these issues, please contact the UAntwerpen-HPC.</p> <ul> <li><code>Operation not permitted</code> error for MPI applications</li> </ul>"}, {"location": "known_issues/#openmpi_libfabric_operation_not_permitted", "title": "<code>Operation not permitted</code> error for MPI applications", "text": "<p>When running an MPI application that was installed with a <code>foss</code> toolchain, you may run into crash with an error message like:</p> <pre><code>Failed to modify UD QP to INIT on mlx5_0: Operation not permitted\n</code></pre> <p>This error means that an internal problem has occurred in OpenMPI.</p>"}, {"location": "known_issues/#cause-of-the-problem", "title": "Cause of the problem", "text": "<p>This problem was introduced with the OS updates that were installed on the HPC-UGent and VSC Tier-1 Hortense clusters mid February 2024, most likely due to updating the Mellanox OFED kernel module.</p> <p>It seems that having OpenMPI consider both UCX and libfabric as \"backends\" to use the high-speed interconnect (InfiniBand) is causing this problem: the error message is reported by UCX, but the problem only occurs when OpenMPI is configured to also consider libfabric.</p>"}, {"location": "known_issues/#affected-software", "title": "Affected software", "text": "<p>We have been notified that this error may occur with various applications, including (but not limited to) CP2K, LAMMPS, netcdf4-python, SKIRT, ...</p>"}, {"location": "known_issues/#workarounds", "title": "Workarounds", "text": ""}, {"location": "known_issues/#openmpi_libfabric_mympirun", "title": "Use latest <code>vsc-mympirun</code>", "text": "<p>A workaround as been implemented in <code>mympirun</code> (version 5.4.0).</p> <p>Make sure you use the latest version of <code>vsc-mympirun</code> by using the following (version-less) <code>module load</code> statement in your job scripts:</p> <pre><code>module load vsc-mympirun\n</code></pre> <p>and launch your MPI application using the <code>mympirun</code> command.</p> <p>For more information, see the <code>mympirun</code> documentation.</p>"}, {"location": "known_issues/#openmpi_libfabric_env_vars", "title": "Configure OpenMPI to not use libfabric via environment variables", "text": "<p>If using <code>mympirun</code> is not an option, you can configure OpenMPI to not consider libfabric (and only use UCX) by setting the following environment variables (in your job script or session environment):</p> <pre><code>export OMPI_MCA_btl='^uct,ofi'\nexport OMPI_MCA_pml='ucx'\nexport OMPI_MCA_mtl='^ofi'\n</code></pre>"}, {"location": "known_issues/#resolution", "title": "Resolution", "text": "<p>We will re-install the affected OpenMPI installations during the scheduled maintenance of 13-17 May 2024 (see also VSC status page).</p>"}, {"location": "multi_core_jobs/", "title": "Multi core jobs/Parallel Computing", "text": ""}, {"location": "multi_core_jobs/#why-parallel-programming", "title": "Why Parallel Programming?", "text": "<p>There are two important motivations to engage in parallel programming.</p> <ol> <li> <p>Firstly, the need to decrease the time to solution: distributing     your code over C cores holds the promise of speeding up execution     times by a factor C. All modern computers (and probably even your     smartphone) are equipped with multi-core processors capable of     parallel processing.</p> </li> <li> <p>The second reason is problem size: distributing your code over N     nodes increases the available memory by a factor N, and thus holds     the promise of being able to tackle problems which are N times     bigger.</p> </li> </ol> <p>On a desktop computer, this enables a user to run multiple programs and the operating system simultaneously. For scientific computing, this means you have the ability in principle of splitting up your computations into groups and running each group on its own core.</p> <p>There are multiple different ways to achieve parallel programming. The table below gives a (non-exhaustive) overview of problem independent approaches to parallel programming. In addition there are many problem specific libraries that incorporate parallel capabilities. The next three sections explore some common approaches: (raw) threads, OpenMP and MPI.</p> Tool Available languages binding Limitations Raw threads (pthreads, boost::threading, ...) Threading libraries are available for all common programming languages Threading libraries are available for all common programming languages &amp; Threads are limited to shared memory systems. They are more often used on single node systems rather than for UAntwerpen-HPC. Thread management is hard. OpenMP Fortran/C/C++ Limited to shared memory systems, but large shared memory systems for HPC are not uncommon (e.g., SGI UV). Loops and task can be parallelized by simple insertion of compiler directives. Under the hood threads are used. Hybrid approaches exist which use OpenMP to parallelize the work load on each node and MPI (see below) for communication between nodes. Lightweight threads with clever scheduling, Intel TBB, Intel Cilk Plus C/C++ Limited to shared memory systems, but may be combined with MPI. Thread management is taken care of by a very clever scheduler enabling the programmer to focus on parallelization itself. Hybrid approaches exist which use TBB and/or Cilk Plus to parallelise the work load on each node and MPI (see below) for communication between nodes. MPI Fortran/C/C++, Python Applies to both distributed and shared memory systems. Cooperation between different nodes or cores is managed by explicit calls to library routines handling communication routines. Global Arrays library C/C++, Python Mimics a global address space on distributed memory systems, by distributing arrays over many nodes and one sided communication. This library is used a lot for chemical structure calculation codes and was used in one of the first applications that broke the PetaFlop barrier. <p>Tip</p> <p>You can request more nodes/cores by adding following line to your run script. <pre><code>#PBS -l nodes=2:ppn=10\n</code></pre> This queues a job that claims 2 nodes and 10 cores.</p> <p>Warning</p> <p>Just requesting more nodes and/or cores does not mean that your job will automatically run faster. You can find more about this here.</p>"}, {"location": "multi_core_jobs/#parallel-computing-with-threads", "title": "Parallel Computing with threads", "text": "<p>Multi-threading is a widespread programming and execution model that allows multiple threads to exist within the context of a single process. These threads share the process' resources, but are able to execute independently. The threaded programming model provides developers with a useful abstraction of concurrent execution. Multi-threading can also be applied to a single process to enable parallel execution on a multiprocessing system.</p> <p></p> <p>This advantage of a multithreaded program allows it to operate faster on computer systems that have multiple CPUs or across a cluster of machines --- because the threads of the program naturally lend themselves to truly concurrent execution. In such a case, the programmer needs to be careful to avoid race conditions, and other non-intuitive behaviours. In order for data to be correctly manipulated, threads will often need to synchronise in time in order to process the data in the correct order. Threads may also require mutually exclusive operations (often implemented using semaphores) in order to prevent common data from being simultaneously modified, or read while in the process of being modified. Careless use of such primitives can lead to deadlocks.</p> <p>Threads are a way that a program can spawn concurrent units of processing that can then be delegated by the operating system to multiple processing cores. Clearly the advantage of a multithreaded program (one that uses multiple threads that are assigned to multiple processing cores) is that you can achieve big speedups, as all cores of your CPU (and all CPUs if you have more than one) are used at the same time.</p> <p>Here is a simple example program that spawns 5 threads, where each one runs a simple function that only prints \"Hello from thread\".</p> <p>Go to the example directory:</p> <pre><code>cd ~/examples/Multi-core-jobs-Parallel-Computing\n</code></pre> <p>Note</p> <p>If the example directory is not yet present, copy it to your home directory:</p> <pre><code>cp -r /apps/antwerpen/tutorials/Intro-HPC/examples ~/\n</code></pre> <p>Study the example first:</p> T_hello.c<pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: Showcase of working with threads\n */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;pthread.h&gt;\n\n#define NTHREADS 5\n\nvoid *myFun(void *x)\n{\nint tid;\ntid = *((int *) x);\nprintf(\"Hello from thread %d!\\n\", tid);\nreturn NULL;\n}\n\nint main(int argc, char *argv[])\n{\npthread_t threads[NTHREADS];\nint thread_args[NTHREADS];\nint rc, i;\n\n/* spawn the threads */\nfor (i=0; i&lt;NTHREADS; ++i)\n{\nthread_args[i] = i;\nprintf(\"spawning thread %d\\n\", i);\nrc = pthread_create(&amp;threads[i], NULL, myFun, (void *) &amp;thread_args[i]);\n}\n\n/* wait for threads to finish */\nfor (i=0; i&lt;NTHREADS; ++i) {\nrc = pthread_join(threads[i], NULL);\n}\n\nreturn 1;\n}\n</code></pre> <p>And compile it (whilst including the thread library) and run and test it on the login-node:</p> <pre><code>$ module load GCC\n$ gcc -o T_hello T_hello.c -lpthread\n$ ./T_hello\nspawning thread 0\nspawning thread 1\nspawning thread 2\nHello from thread 0!\nHello from thread 1!\nHello from thread 2!\nspawning thread 3\nspawning thread 4\nHello from thread 3!\nHello from thread 4!\n</code></pre> <p>Now, run it on the cluster and check the output:</p> <pre><code>$ qsub T_hello.pbs\n433253.leibniz\n$ more T_hello.pbs.o433253.leibniz\nspawning thread 0\nspawning thread 1\nspawning thread 2\nHello from thread 0!\nHello from thread 1!\nHello from thread 2!\nspawning thread 3\nspawning thread 4\nHello from thread 3!\nHello from thread 4!\n</code></pre> <p>Tip</p> <p>If you plan engaging in parallel programming using threads, this book may prove useful: Professional Multicore Programming: Design and Implementation for C++ Developers. Cameron Hughes and Tracey Hughes. Wrox 2008.</p>"}, {"location": "multi_core_jobs/#parallel-computing-with-openmp", "title": "Parallel Computing with OpenMP", "text": "<p>OpenMP is an API that implements a multi-threaded, shared memory form of parallelism. It uses a set of compiler directives (statements that you add to your code and that are recognised by your Fortran/C/C++ compiler if OpenMP is enabled or otherwise ignored) that are incorporated at compile-time to generate a multi-threaded version of your code. You can think of Pthreads (above) as doing multi-threaded programming \"by hand\", and OpenMP as a slightly more automated, higher-level API to make your program multithreaded. OpenMP takes care of many of the low-level details that you would normally have to implement yourself, if you were using Pthreads from the ground up.</p> <p>An important advantage of OpenMP is that, because it uses compiler directives, the original serial version stays intact, and minimal changes (in the form of compiler directives) are necessary to turn a working serial code into a working parallel code.</p> <p>Here is the general code structure of an OpenMP program: <pre><code>#include &lt;omp.h&gt;\nmain ()  {\nint var1, var2, var3;\n// Serial code\n// Beginning of parallel section. Fork a team of threads.\n// Specify variable scoping\n\n#pragma omp parallel private(var1, var2) shared(var3)\n{\n// Parallel section executed by all threads\n// All threads join master thread and disband\n}\n// Resume serial code\n}\n</code></pre></p>"}, {"location": "multi_core_jobs/#private-versus-shared-variables", "title": "Private versus Shared variables", "text": "<p>By using the private() and shared() clauses, you can specify variables within the parallel region as being shared, i.e., visible and accessible by all threads simultaneously, or private, i.e., private to each thread, meaning each thread will have its own local copy. In the code example below for parallelising a for loop, you can see that we specify the thread_id and nloops variables as private.</p>"}, {"location": "multi_core_jobs/#parallelising-for-loops-with-openmp", "title": "Parallelising for loops with OpenMP", "text": "<p>Parallelising for loops is really simple (see code below). By default, loop iteration counters in OpenMP loop constructs (in this case the i variable) in the for loop are set to private variables.</p> omp1.c<pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: Showcase program for OMP loops\n */\n/* OpenMP_loop.c  */\n#include &lt;stdio.h&gt;\n#include &lt;omp.h&gt;\n\nint main(int argc, char **argv)\n{\nint i, thread_id, nloops;\n\n#pragma omp parallel private(thread_id, nloops)\n{\nnloops = 0;\n\n#pragma omp for\nfor (i=0; i&lt;1000; ++i)\n{\n++nloops;\n}\nthread_id = omp_get_thread_num();\nprintf(\"Thread %d performed %d iterations of the loop.\\n\", thread_id, nloops );\n}\n\nreturn 0;\n}\n</code></pre> <p>And compile it (whilst including the \"openmp\" library) and run and test it on the login-node:</p> <pre><code>$ module load GCC\n$ gcc -fopenmp -o omp1 omp1.c\n$ ./omp1\nThread 6 performed 125 iterations of the loop.\nThread 7 performed 125 iterations of the loop.\nThread 5 performed 125 iterations of the loop.\nThread 4 performed 125 iterations of the loop.\nThread 0 performed 125 iterations of the loop.\nThread 2 performed 125 iterations of the loop.\nThread 3 performed 125 iterations of the loop.\nThread 1 performed 125 iterations of the loop.\n</code></pre> <p>Now run it in the cluster and check the result again.</p> <pre><code>$ qsub omp1.pbs\n$ cat omp1.pbs.o*\nThread 1 performed 125 iterations of the loop.\nThread 4 performed 125 iterations of the loop.\nThread 3 performed 125 iterations of the loop.\nThread 0 performed 125 iterations of the loop.\nThread 5 performed 125 iterations of the loop.\nThread 7 performed 125 iterations of the loop.\nThread 2 performed 125 iterations of the loop.\nThread 6 performed 125 iterations of the loop.\n</code></pre>"}, {"location": "multi_core_jobs/#critical-code", "title": "Critical Code", "text": "<p>Using OpenMP you can specify something called a \"critical\" section of code. This is code that is performed by all threads, but is only performed one thread at a time (i.e., in serial). This provides a convenient way of letting you do things like updating a global variable with local results from each thread, and you don't have to worry about things like other threads writing to that global variable at the same time (a collision).</p> omp2.c<pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: OpenMP Test Program\n */\n#include &lt;stdio.h&gt;\n#include &lt;omp.h&gt;\n\nint main(int argc, char *argv[])\n{\nint i, thread_id;\nint glob_nloops, priv_nloops;\nglob_nloops = 0;\n\n// parallelize this chunk of code\n#pragma omp parallel private(priv_nloops, thread_id)\n{\npriv_nloops = 0;\nthread_id = omp_get_thread_num();\n\n// parallelize this for loop\n#pragma omp for\nfor (i=0; i&lt;100000; ++i)\n{\n++priv_nloops;\n}\n\n// make this a \"critical\" code section\n#pragma omp critical\n{\nprintf(\"Thread %d is adding its iterations (%d) to sum (%d), \", thread_id, priv_nloops, glob_nloops);\nglob_nloops += priv_nloops;\nprintf(\"total is now %d.\\n\", glob_nloops);\n}\n}\nprintf(\"Total # loop iterations is %d\\n\", glob_nloops);\nreturn 0;\n}\n</code></pre> <p>And compile it (whilst including the \"openmp\" library) and run and test it on the login-node:</p> <pre><code>$ module load GCC\n$ gcc -fopenmp -o omp2 omp2.c\n$ ./omp2\nThread 3 is adding its iterations (12500) to sum (0), total is now 12500.\nThread 7 is adding its iterations (12500) to sum (12500), total is now 25000.\nThread 5 is adding its iterations (12500) to sum (25000), total is now 37500.\nThread 6 is adding its iterations (12500) to sum (37500), total is now 50000.\nThread 2 is adding its iterations (12500) to sum (50000), total is now 62500.\nThread 4 is adding its iterations (12500) to sum (62500), total is now 75000.\nThread 1 is adding its iterations (12500) to sum (75000), total is now 87500.\nThread 0 is adding its iterations (12500) to sum (87500), total is now 100000.\nTotal # loop iterations is 100000\n</code></pre> <p>Now run it in the cluster and check the result again.</p> <pre><code>$ qsub omp2.pbs\n$ cat omp2.pbs.o*\nThread 2 is adding its iterations (12500) to sum (0), total is now 12500.\nThread 0 is adding its iterations (12500) to sum (12500), total is now 25000.\nThread 1 is adding its iterations (12500) to sum (25000), total is now 37500.\nThread 4 is adding its iterations (12500) to sum (37500), total is now 50000.\nThread 7 is adding its iterations (12500) to sum (50000), total is now 62500.\nThread 3 is adding its iterations (12500) to sum (62500), total is now 75000.\nThread 5 is adding its iterations (12500) to sum (75000), total is now 87500.\nThread 6 is adding its iterations (12500) to sum (87500), total is now 100000.\nTotal # loop iterations is 100000\n</code></pre>"}, {"location": "multi_core_jobs/#reduction", "title": "Reduction", "text": "<p>Reduction refers to the process of combining the results of several sub-calculations into a final result. This is a very common paradigm (and indeed the so-called \"map-reduce\" framework used by Google and others is very popular). Indeed we used this paradigm in the code example above, where we used the \"critical code\" directive to accomplish this. The map-reduce paradigm is so common that OpenMP has a specific directive that allows you to more easily implement this.</p> omp3.c<pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: OpenMP Test Program\n */\n#include &lt;stdio.h&gt;\n#include &lt;omp.h&gt;\n\nint main(int argc, char *argv[])\n{\nint i, thread_id;\nint glob_nloops, priv_nloops;\nglob_nloops = 0;\n\n// parallelize this chunk of code\n#pragma omp parallel private(priv_nloops, thread_id) reduction(+:glob_nloops)\n{\npriv_nloops = 0;\nthread_id = omp_get_thread_num();\n\n// parallelize this for loop\n#pragma omp for\nfor (i=0; i&lt;100000; ++i)\n{\n++priv_nloops;\n}\nglob_nloops += priv_nloops;\n}\nprintf(\"Total # loop iterations is %d\\n\", glob_nloops);\nreturn 0;\n}\n</code></pre> <p>And compile it (whilst including the \"openmp\" library) and run and test it on the login-node:</p> <pre><code>$ module load GCC\n$ gcc -fopenmp -o omp3 omp3.c\n$ ./omp3\nTotal # loop iterations is 100000\n</code></pre> <p>Now run it in the cluster and check the result again.</p> <pre><code>$ qsub omp3.pbs\n$ cat omp3.pbs.o*\nTotal # loop iterations is 100000\n</code></pre>"}, {"location": "multi_core_jobs/#other-openmp-directives", "title": "Other OpenMP directives", "text": "<p>There are a host of other directives you can issue using OpenMP.</p> <p>Some other clauses of interest are:</p> <ol> <li> <p>barrier: each thread will wait until all threads have reached this     point in the code, before proceeding</p> </li> <li> <p>nowait: threads will not wait until everybody is finished</p> </li> <li> <p>schedule(type, chunk) allows you to specify how tasks are spawned     out to threads in a for loop. There are three types of scheduling     you can specify</p> </li> <li> <p>if: allows you to parallelise only if a certain condition is met</p> </li> <li> <p>...\u00a0and a host of others</p> </li> </ol> <p>Tip</p> <p>If you plan engaging in parallel programming using OpenMP, this book may prove useful: Using OpenMP - Portable Shared Memory Parallel Programming. By Barbara Chapman Gabriele Jost and Ruud van der Pas Scientific and Engineering Computation. 2005.</p>"}, {"location": "multi_core_jobs/#parallel-computing-with-mpi", "title": "Parallel Computing with MPI", "text": "<p>The Message Passing Interface (MPI) is a standard defining core syntax and semantics of library routines that can be used to implement parallel programming in C (and in other languages as well). There are several implementations of MPI such as Open MPI, Intel MPI, M(VA)PICH and LAM/MPI.</p> <p>In the context of this tutorial, you can think of MPI, in terms of its complexity, scope and control, as sitting in between programming with Pthreads, and using a high-level API such as OpenMP. For a Message Passing Interface (MPI) application, a parallel task usually consists of a single executable running concurrently on multiple processors, with communication between the processes. This is shown in the following diagram:</p> <p></p> <p>The process numbers 0, 1 and 2 represent the process rank and have greater or less significance depending on the processing paradigm. At the minimum, Process 0 handles the input/output and determines what other processes are running.</p> <p>The MPI interface allows you to manage allocation, communication, and synchronisation of a set of processes that are mapped onto multiple nodes, where each node can be a core within a single CPU, or CPUs within a single machine, or even across multiple machines (as long as they are networked together).</p> <p>One context where MPI shines in particular is the ability to easily take advantage not just of multiple cores on a single machine, but to run programs on clusters of several machines. Even if you don't have a dedicated cluster, you could still write a program using MPI that could run your program in parallel, across any collection of computers, as long as they are networked together.</p> <p>Here is a \"Hello World\" program in MPI written in C. In this example, we send a \"Hello\" message to each processor, manipulate it trivially, return the results to the main process, and print the messages.</p> <p>Study the MPI-programme and the PBS-file:</p> mpi_hello.c<pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: \"Hello World\" MPI Test Program\n */\n#include &lt;stdio.h&gt;\n#include &lt;mpi.h&gt;\n\n#include &lt;mpi.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define BUFSIZE 128\n#define TAG 0\n\nint main(int argc, char *argv[])\n{\nchar idstr[32];\nchar buff[BUFSIZE];\nint numprocs;\nint myid;\nint i;\nMPI_Status stat;\n/* MPI programs start with MPI_Init; all 'N' processes exist thereafter */\nMPI_Init(&amp;argc,&amp;argv);\n/* find out how big the SPMD world is */\nMPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs);\n/* and this processes' rank is */\nMPI_Comm_rank(MPI_COMM_WORLD,&amp;myid);\n\n/* At this point, all programs are running equivalently, the rank\n      distinguishes the roles of the programs in the SPMD model, with\n      rank 0 often used specially... */\nif(myid == 0)\n{\nprintf(\"%d: We have %d processors\\n\", myid, numprocs);\nfor(i=1;i&lt;numprocs;i++)\n{\nsprintf(buff, \"Hello %d! \", i);\nMPI_Send(buff, BUFSIZE, MPI_CHAR, i, TAG, MPI_COMM_WORLD);\n}\nfor(i=1;i&lt;numprocs;i++)\n{\nMPI_Recv(buff, BUFSIZE, MPI_CHAR, i, TAG, MPI_COMM_WORLD, &amp;stat);\nprintf(\"%d: %s\\n\", myid, buff);\n}\n}\nelse\n{\n/* receive from rank 0: */\nMPI_Recv(buff, BUFSIZE, MPI_CHAR, 0, TAG, MPI_COMM_WORLD, &amp;stat);\nsprintf(idstr, \"Processor %d \", myid);\nstrncat(buff, idstr, BUFSIZE-1);\nstrncat(buff, \"reporting for duty\", BUFSIZE-1);\n/* send to rank 0: */\nMPI_Send(buff, BUFSIZE, MPI_CHAR, 0, TAG, MPI_COMM_WORLD);\n}\n\n/* MPI programs end with MPI Finalize; this is a weak synchronization point */\nMPI_Finalize();\nreturn 0;\n}\n</code></pre> mpi_hello.pbs<pre><code>#!/bin/bash\n\n#PBS -N mpihello\n#PBS -l walltime=00:05:00\n\n# assume a 40 core job\n#PBS -l nodes=2:ppn=20\n\n# make sure we are in the right directory in case writing files\ncd $PBS_O_WORKDIR\n\n# load the environment\n\nmodule load intel\n\nmpirun ./mpi_hello\n</code></pre> <p>and compile it:</p> <pre><code>$ module load intel\n$ mpiicc -o mpi_hello mpi_hello.c\n</code></pre> <p>mpiicc is a wrapper of the Intel C++ compiler icc to compile MPI programs (see the chapter on compilation for details).</p> <p>Run the parallel program:</p> <pre><code>$ qsub mpi_hello.pbs\n$ ls -l\ntotal 1024\n-rwxrwxr-x 1 vsc20167 8746 Sep 16 14:19 mpi_hello*\n-rw-r--r-- 1 vsc20167 1626 Sep 16 14:18 mpi_hello.c\n-rw------- 1 vsc20167    0 Sep 16 14:22 mpi_hello.o433253.leibniz\n-rw------- 1 vsc20167  697 Sep 16 14:22 mpi_hello.o433253.leibniz\n-rw-r--r-- 1 vsc20167  304 Sep 16 14:22 mpi_hello.pbs\n$ cat mpi_hello.o433253.leibniz\n0: We have 16 processors\n0: Hello 1! Processor 1 reporting for duty\n0: Hello 2! Processor 2 reporting for duty\n0: Hello 3! Processor 3 reporting for duty\n0: Hello 4! Processor 4 reporting for duty\n0: Hello 5! Processor 5 reporting for duty\n0: Hello 6! Processor 6 reporting for duty\n0: Hello 7! Processor 7 reporting for duty\n0: Hello 8! Processor 8 reporting for duty\n0: Hello 9! Processor 9 reporting for duty\n0: Hello 10! Processor 10 reporting for duty\n0: Hello 11! Processor 11 reporting for duty\n0: Hello 12! Processor 12 reporting for duty\n0: Hello 13! Processor 13 reporting for duty\n0: Hello 14! Processor 14 reporting for duty\n0: Hello 15! Processor 15 reporting for duty\n</code></pre> <p>The runtime environment for the MPI implementation used (often called mpirun or mpiexec) spawns multiple copies of the program, with the total number of copies determining the number of process ranks in MPI_COMM_WORLD, which is an opaque descriptor for communication between the set of processes. A single process, multiple data (SPMD = Single Program, Multiple Data) programming model is thereby facilitated, but not required; many MPI implementations allow multiple, different, executables to be started in the same MPI job. Each process has its own rank, the total number of processes in the world, and the ability to communicate between them either with point-to-point (send/receive) communication, or by collective communication among the group. It is enough for MPI to provide an SPMD-style program with MPI_COMM_WORLD, its own rank, and the size of the world to allow algorithms to decide what to do. In more realistic situations, I/O is more carefully managed than in this example. MPI does not guarantee how POSIX I/O would actually work on a given system, but it commonly does work, at least from rank 0.</p> <p>MPI uses the notion of process rather than processor. Program copies are mapped to processors by the MPI runtime. In that sense, the parallel machine can map to 1 physical processor, or N where N is the total number of processors available, or something in between. For maximum parallel speedup, more physical processors are used. This example adjusts its behaviour to the size of the world N, so it also seeks to scale to the runtime configuration without compilation for each size variation, although runtime decisions might vary depending on that absolute amount of concurrency available.</p> <p>Tip</p> <p>If you plan engaging in parallel programming using MPI, this book may prove useful: Parallel Programming with MPI. Peter Pacheo. Morgan Kaufmann. 1996.</p>"}, {"location": "multi_job_submission/", "title": "Multi-job submission", "text": "<p>A frequent occurring characteristic of scientific computation is their focus on data intensive processing. A typical example is the iterative evaluation of a program over different input parameter values, often referred to as a \"parameter sweep\". A Parameter Sweep runs a job a specified number of times, as if we sweep the parameter values through a user defined range.</p> <p>Users then often want to submit a large numbers of jobs based on the same job script but with (i) slightly different parameters settings or with (ii) different input files.</p> <p>These parameter values can have many forms, we can think about a range (e.g., from 1 to 100), or the parameters can be stored line by line in a comma-separated file. The users want to run their job once for each instance of the parameter values.</p> <p>One option could be to launch a lot of separate individual small jobs (one for each parameter) on the cluster, but this is not a good idea. The cluster scheduler isn't meant to deal with tons of small jobs. Those huge amounts of small jobs will create a lot of overhead, and can slow down the whole cluster. It would be better to bundle those jobs in larger sets. In TORQUE, an experimental feature known as \"job arrays\" existed to allow the creation of multiple jobs with one qsub command, but is not supported by Moab, the current scheduler.</p> <p>The \"Worker framework\" has been developed to address this issue.</p> <p>It can handle many small jobs determined by:</p> parameter variations <p>i.e., many small jobs determined by a specific parameter set which is stored in a .csv (comma separated value) input file.</p> job arrays <p>i.e., each individual job got a unique numeric identifier.</p> <p>Both use cases often have a common root: the user wants to run a program with a large number of parameter settings, and the program does not allow for aggregation, i.e., it has to be run once for each instance of the parameter values.</p> <p>However, the Worker Framework's scope is wider: it can be used for any scenario that can be reduced to a MapReduce approach.1</p>"}, {"location": "multi_job_submission/#the-worker-framework-parameter-sweeps", "title": "The worker Framework: Parameter Sweeps", "text": "<p>First go to the right directory:</p> <pre><code>cd ~/examples/Multi-job-submission/par_sweep\n</code></pre> <p>Suppose the user wishes to run the \"weather\" program, which takes three parameters: a temperature, a pressure and a volume. A typical call of the program looks like:</p> <pre><code>$ ./weather -t 20 -p 1.05 -v 4.3\nT: 20  P: 1.05  V: 4.3\n</code></pre> <p>For the purpose of this exercise, the weather program is just a simple bash script, which prints the 3 variables to the standard output and waits a bit:</p> par_sweep/weather<pre><code>#!/bin/bash\n# Here you could do your calculations\necho \"T: $2  P: $4  V: $6\"\nsleep 100\n</code></pre> <p>A job script that would run this as a job for the first parameters (p01) would then look like:</p> par_sweep/weather_p01.pbs<pre><code>#!/bin/bash\n\n#PBS -l nodes=1:ppn=8\n#PBS -l walltime=01:00:00\n\ncd $PBS_O_WORKDIR\n./weather -t 20 -p 1.05 -v 4.3\n</code></pre> <p>When submitting this job, the calculation is performed or this particular instance of the parameters, i.e., temperature = 20, pressure = 1.05, and volume = 4.3.</p> <p>To submit the job, the user would use:</p> <p><pre><code> $ qsub weather_p01.pbs\n</code></pre> However, the user wants to run this program for many parameter instances, e.g., he wants to run the program on 100 instances of temperature, pressure and volume. The 100 parameter instances can be stored in a comma separated value file (.csv) that can be generated using a spreadsheet program such as Microsoft Excel or RDBMS or just by hand using any text editor (do not use a word processor such as Microsoft Word). The first few lines of the file \"data.csv\" would look like:</p> <pre><code>$ more data.csv\ntemperature, pressure, volume\n293, 1.0e5, 107\n294, 1.0e5, 106\n295, 1.0e5, 105\n296, 1.0e5, 104\n297, 1.0e5, 103\n...\n</code></pre> <p>It has to contain the names of the variables on the first line, followed by 100 parameter instances in the current example.</p> <p>In order to make our PBS generic, the PBS file can be modified as follows:</p> par_sweep/weather.pbs<pre><code>#!/bin/bash\n\n#PBS -l nodes=1:ppn=8\n#PBS -l walltime=04:00:00\n\ncd $PBS_O_WORKDIR\n./weather -t $temperature -p $pressure -v $volume\n\n# # This script is submitted to the cluster with the following 2 commands:\n# module load worker/1.6.13-iimpi-2023a\n# wsub -data data.csv -batch weather.pbs\n</code></pre> <p>Note that:</p> <ol> <li> <p>the parameter values 20, 1.05, 4.3 have been replaced by variables     $temperature, $pressure and $volume respectively, which were     being specified on the first line of the \"data.csv\" file;</p> </li> <li> <p>the number of processors per node has been increased to 8 (i.e.,     ppn=1 is replaced by ppn=8);</p> </li> <li> <p>the walltime has been increased to 4 hours (i.e., walltime=00:15:00     is replaced by walltime=04:00:00).</p> </li> </ol> <p>The walltime is calculated as follows: one calculation takes 15 minutes, so 100 calculations take 1500 minutes on one CPU. However, this job will use 8 CPUs, so the 100 calculations will be done in 1500/8 = 187.5 minutes, i.e., 4 hours to be on the safe side.</p> <p>The job can now be submitted as follows (to check which <code>worker</code> module to use, see subsection Using explicit version numbers):</p> <pre><code>$ module load worker/1.6.13-iimpi-2023a\n$ wsub -batch weather.pbs -data data.csv\ntotal number of work items: 41\n433253.leibniz\n</code></pre> <p>Note that the PBS file is the value of the -batch option. The weather program will now be run for all 100 parameter instances -- 8 concurrently -- until all computations are done. A computation for such a parameter instance is called a work item in Worker parlance.</p> <p>Warning</p> <p>When you attempt to submit a worker job on a non-default cluster, you might encounter an <code>Illegal instruction</code> error. In such cases, the solution is to use a different <code>module swap</code> command. For example, to submit a worker job to the <code>donphan</code> debug cluster from the login nodes, use:</p> <pre><code>module swap env/slurm/donphan\n</code></pre> <p>instead of</p> <p><pre><code>module swap cluster/donphan\n</code></pre> We recommend using a <code>module swap cluster</code> command after submitting the jobs. Additional information about this as well as more comprehensive details concerning the 'Illegal instruction' error can be accessed here.</p>"}, {"location": "multi_job_submission/#the-worker-framework-job-arrays", "title": "The Worker framework: Job arrays", "text": "<p>First go to the right directory:</p> <pre><code>cd ~/examples/Multi-job-submission/job_array\n</code></pre> <p>As a simple example, assume you have a serial program called myprog that you want to run on various input files input[1-100].</p> <p></p> <p>The following bash script would submit these jobs all one by one: <pre><code>#!/bin/bash\nfor i in `seq 1 100`; do\nqsub -o output $i -i input $i myprog.pbs\ndone\n</code></pre></p> <p>This, as said before, could be disturbing for the job scheduler.</p> <p>Alternatively, TORQUE provides a feature known as job arrays which allows the creation of multiple, similar jobs with only one qsub command. This feature introduced a new job naming convention that allows users either to reference the entire set of jobs as a unit or to reference one particular job from the set.</p> <p>Under TORQUE, the -t range option is used with qsub to specify a job array, where range is a range of numbers (e.g., 1-100 or 2,4-5,7).</p> <p>The details are</p> <ol> <li> <p>a job is submitted for each number in the range;</p> </li> <li> <p>individuals jobs are referenced as jobid-number, and the entire     array can be referenced as jobid for easy killing etc.; and</p> </li> <li> <p>each job has PBS_ARRAYID set to its number which allows the     script/program to specialise for that job</p> </li> </ol> <p>The job could have been submitted using:</p> <pre><code>qsub -t 1-100 my_prog.pbs\n</code></pre> <p>The effect was that rather than 1 job, the user would actually submit 100 jobs to the queue system. This was a popular feature of TORQUE, but as this technique puts quite a burden on the scheduler, it is not supported by Moab (the current job scheduler).</p> <p>To support those users who used the feature and since it offers a convenient workflow, the \"worker framework\" implements the idea of \"job arrays\" in its own way.</p> <p>A typical job script for use with job arrays would look like this:</p> job_array/job_array.pbs<pre><code>#!/bin/bash -l\n#PBS -l nodes=1:ppn=1\n#PBS -l walltime=00:15:00\ncd $PBS_O_WORKDIR\nINPUT_FILE=\"input_${PBS_ARRAYID}.dat\"\nOUTPUT_FILE=\"output_${PBS_ARRAYID}.dat\"\nmy_prog -input ${INPUT_FILE}  -output ${OUTPUT_FILE}\n</code></pre> <p>In our specific example, we have prefabricated 100 input files in the \"./input\" subdirectory. Each of those files contains a number of parameters for the \"test_set\" program, which will perform some tests with those parameters.</p> <p>Input for the program is stored in files with names such as input_1.dat, input_2.dat, ..., input_100.dat in the ./input subdirectory.</p> <pre><code>$ ls ./input\n...\n$ more ./input/input_99.dat\nThis is input file \\#99\nParameter #1 = 99\nParameter #2 = 25.67\nParameter #3 = Batch\nParameter #4 = 0x562867\n</code></pre> <p>For the sole purpose of this exercise, we have provided a short \"test_set\" program, which reads the \"input\" files and just copies them into a corresponding output file. We even add a few lines to each output file. The corresponding output computed by our \"test_set\" program will be written to the \"./output\" directory in output_1.dat, output_2.dat, ..., output_100.dat. files.</p> job_array/test_set<pre><code>#!/bin/bash\n\n# Check if the output Directory exists\nif [ ! -d \"./output\" ] ; then\nmkdir ./output\nfi\n\n#   Here you could do your calculations...\necho \"This is Job_array #\" $1\necho \"Input File : \" $3\necho \"Output File: \" $5\ncat ./input/$3 | sed -e \"s/input/output/g\" | grep -v \"Parameter\" &gt; ./output/$5\necho \"Calculations done, no results\" &gt;&gt; ./output/$5\n</code></pre> <p>Using the \"worker framework\", a feature akin to job arrays can be used with minimal modifications to the job script:</p> job_array/test_set.pbs<pre><code>#!/bin/bash -l\n#PBS -l nodes=1:ppn=8\n#PBS -l walltime=04:00:00\ncd $PBS_O_WORKDIR\nINPUT_FILE=\"input_${PBS_ARRAYID}.dat\"\nOUTPUT_FILE=\"output_${PBS_ARRAYID}.dat\"\n./test_set ${PBS_ARRAYID} -input ${INPUT_FILE}  -output ${OUTPUT_FILE}\n</code></pre> <p>Note that</p> <ol> <li> <p>the number of CPUs is increased to 8 (ppn=1 is replaced by ppn=8);     and</p> </li> <li> <p>the walltime has been modified (walltime=00:15:00 is replaced by     walltime=04:00:00).</p> </li> </ol> <p>The job is now submitted as follows:</p> <pre><code>$ module load worker/1.6.13-iimpi-2023a\n$ wsub -t 1-100 -batch test_set.pbs\ntotal number of work items: 100\n433253.leibniz\n</code></pre> <p>The \"test_set\" program will now be run for all 100 input files -- 8 concurrently -- until all computations are done. Again, a computation for an individual input file, or, equivalently, an array id, is called a work item in Worker speak.</p> <p>Note that in contrast to TORQUE job arrays, a worker job array only submits a single job.</p> <pre><code>$ qstat\nJob id          Name          User      Time   Use S Queue\n--------------- ------------- --------- ---- ----- - -----\n433253.leibniz  test_set.pbs  vsc20167          0 Q\n\nAnd you can now check the generated output files:\n$ more ./output/output_99.dat\nThis is output file #99\nCalculations done, no results\n</code></pre>"}, {"location": "multi_job_submission/#mapreduce-prologues-and-epilogue", "title": "MapReduce: prologues and epilogue", "text": "<p>Often, an embarrassingly parallel computation can be abstracted to three simple steps:</p> <ol> <li> <p>a preparation phase in which the data is split up into smaller, more     manageable chunks;</p> </li> <li> <p>on these chunks, the same algorithm is applied independently (these     are the work items); and</p> </li> <li> <p>the results of the computations on those chunks are aggregated into,     e.g., a statistical description of some sort.</p> </li> </ol> <p></p> <p>The Worker framework directly supports this scenario by using a prologue (pre-processing) and an epilogue (post-processing). The former is executed just once before work is started on the work items, the latter is executed just once after the work on all work items has finished. Technically, the master, i.e., the process that is responsible for dispatching work and logging progress, executes the prologue and epilogue.</p> <pre><code>cd ~/examples/Multi-job-submission/map_reduce\n</code></pre> <p>The script \"pre.sh\" prepares the data by creating 100 different input-files, and the script \"post.sh\" aggregates (concatenates) the data.</p> <p>First study the scripts:</p> map_reduce/pre.sh<pre><code>#!/bin/bash\n\n# Check if the input Directory exists\nif [ ! -d \"./input\" ] ; then\nmkdir ./input\nfi\n\n# Just generate all dummy input files\nfor i in {1..100}; do\necho \"This is input file #$i\" &gt;  ./input/input_$i.dat echo \"Parameter #1 = $i\" &gt;&gt;  ./input/input_$i.dat echo \"Parameter #2 = 25.67\" &gt;&gt;  ./input/input_$i.dat\n  echo \"Parameter #3 = Batch\" &gt;&gt;  ./input/input_$i.dat\n  echo \"Parameter #4 = 0x562867\" &gt;&gt;  ./input/input_$i.dat\ndone\n</code></pre> map_reduce/post.sh<pre><code>#!/bin/bash\n\n# Check if the input Directory exists\nif [ ! -d \"./output\" ] ; then\necho \"The output directory does not exist!\"\nexit\nfi\n\n# Just concatenate all output files\ntouch all_output.txt\nfor i in {1..100}; do\ncat ./output/output_$i.dat &gt;&gt; all_output.txt\ndone\n</code></pre> <p>Then one can submit a MapReduce style job as follows:</p> <pre><code>$ wsub -prolog pre.sh -batch test_set.pbs -epilog post.sh -t 1-100\ntotal number of work items: 100\n433253.leibniz\n$ cat all_output.txt\n...\n$ rm -r -f ./output/\n</code></pre> <p>Note that the time taken for executing the prologue and the epilogue should be added to the job's total walltime.</p>"}, {"location": "multi_job_submission/#some-more-on-the-worker-framework", "title": "Some more on the Worker Framework", "text": ""}, {"location": "multi_job_submission/#using-worker-efficiently", "title": "Using Worker efficiently", "text": "<p>The \"Worker Framework\" is implemented using MPI, so it is not restricted to a single compute nodes, it scales well to multiple nodes. However, remember that jobs requesting a large number of nodes typically spend quite some time in the queue.</p> <p>The \"Worker Framework\" will be effective when</p> <ol> <li> <p>work items, i.e., individual computations, are neither too short,     nor too long (i.e., from a few minutes to a few hours); and,</p> </li> <li> <p>when the number of work items is larger than the number of CPUs     involved in the job (e.g., more than 30 for 8 CPUs).</p> </li> </ol>"}, {"location": "multi_job_submission/#monitoring-a-worker-job", "title": "Monitoring a worker job", "text": "<p>Since a Worker job will typically run for several hours, it may be reassuring to monitor its progress. Worker keeps a log of its activity in the directory where the job was submitted. The log's name is derived from the job's name and the job's ID, i.e., it has the form <code>&lt;jobname&gt;.log&lt;jobid&gt;</code>. For the running example, this could be <code>run.pbs.log433253.leibniz</code>, assuming the job's ID is 433253.leibniz. To keep an eye on the progress, one can use:</p> <pre><code>tail -f run.pbs.log433253.leibniz\n</code></pre> <p>Alternatively, <code>wsummarize</code>, a Worker command that summarises a log file, can be used:</p> <pre><code>watch -n 60 wsummarize run.pbs.log433253.leibniz\n</code></pre> <p>This will summarise the log file every 60 seconds.</p>"}, {"location": "multi_job_submission/#time-limits-for-work-items", "title": "Time limits for work items", "text": "<p>Sometimes, the execution of a work item takes longer than expected, or worse, some work items get stuck in an infinite loop. This situation is unfortunate, since it implies that work items that could successfully execute are not even started. Again, the Worker framework offers a simple and yet versatile solution. If we want to limit the execution of each work item to at most 20 minutes, this can be accomplished by modifying the script of the running example. <pre><code>#!/bin/bash -l\n#PBS -l nodes=1:ppn=8\n#PBS -l walltime=04:00:00\nmodule load timedrun/1.0\ncd $PBS_O_WORKDIR\ntimedrun -t 00:20:00 weather -t $temperature  -p $pressure  -v $volume\n</code></pre></p> <p>Note that it is trivial to set individual time constraints for work items by introducing a parameter, and including the values of the latter in the CSV file, along with those for the temperature, pressure and volume.</p> <p>Also note that \"timedrun\" is in fact offered in a module of its own, so it can be used outside the Worker framework as well.</p>"}, {"location": "multi_job_submission/#resuming-a-worker-job", "title": "Resuming a Worker job", "text": "<p>Unfortunately, walltime is sometimes underestimated. When using the Worker framework, this implies that not all work items will have been processed. Worker makes it very easy to resume such a job without having to figure out which work items did complete successfully, and which remain to be computed. Suppose the job that did not complete all its work items had ID \"445948\".</p> <pre><code>wresume -jobid 433253.leibniz\n</code></pre> <p>This will submit a new job that will start to work on the work items that were not done yet. Note that it is possible to change almost all job parameters when resuming, specifically the requested resources such as the number of cores and the walltime.</p> <pre><code>wresume -l walltime=1:30:00 -jobid 433253.leibniz\n</code></pre> <p>Work items may fail to complete successfully for a variety of reasons, e.g., a data file that is missing, a (minor) programming error, etc. Upon resuming a job, the work items that failed are considered to be done, so resuming a job will only execute work items that did not terminate either successfully, or reporting a failure. It is also possible to retry work items that failed (preferably after the glitch why they failed was fixed).</p> <pre><code>wresume -jobid 433253.leibniz -retry\n</code></pre> <p>By default, a job's prologue is not executed when it is resumed, while its epilogue is. \"wresume\" has options to modify this default behaviour.</p>"}, {"location": "multi_job_submission/#further-information", "title": "Further information", "text": "<p>This how-to introduces only Worker's basic features. The wsub command has some usage information that is printed when the -help option is specified:</p> <pre><code>$ wsub -help\n### usage: wsub  -batch &amp;lt;batch-file&amp;gt;          \n#                [-data &amp;lt;data-files&amp;gt;]         \n#                [-prolog &amp;lt;prolog-file&amp;gt;]      \n#                [-epilog &amp;lt;epilog-file&amp;gt;]      \n#                [-log &amp;lt;log-file&amp;gt;]            \n#                [-mpiverbose]                \n#                [-dryrun] [-verbose]         \n#                [-quiet] [-help]             \n#                [-t &amp;lt;array-req&amp;gt;]             \n#                [&amp;lt;pbs-qsub-options&amp;gt;]\n#\n#   -batch &amp;lt;batch-file&amp;gt;   : batch file template, containing variables to be\n#                           replaced with data from the data file(s) or the\n#                           PBS array request option\n#   -data &amp;lt;data-files&amp;gt;    : comma-separated list of data files (default CSV\n#                           files) used to provide the data for the work\n#                           items\n#   -prolog &amp;lt;prolog-file&amp;gt; : prolog script to be executed before any of the\n#                           work items are executed\n#   -epilog &amp;lt;epilog-file&amp;gt; : epilog script to be executed after all the work\n#                           items are executed\n#   -mpiverbose           : pass verbose flag to the underlying MPI program\n#   -verbose              : feedback information is written to standard error\n#   -dryrun               : run without actually submitting the job, useful\n#   -quiet                : don't show information\n#   -help                 : print this help message\n#   -t &amp;lt;array-req&amp;gt;        : qsub's PBS array request options, e.g., 1-10\n#   &amp;lt;pbs-qsub-options&amp;gt;    : options passed on to the queue submission\n#                           command\n</code></pre>"}, {"location": "multi_job_submission/#troubleshooting", "title": "Troubleshooting", "text": ""}, {"location": "multi_job_submission/#error-an-orte-daemon-has-unexpectedly-failed-after-launch-and-before-communicating-back-to-mpirun", "title": "Error: An ORTE daemon has unexpectedly failed after launch and before communicating back to mpirun", "text": "<p>When submitting a Worker job, you might encounter the following error:  <code>An ORTE daemon has unexpectedly failed after launch and before communicating back to mpirun</code>. This error can occur when the foss toolchain version of worker is loaded. Instead, try loading an iimpi toolchain version of worker.</p> <p>to check for the available versions of worker, use the following command:</p> <pre><code>$ module avail worker\n</code></pre> <ol> <li> <p>MapReduce: 'Map' refers to the map pattern in which every item in a collection is mapped onto a new value by applying a given function, while \"reduce\" refers to the reduction pattern which condenses or reduces a collection of previously computed results to a single value.\u00a0\u21a9</p> </li> </ol>"}, {"location": "mympirun/", "title": "Mympirun", "text": "<p><code>mympirun</code> is a tool to make it easier for users of HPC clusters to run MPI programs with good performance. We strongly recommend to use <code>mympirun</code> instead of <code>impirun</code>.</p> <p>In this chapter, we give a high-level overview. For a more detailed description of all options, see the vsc-mympirun README.</p>"}, {"location": "mympirun/#basic-usage", "title": "Basic usage", "text": "<p>Before using <code>mympirun</code>, we first need to load its module:</p> <pre><code>module load vsc-mympirun\n</code></pre> <p>As an exception, we don't specify a version here. The reason is that we want to ensure that the latest version of the <code>mympirun</code> script is always used, since it may include important bug fixes or improvements.</p> <p>The most basic form of using <code>mympirun</code> is <code>mympirun [mympirun options] your_program [your_program options]</code>.</p> <p>For example, to run a program named <code>example</code> and give it a single argument (<code>5</code>), we can run it with <code>mympirun example 5</code>.</p>"}, {"location": "mympirun/#controlling-number-of-processes", "title": "Controlling number of processes", "text": "<p>There are four options you can choose from to control the number of processes <code>mympirun</code> will start. In the following example, the program <code>mpi_hello</code> prints a single line: <code>Hello world from processor &lt;node&gt; ...</code> (the sourcecode of <code>mpi_hello</code> is available in the vsc-mympirun repository).</p> <p>By default, <code>mympirun</code> starts one process per core on every node you assigned. So if you assigned 2 nodes with 16 cores each, <code>mympirun</code> will start 2 . 16 = 32 test processes in total.</p>"}, {"location": "mympirun/#-hybrid-h", "title": "<code>--hybrid</code>/<code>-h</code>", "text": "<p>This is the most commonly used option for controlling the number of processing.</p> <p>The <code>--hybrid</code> option requires a positive number. This number specifies the number of processes started on each available physical node. It will ignore the number of available cores per node.</p> <pre><code>$ echo $PBS_NUM_NODES\n2\n$ mympirun --hybrid 2 ./mpihello\nHello world from processor node3400.doduo.os, rank 1 out of 4 processors \nHello world from processor node3401.doduo.os, rank 3 out of 4 processors \nHello world from processor node3401.doduo.os, rank 2 out of 4 processors \nHello world from processor node3400.doduo.os, rank 0 out of 4 processors\n</code></pre>"}, {"location": "mympirun/#other-options", "title": "Other options", "text": "<p>There's also <code>--universe</code>, which sets the exact amount of processes started by <code>mympirun</code>; <code>--double</code>, which uses double the amount of processes it normally would; and <code>--multi</code> that does the same as <code>--double</code>, but takes a multiplier (instead of the implied factor 2 with <code>--double</code>).</p> <p>See vsc-mympirun README for a detailed explanation of these options.</p>"}, {"location": "mympirun/#dry-run", "title": "Dry run", "text": "<p>You can do a so-called \"dry run\", which doesn't have any side-effects, but just prints the command that <code>mympirun</code> would execute. You enable this with the <code>--dry-run</code> flag:</p> <pre><code>$ mympirun --dry-run ./mpi_hello\nmpirun ... -genv I_MPI_FABRICS shm:dapl ... -np 16 ... ./mpi_hello\n</code></pre>"}, {"location": "openFOAM/", "title": "OpenFOAM", "text": "<p>In this chapter, we outline best practices for using the centrally provided OpenFOAM installations on the VSC UAntwerpen-HPC infrastructure.</p>"}, {"location": "openFOAM/#different-openfoam-releases", "title": "Different OpenFOAM releases", "text": "<p>There are currently three different sets of versions of OpenFOAM available, each with its own versioning scheme:</p> <ul> <li> <p>OpenFOAM versions released via http://openfoam.com: <code>v3.0+</code>,     <code>v1706</code></p> <ul> <li>see also http://openfoam.com/history/</li> </ul> </li> <li> <p>OpenFOAM versions released via https://openfoam.org: <code>v4.1</code>,     <code>v5.0</code></p> <ul> <li>see also https://openfoam.org/download/history/</li> </ul> </li> </ul> <p>Make sure you know which flavor of OpenFOAM you want to use, since there are important differences between the different versions w.r.t. features. If the OpenFOAM version you need is not available yet, see I want to use software that is not available on the clusters yet.</p>"}, {"location": "openFOAM/#documentation-training-material", "title": "Documentation &amp; training material", "text": "<p>The best practices outlined here focus specifically on the use of OpenFOAM on the VSC UAntwerpen-HPC infrastructure. As such, they are intended to augment the existing OpenFOAM documentation rather than replace it. For more general information on using OpenFOAM, please refer to:</p> <ul> <li> <p>OpenFOAM websites:</p> <ul> <li> <p>https://openfoam.com</p> </li> <li> <p>https://openfoam.org</p> </li> </ul> </li> <li> <p>OpenFOAM user guides:</p> <ul> <li> <p>https://www.openfoam.com/documentation/user-guide</p> </li> <li> <p>https://cfd.direct/openfoam/user-guide/</p> </li> </ul> </li> <li> <p>OpenFOAM C++ source code guide: https://cpp.openfoam.org</p> </li> <li> <p>tutorials: https://wiki.openfoam.com/Tutorials</p> </li> <li> <p>recordings of \"Introduction to OpenFOAM\" training session at     UGent (May 2016):     https://www.youtube.com/playlist?list=PLqxhJj6bcnY9RoIgzeF6xDh5L9bbeK3BL</p> </li> </ul> <p>Other useful OpenFOAM documentation:</p> <ul> <li>https://github.com/ParticulateFlow/OSCCAR-doc/blob/master/openFoamUserManual_PFM.pdf</li> </ul>"}, {"location": "openFOAM/#preparing-the-environment", "title": "Preparing the environment", "text": "<p>To prepare the environment of your shell session or job for using OpenFOAM, there are a couple of things to take into account.</p>"}, {"location": "openFOAM/#picking-and-loading-an-openfoam-module", "title": "Picking and loading an <code>OpenFOAM</code> module", "text": "<p>First of all, you need to pick and load one of the available <code>OpenFOAM</code> modules. To get an overview of the available modules, run '<code>module avail OpenFOAM</code>'. For example:</p> <pre><code>$ module avail OpenFOAM\n\n-------------------- /apps/gent/RHEL9/zen4-ib/modules/all ---------------------\n   OpenFOAM-Extend/4.1-20210705-foss-2023a-Python-2.7.18\n   OpenFOAM/v2312-foss-2023a\n   OpenFOAM/10-foss-2023a\n   OpenFOAM/11-foss-2023a\n   OpenFOAM/12-foss-2023a                                (D)\n\n  Where:\n   D:  Default Module\n</code></pre> <p>To pick a module, take into account the differences between the different OpenFOAM versions w.r.t. features and API (see also Different OpenFOAM releases). If multiple modules are available that fulfill your requirements, give preference to those providing a more recent OpenFOAM version, and to the ones that were installed with a more recent compiler toolchain; for example, prefer a module that includes <code>intel-2025b</code> in its name over one that includes <code>intel-2025a</code>.</p> <p>To prepare your environment for using OpenFOAM, load the <code>OpenFOAM</code> module you have picked; for example:</p> <pre><code>module load OpenFOAM/11-foss-2023a\n</code></pre>"}, {"location": "openFOAM/#sourcing-the-foam_bash-script", "title": "Sourcing the <code>$FOAM_BASH</code> script", "text": "<p>OpenFOAM provides a script that you should <code>source</code> to further prepare the environment. This script will define some additional environment variables that are required to use OpenFOAM. The <code>OpenFOAM</code> modules define an environment variable named <code>FOAM_BASH</code> that specifies the location to this script. Assuming you are using <code>bash</code> in your shell session or job script, you should always run the following command after loading an <code>OpenFOAM</code> module:</p> <pre><code>source $FOAM_BASH\n</code></pre>"}, {"location": "openFOAM/#defining-utility-functions-used-in-tutorial-cases", "title": "Defining utility functions used in tutorial cases", "text": "<p>If you would like to use the <code>getApplication</code>, <code>runApplication</code>, <code>runParallel</code>, <code>cloneCase</code> and/or <code>compileApplication</code> functions that are used in OpenFOAM tutorials, you also need to <code>source</code> the <code>RunFunctions</code> script:</p> <pre><code>source $WM_PROJECT_DIR/bin/tools/RunFunctions\n</code></pre> <p>Note that this needs to be done after sourcing <code>$FOAM_BASH</code> to make sure <code>$WM_PROJECT_DIR</code> is defined.</p>"}, {"location": "openFOAM/#dealing-with-floating-point-errors", "title": "Dealing with floating-point errors", "text": "<p>If you are seeing <code>Floating Point Exception</code> errors, you can undefine the <code>$FOAM_SIGFPE</code> environment variable that is defined by the <code>$FOAM_BASH</code> script as follows:</p> <pre><code>unset $FOAM_SIGFPE\n</code></pre> <p>Note that this only prevents OpenFOAM from propagating floating point exceptions, which then results in terminating the simulation. However, it does not prevent that illegal operations (like a division by zero) are being executed; if <code>NaN</code> values appear in your results, floating point errors are occurring.</p> <p>As such, you should not use this in production runs. Instead, you should track down the root cause of the floating point errors, and try to prevent them from occurring at all.</p>"}, {"location": "openFOAM/#openfoam-workflow", "title": "OpenFOAM workflow", "text": "<p>The general workflow for OpenFOAM consists of multiple steps. Prior to running the actual simulation, some pre-processing needs to be done:</p> <ul> <li> <p>generate the mesh;</p> </li> <li> <p>decompose the domain into subdomains using <code>decomposePar</code> (only for     parallel OpenFOAM simulations);</p> </li> </ul> <p>After running the simulation, some post-processing steps are typically performed:</p> <ul> <li> <p>reassemble the decomposed domain using <code>reconstructPar</code> (only for     parallel OpenFOAM simulations, and optional since some     postprocessing can also be done on decomposed cases);</p> </li> <li> <p>evaluate or further process the simulation results, either visually     using ParaView (for example, via the <code>paraFoam</code> tool; use     <code>paraFoam -builtin</code> for decomposed cases) or using command-line     tools like <code>postProcess</code>; see also     https://cfd.direct/openfoam/user-guide/postprocessing.</p> </li> </ul> <p>Depending on the size of the domain and the desired format of the results, these pre- and post-processing steps can be run either before/after the job running the actual simulation, either on the HPC infrastructure or elsewhere, or as a part of the job that runs the OpenFOAM simulation itself.</p> <p>Do make sure you are using the same OpenFOAM version in each of the steps. Meshing can be done sequentially (i.e., on a single core) using for example <code>blockMesh</code>, or in parallel using more advanced meshing tools like <code>snappyHexMesh</code>, which is highly recommended for large cases. For more details, see https://cfd.direct/openfoam/user-guide/mesh/.</p> <p>One important aspect to keep in mind for 'offline' pre-processing is that the domain decomposition needs to match the number of processor cores that are used for the actual simulation, see also Domain decomposition and number of processor cores.</p> <p>For post-processing you can either download the simulation results to a local workstation, or do the post-processing (interactively) on the HPC infrastructure, for example on the login nodes or using an interactive session on a workernode. This may be interesting to avoid the overhead of downloading the results locally.</p>"}, {"location": "openFOAM/#running-openfoam-in-parallel", "title": "Running OpenFOAM in parallel", "text": "<p>For general information on running OpenFOAM in parallel, see https://cfd.direct/openfoam/user-guide/running-applications-parallel/.</p>"}, {"location": "openFOAM/#the-parallel-option", "title": "The <code>-parallel</code> option", "text": "<p>When running OpenFOAM in parallel, do not forget to specify the <code>-parallel</code> option, to avoid running the same OpenFOAM simulation $N$ times, rather than running it once using $N$ processor cores.</p> <p>You can check whether OpenFOAM was run in parallel in the output of the main command: the OpenFOAM header text should only be included once in the output, and it should specify a value different than '<code>1</code>' in the <code>nProcs</code> field. Note that most pre- and post-processing utilities like <code>blockMesh</code>, <code>decomposePar</code> and <code>reconstructPar</code> can not be run in parallel.</p>"}, {"location": "openFOAM/#using-mympirun", "title": "Using <code>mympirun</code>", "text": "<p>It is highly recommended to use the <code>mympirun</code> command when running parallel OpenFOAM simulations rather than the standard <code>mpirun</code> command; see Mympiprun for more information on <code>mympirun</code>.</p> <p>See Basic usage for how to get started with <code>mympirun</code>.</p> <p>To pass down the environment variables required to run OpenFOAM (which were defined by the <code>$FOAM_BASH</code> script, see Preparing the environment) to each of the MPI processes used in a parallel OpenFOAM execution, the <code>$MYMPIRUN_VARIABLESPREFIX</code> environment variable must be defined as follows, prior to running the OpenFOAM simulation with <code>mympirun</code>:</p> <pre><code>export MYMPIRUN_VARIABLESPREFIX=WM_PROJECT,FOAM,MPI\n</code></pre> <p>Whenever you are instructed to use a command like <code>mpirun -np &lt;N&gt; ...</code>, use <code>mympirun ...</code> instead; <code>mympirun</code> will automatically detect the number of processor cores that are available (see also Controlling number of processes).</p>"}, {"location": "openFOAM/#domain-decomposition-and-number-of-processor-cores", "title": "Domain decomposition and number of processor cores", "text": "<p>To run OpenFOAM in parallel, you must decompose the domain into multiple subdomains. Each subdomain will be processed by OpenFOAM on one processor core.</p> <p>Since <code>mympirun</code> will automatically use all available cores, you need to make sure that the number of subdomains matches the number of processor cores that will be used by <code>mympirun</code>. If not, you may run into an error message like:</p> <pre><code>number of processor directories = 4 is not equal to the number of processors = 16\n</code></pre> <p>In this case, the case was decomposed in 4 subdomains, while the OpenFOAM simulation was started with 16 processes through <code>mympirun</code>. To match the number of subdomains and the number of processor cores used by <code>mympirun</code>, you should either:</p> <ul> <li> <p>adjust the value for <code>numberOfSubdomains</code> in     <code>system/decomposeParDict</code> (and adjust the value for <code>n</code> accordingly     in the domain decomposition coefficients), and run <code>decomposePar</code>     again; or</p> </li> <li> <p>submit your job requesting exactly the same number of processor     cores as there are subdomains (see the number of <code>processor*</code>     directories that were created by <code>decomposePar</code>)</p> </li> </ul> <p>See Controlling number of processes to control the number of process <code>mympirun</code> will start.</p> <p>This is interesting if you require more memory per core than is available by default. Note that the decomposition method being used (which is specified in <code>system/decomposeParDict</code>) has significant impact on the performance of a parallel OpenFOAM simulation. Good decomposition methods (like <code>metis</code> or <code>scotch</code>) try to limit communication overhead by minimising the number of processor boundaries.</p> <p>To visualise the processor domains, use the following command:</p> <pre><code>mympirun foamToVTK -parallel -constant -time 0 -excludePatches '(\".*.\")'\n</code></pre> <p>and then load the VTK files generated in the <code>VTK</code> folder into ParaView.</p>"}, {"location": "openFOAM/#running-openfoam-on-a-shared-filesystem", "title": "Running OpenFOAM on a shared filesystem", "text": "<p>OpenFOAM is known to significantly stress shared filesystems, since a lot of (small) files are generated during an OpenFOAM simulation. Shared filesystems are typically optimised for dealing with (a small number of) large files, and are usually a poor match for workloads that involve a (very) large number of small files.</p> <p>Take into account the following guidelines for your OpenFOAM jobs, which all relate to input parameters for the OpenFOAM simulation that you can specify in <code>system/controlDict</code> (see also https://cfd.direct/openfoam/user-guide/controldict).</p> <ul> <li> <p>instruct OpenFOAM to write out results at a reasonable frequency, certainly not for every single time step}; you can control this using the <code>writeControl</code>, <code>writeInterval</code>, etc.\u00a0keywords;</p> </li> <li> <p>consider only retaining results for the last couple of time steps,     see the <code>purgeWrite</code> keyword;</p> </li> <li> <p>consider writing results for only part of the domain (e.g., a line     of plane) rather than the entire domain;</p> </li> <li> <p>if you do not plan to change the parameters of the OpenFOAM     simulation while it is running, set runTimeModifiable to false to avoid that OpenFOAM re-reads each     of the <code>system/*Dict</code> files at every time step;</p> </li> <li> <p>if the results per individual time step are large, consider setting     <code>writeCompression</code> to <code>true</code>;</p> </li> </ul> <p>For modest OpenFOAM simulations where a single workernode suffices, consider using the local disk of the workernode as working directory (accessible via <code>$VSC_SCRATCH_NODE</code>), rather than the shared <code>$VSC_SCRATCH</code> filesystem. **Certainly do not use a subdirectory in <code>$VSC_HOME</code> or <code>$VSC_DATA</code>, since these shared filesystems are too slow for these types of workloads.</p> <p>These guidelines are especially important for large-scale OpenFOAM simulations that involve more than a couple of dozen of processor cores.</p>"}, {"location": "openFOAM/#using-own-solvers-with-openfoam", "title": "Using own solvers with OpenFOAM", "text": "<p>See https://cfd.direct/openfoam/user-guide/compiling-applications/.</p>"}, {"location": "openFOAM/#example-openfoam-job-script", "title": "Example OpenFOAM job script", "text": "<p>Example job script for <code>damBreak</code> OpenFOAM tutorial (see also https://cfd.direct/openfoam/user-guide/dambreak):</p> OpenFOAM_damBreak.sh<pre><code>#!/bin/bash\n#PBS -l walltime=1:0:0\n#PBS -l nodes=1:ppn=4\n# check for more recent OpenFOAM modules with 'module avail OpenFOAM'\nmodule load OpenFOAM/6-intel-2018a\nsource $FOAM_BASH\n# purposely not specifying a particular version to use most recent mympirun\nmodule load vsc-mympirun\n# let mympirun pass down relevant environment variables to MPI processes\nexport MYMPIRUN_VARIABLESPREFIX=WM_PROJECT,FOAM,MPI\n# set up working directory\n# (uncomment one line defining $WORKDIR below)\n#export WORKDIR=$VSC_SCRATCH/$PBS_JOBID  # for small multi-node jobs\n#export WORKDIR=$VSC_SCRATCH_ARCANINE/$PBS_JOBID  # for large multi-node jobs (not on available victini)\nexport WORKDIR=$VSC_SCRATCH_NODE/$PBS_JOBID  # for single-node jobs\nmkdir -p $WORKDIR\n# damBreak tutorial, see also https://cfd.direct/openfoam/user-guide/dambreak\ncp -r $FOAM_TUTORIALS/multiphase/interFoam/laminar/damBreak/damBreak $WORKDIR\ncd $WORKDIR/damBreak\necho \"working directory: $PWD\"\n# pre-processing: generate mesh\necho \"start blockMesh: $(date)\"\nblockMesh &amp;&gt; blockMesh.out\n# pre-processing: decompose domain for parallel processing\necho \"start decomposePar: $(date)\"\ndecomposePar &amp;&gt; decomposePar.out\n# run OpenFOAM simulation in parallel\n# note:\n#  * the -parallel option is strictly required to actually run in parallel!\n#    without it, the simulation is run N times on a single core...\n#  * mympirun will use all available cores in the job by default,\n#    you need to make sure this matches the number of subdomains!\necho \"start interFoam: $(date)\"\nmympirun --output=interFoam.out interFoam -parallel\n# post-processing: reassemble decomposed domain\necho \"start reconstructPar: $(date)\"\nreconstructPar &amp;&gt; reconstructPar.out\n# copy back results, i.e. all time step directories: 0, 0.05, ..., 1.0 and inputs\nexport RESULTS_DIR=$VSC_DATA/results/$PBS_JOBID\nmkdir -p $RESULTS_DIR\ncp -a *.out [0-9.]* constant system $RESULTS_DIR\necho \"results copied to $RESULTS_DIR at $(date)\"\n# clean up working directory\ncd $HOME\nrm -rf $WORKDIR\n</code></pre>"}, {"location": "program_examples/", "title": "Program examples", "text": "<p>If you have not done so already copy our examples to your home directory by running the following command: <pre><code> cp -r /apps/antwerpen/tutorials/Intro-HPC/examples ~/\n</code></pre></p> <p><code>~</code>(tilde) refers to your home directory, the directory you arrive by default when you login.</p> <p>Go to our examples: <pre><code>cd ~/examples/Program-examples\n</code></pre></p> <p>Here, we just have put together a number of examples for your convenience. We did an effort to put comments inside the source files, so the source code files are (should be) self-explanatory.</p> <ol> <li> <p>01_Python</p> </li> <li> <p>02_C_C++</p> </li> <li> <p>03_Matlab</p> </li> <li> <p>04_MPI_C</p> </li> <li> <p>05a_OMP_C</p> </li> <li> <p>05b_OMP_FORTRAN</p> </li> <li> <p>06_NWChem</p> </li> <li> <p>07_Wien2k</p> </li> <li> <p>08_Gaussian</p> </li> <li> <p>09_Fortran</p> </li> <li> <p>10_PQS</p> </li> </ol> <p>The above 2 OMP directories contain the following examples:</p> C Files Fortran Files Description omp_hello.c omp_hello.f Hello world omp_workshare1.c omp_workshare1.f Loop work-sharing omp_workshare2.c omp_workshare2.f Sections work-sharing omp_reduction.c omp_reduction.f Combined parallel loop reduction omp_orphan.c omp_orphan.f Orphaned parallel loop reduction omp_mm.c omp_mm.f Matrix multiply omp_getEnvInfo.c omp_getEnvInfo.f Get and print environment information omp_bug* omp_bug* Programs with bugs and their solution <p>Compile by any of the following commands:</p> Language Commands C: icc -openmp omp_hello.c -o hello pgcc -mp omp_hello.c -o hello gcc -fopenmp omp_hello.c -o hello Fortran: ifort -openmp omp_hello.f -o hello pgf90 -mp omp_hello.f -o hello gfortran -fopenmp omp_hello.f -o hello <p>Be invited to explore the examples.</p>"}, {"location": "python/", "title": "Python", "text": "<p>This page provides information on how to use Python on the HPC systems. It shows how to load Python modules and Python packages,  and how to run Python scripts interactively and using job scripts.</p>"}, {"location": "python/#python-modules", "title": "Python modules", "text": "<p>The HPC systems provide a number of Python modules that you can load into your environment. To see a list of available Python modules, you can run:</p> <pre><code>$ module avail Python/\n</code></pre> <p>For example, to load Python 3.11, you can run:</p> <pre><code>$ module load Python/3.11.5-GCCcore-13.2.0\n</code></pre> <p>This will load Python into your environment:</p> <pre><code>$ python --version\nPython 3.11.5\n</code></pre> <p>Tip</p> <p>To clear all loaded modules, you can run:</p> <pre><code>$ module purge\n</code></pre> <p>However, for recent Python modules, there are also companion modules that provide a bunch of Python packages from PyPI,  like <code>Python-bundle-PyPI</code>, <code>SciPy-bundle</code> (which includes numpy, pandas, ...), <code>matplotlib</code>, etc. Therefore, we recommend loading these modules instead of a standalone Python module.</p> <p>To check which versions of a python bundle are available, you can run </p> <pre><code>$ module avail &lt;bundle_name&gt;\n</code></pre> <p>You can view the list of included packages in a bundle by running </p> <pre><code>$ module show &lt;bundle_name&gt;\n</code></pre> <p>After loading the module, the available packages can also be consulted by running <code>pip list</code>.</p>"}, {"location": "python/#python-packages-as-modules", "title": "Python packages as modules", "text": "<p>Python packages can be divided into two categories: standard library packages and third-party packages. The standard library packages are included with Python and do not need to be installed separately. Third-party packages need to be installed before they can be used in your Python code.</p> <p>We cannot allow users to install packages into the system-wide Python installation. Instead, we provide a large number of Python packages as modules that can be loaded into your environment. Once loaded, you can use the packages in your Python code.</p>"}, {"location": "python/#finding-packages", "title": "Finding packages", "text": "<p>If you need a particular Python package that is not part of the standard library,  you can search for it using the <code>module avail</code> command.  For example, to search for the <code>beautifulsoup</code> package, you can run:</p> <pre><code>$ module avail beautifulsoup\nBeautifulSoup/4.10.0-GCCcore-10.3.0\n...\nBeautifulSoup/4.12.2-GCCcore-13.2.0 (D)\n</code></pre> <p>This will show you all available versions of the <code>beautifulsoup</code> package.</p> <p>Note</p> <p>Not all Python packages can be found by searching for the package name.  Some packages are installed as extensions of modules.  For example, <code>numpy</code>, <code>scipy</code> and <code>pandas</code> are part of the <code>SciPy-bundle</code> module.  You can use the following command to check which extensions are included in a module (if any):</p> <pre><code>module show &lt;module_name&gt;\n</code></pre> <p>If you cannot find a package, it could be that it is not available as a module. You can send us a software installation request,  or you can install the package in a Python virtual environment.</p>"}, {"location": "python/#loading-packages", "title": "Loading packages", "text": "<p>If your python script does not use any third-party packages, you only have to load a Python module. If you need to use a third-party package, you will need to load the corresponding module. Loading such a module will also load a Python module, so you do not need to load both.</p> <p>For example, loading the <code>SciPy-bundle</code> module will also load the Python module:</p> <pre><code>$ module load SciPy-bundle/2023.11-gfbf-2023b\n$ module list\nCurrently Loaded Modules:\n ...\n 21) Python/3.11.5-GCCcore-13.2.0\n ...\n 27) SciPy-bundle/2023.11-gfbf-2023b\n</code></pre>"}, {"location": "python/#example-running-python-scripts", "title": "Example: Running Python scripts", "text": "<p>There are multiple ways to run Python scripts on the HPC systems.  You can start an interactive session on a cluster and run your script manually, or you can submit a job using a job script.  This section will show you how to run Python scripts using both methods on the following example script:</p> script.py<pre><code>import numpy as np\n\nrandom_numbers = np.random.rand(5)\n\nprint(f\"Random numbers: {random_numbers}\")\n</code></pre> <p>First, we select a toolchain of the SciPy bundle module, which contains the <code>numpy</code> package, along with a Python module:</p> <pre><code>$ module avail SciPy-bundle\n</code></pre> <p>We will use the <code>SciPy-bundle/2023.11-gfbf-2023b</code> toolchain. Next, we decide on which cluster we want to run the script.  For this example, we will use the <code>donphan</code> cluster.</p> <p>To switch to the <code>donphan</code> cluster, we run:</p> <pre><code>$ module swap cluster/donphan\n</code></pre>"}, {"location": "python/#interactive-session", "title": "Interactive session", "text": "<p>To run the script interactively, we need to start an interactive session on the cluster (<code>donphan</code> in this case):</p> <pre><code>$ qsub -I\n</code></pre> <p>Once the interactive session is started, we can load the <code>SciPy-bundle</code> module and run the script:</p> <pre><code>$ module load SciPy-bundle/2023.11-gfbf-2023b\n</code></pre> <p>Now we can run the script:</p> <pre><code>$ python script.py\n</code></pre> <p>For more information on how to start an interactive session,  see the Interactive jobs page.</p>"}, {"location": "python/#job-script", "title": "Job script", "text": "<p>To run the script using a job script,  we need to create a job script that will load the <code>SciPy-bundle</code> module and run the script:</p> jobscript.pbs<pre><code>#!/bin/bash\n\n# Basic parameters\n#PBS -N python_job_example            ## Job name\n#PBS -l nodes=1:ppn=1                 ## 1 node, 1 processors per node\n#PBS -l walltime=01:00:00             ## Max time your job will run (no more than 72:00:00)\n\nmodule load SciPy-bundle/2023.11-gfbf-2023b   # Load the SciPy module, which includes the numpy package\ncd $PBS_O_WORKDIR                             # Change working directory to the location where the job was submitted\npython script.py                              # Run your Python script\n</code></pre> <p>To submit the job, run:</p> <pre><code>qsub jobscript.pbs\n</code></pre> <p>After some time, two files will be created in the directory where the job was submitted:  <code>python_job_example.o433253.leibniz</code> and <code>python_job_example.e433253.leibniz</code>, where 433253.leibniz is the id of your job. The <code>.o</code> file contains the output of the job.</p>"}, {"location": "python/#more-information", "title": "More information", "text": "<ul> <li>For more info on Python virtual environments, see the Setting up Python virtual environments page.</li> <li>To use Jupyter on the HPC systems, see the Jupyter page.</li> </ul>"}, {"location": "quick_reference_guide/", "title": "HPC Quick Reference Guide", "text": "<p>Remember to substitute the usernames, login nodes, file names, ...for your own.</p> Login Login <code>ssh vsc20167@login.hpc.uantwerpen.be</code> Where am I? <code>hostname</code> Copy to UAntwerpen-HPC <code>scp foo.txt vsc20167@login.hpc.uantwerpen.be:</code> Copy from UAntwerpen-HPC <code>scp vsc20167@login.hpc.uantwerpen.be:foo.txt</code> Setup ftp session <code>sftp vsc20167@login.hpc.uantwerpen.be</code> Modules List all available modules Module avail List loaded modules module list Load module module load example Unload module module unload example Unload all modules module purge Help on use of module module help Command Description <code>qsub script.pbs</code> Submit job with job script <code>script.pbs</code> <code>qstat 12345</code> Status of job with ID 12345 <code>showstart 12345</code> Possible start time of job with ID 12345 (not available everywhere) <code>checkjob 12345</code> Check job with ID 12345 (not available everywhere) <code>qstat -n 12345</code> Show compute node of job with ID 12345 <code>qdel 12345</code> Delete job with ID 12345 <code>qstat</code> Status of all your jobs <code>qstat -na</code> Detailed status of your jobs + a list of nodes they are running on <code>showq</code> Show all jobs on queue (not available everywhere) <code>qsub -I</code> Submit Interactive job Disk quota Check your disk quota <code>mmlsquota</code> Check your disk quota nice <code>show_quota.py</code> Disk usage in current directory (<code>.</code>) <code>du -h</code> Worker Framework Load worker module <code>module load worker/1.6.13-iimpi-2023a</code>  Don't forget to specify a version. To list available versions, use <code>module avail worker/</code> Submit parameter sweep <code>wsub -batch weather.pbs -data data.csv</code> Submit job array <code>wsub -t 1-100 -batch test_set.pbs</code> Submit job array with prolog and epilog <code>wsub -prolog pre.sh -batch test_set.pbs -epilog post.sh -t 1-100</code>"}, {"location": "r-packages/", "title": "R packages", "text": "<p>Note</p> <p>Please keep in mind that this is not general documentation about installing <code>R</code> packages, but specific information about  self-installed R packages at the UAntwerpen-HPC.</p> <p>The UAntwerpen-HPC contains different generations of CPUs, with different microarchitectures, that are not necessarily compatible with each other. Additionally, we have  multiple versions of <code>R</code> installed with different versions of toolchains, and by default, self-installed packages are installed in separate directories based only on <code>R</code> major and minor versions (only using <code>x.y</code> for R version <code>x.y.z</code>).</p> <p>In this way, you might use self-installed <code>R</code> packages on incompatible CPU microarchitectures and/or compiled with incompatible toolchains, or for a different major version of the operating system, which might lead to hangs or other types of errors.</p> <p>Since end of February 2025, we make sure that <code>R</code> packages that you install yourself will be installed in a directory that is specific to the operating system version, CPU microarchitecture, toolchain, and <code>R</code> version that is being used. The location of this directory by default is (by setting <code>$R_LIBS_USER</code> environment variable to) <code>$VSC_DATA/local_R_LIBS/$VSC_OS_LOCAL/$VSC_ARCH_LOCAL/&lt;R version&gt;-&lt;toolchain&gt;</code>.</p>"}, {"location": "r-packages/#controlling-the-location-for-self-installed-r-packages", "title": "Controlling the location for self-installed R packages", "text": "<p>If you would like to have another location (for example you are using a central location in your Virtual Organisation), you should set the environment variable <code>$R_LIBS_BASEDIR</code> to the desired location before you load any centrally installed <code>R</code> module. In this case, the location of the directory for self-installed <code>R</code> packages will be <code>$R_LIBS_BASEDIR/local_R_LIBS/$VSC_OS_LOCAL/$VSC_ARCH_LOCAL/&lt;R version&gt;-&lt;toolchain&gt;</code>. If this directory is not writable, you will still be able to use already installed <code>R</code> packages from that location, but you will not be able to install <code>R</code> packages  yourself.</p> <p>You can always check the default location(s) of <code>R</code> packages by issuing <code>.libPaths()</code> command in <code>R</code>. This command will show the package locations, ordered by their priorities. </p>"}, {"location": "r-packages/#missing-r-packages-intalled-before", "title": "Missing R packages intalled before", "text": "<p>Please be aware that if you have installed <code>R</code> packages yourself before end of February 2025, then you have to reinstall all of them. You might have to reinstall self installed <code>R</code> packages if you want to use them:</p> <ul> <li>on a different cluster</li> <li>with a different version of <code>R</code></li> <li>with an <code>R</code> compiled with a different version of toolchain</li> <li>if the operating system was changed/updated. </li> </ul>"}, {"location": "rhel9/", "title": "Migration to RHEL 9 operation system (Tier-2)", "text": "<p>Starting September 2024 we will gradually migrate the HPC-UGent Tier-2 clusters that are using RHEL 8 as operating system (OS) to RHEL 9 (Red Hat Enterprise Linux 9). This includes clusters <code>skitty</code>, <code>joltik</code>, <code>doduo</code>, <code>accelgor</code>, <code>donphan</code> and <code>gallade</code> (see also the infrastructure overview), as well as switching the Tier-2 login nodes to new ones running RHEL 9.</p>"}, {"location": "rhel9/#motivation", "title": "Motivation", "text": "<p>Migrating to RHEL 9 is done to bring all clusters in line with the most recent cluster that is already running RHEL 9 (<code>shinx</code>).</p> <p>This makes the maintenance of the HPC-UGent Tier-2 infrastructure significantly easier, since we only need to take into account a single operating system version going forward.</p> <p>It will also bring you the latest versions in operating system software, with more features, performance improvements, and enhanced security.</p>"}, {"location": "rhel9/#login_nodes_impact", "title": "Impact on the HPC-UGent Tier-2 login nodes", "text": "<p>As a general rule, the OS of the login node should match the OS of the cluster you are running on. To make this more transparent, you will be warned when loading a <code>cluster</code> module for a cluster than is running an OS that is different than that of the login node you are on.</p> <p>For example, on the current login nodes (<code>gligar07</code> + <code>gligar08</code>) which are still using RHEL 8, you will see a warning like: <pre><code>$ module swap cluster/shinx\n...\nWe advise you to log in to a RHEL 9 login node when using the shinx cluster.\nThe shinx cluster is using RHEL 9 as operating system,\nwhile the login node you are logged in to is using RHEL 8.\nTo avoid problems with testing installed software or submitting jobs,\nit is recommended to switch to a RHEL 9 login node by running 'ssh login9'.\n</code></pre></p> <p>Initially there will be only one RHEL 9 login node. As needed a second one will be added.</p> <p>When the default cluster (<code>doduo</code>) is migrated to RHEL 9 the corresponding login nodes will also become default when you log in via <code>login.hpc.ugent.be</code> When they are no longer needed the RHEL 8 login nodes will be shut down.</p>"}, {"location": "rhel9/#login_nodes_limits", "title": "User limits (CPU time, memory, ...)", "text": "<p>To encourage only using the login nodes as an entry point to the HPC-UGent infrastructure, user limits will be enforced on the RHEL 9 login nodes. This was already the case for the RHEL 8 login nodes, but the limits are a bit stricter now.</p> <p>This includes (per user):</p> <ul> <li>max. of 2 CPU cores in use</li> <li>max. 8 GB of memory in use</li> </ul> <p>For more intensive tasks you can use the interactive and debug clusters through the web portal.</p>"}, {"location": "rhel9/#software_impact", "title": "Impact on central software stack", "text": "<p>The migration to RHEL 8 as operating system should not impact your workflow, everything will basically be working as it did before (incl. job submission, etc.).</p> <p>However, there will be impact on the availability of software that is made available via modules.</p> <p>Software that was installed with an older compiler toolchain will no longer be available once the clusters have been updated to RHEL 9.</p> <p>This includes all software installations on top of a compiler toolchain that is older than:</p> <ul> <li><code>GCC(core)/12.3.0</code></li> <li><code>foss/2023a</code></li> <li><code>intel/2023a</code></li> <li><code>gompi/2023a</code></li> <li><code>iimpi/2023a</code></li> <li><code>gfbf/2023a</code></li> </ul> <p>(or another toolchain with a year-based version older than <code>2023a</code>)</p> <p>The <code>module</code> command will produce a clear warning when you are loading modules that are using a toolchain that will no longer be available after the cluster has been migrated to RHEL 9. For example:</p> <pre><code>foss/2022b:\n   ___________________________________\n  /  This module will soon no longer  \\\n  \\  be available on this cluster!    /\n   -----------------------------------\n         \\   ^__^\n          \\  (xx)\\_______\n             (__)\\       )\\/\\\n              U  ||----w |\n                 ||     ||\n\nOnly modules installed with a recent toolchain will still be available\nwhen this cluster has been migrated to the RHEL 9 operating system.\nRecent toolchains include GCC(core)/12.3.0, gompi/2023a, foss/2023a,\niimpi/2023a, intel/2023a, gfbf/2023a, and newer versions.\n\nYou should update your workflow or job script to use more recent software\ninstallations, or accept that the modules you currently rely on will soon\nno longer be available.\n\nTo request a more recent version of the software you are using,\nplease submit a software installation request via:\n\nhttps://www.ugent.be/hpc/en/support/software-installation-request\n\nThe HPC-UGent Tier-2 clusters running RHEL 8 will be migrated to RHEL 9.\n\nFor more information, see https://docs.hpc.ugent.be/rhel9/\n\nIf you have any questions, please contact hpc@ugent.be .\n</code></pre> <p>If you require software that is currently only available with an older toolchain on the HPC-UGent Tier-2 clusters that are still running RHEL 8, check via <code>module avail</code> if a more recent version is installed that you can switch to, or submit a software installation request so we can provide a more recent installation of that software which you can adopt.</p> <p>It is a good idea to test your software on the <code>shinx</code> cluster, which is already running RHEL 9 as operating system, to be sure if it still works. We will provide more RHEL 9 nodes on other clusters to test on soon.</p>"}, {"location": "rhel9/#planning", "title": "Planning", "text": "<p>We plan to migrate the HPC-UGent Tier-2 clusters that are still using RHEL 8 to RHEL 9 one by one, following the schedule outlined below.</p> cluster migration start migration completed on <code>skitty</code> Monday 30 September 2024 Tuesday 1 October 2024 <code>joltik</code> Monday 21 October 2024 Tuesday 22 October 2024 <code>accelgor</code> Tuesday 26 November 2024 Tuesday 27 November 2024 <code>gallade</code> January 2025 <code>donphan</code> February 2025 <code>doduo</code> (default cluster) February 2025 login nodes switch February 2025 <p>Migration of the <code>donphan</code> and <code>doduo</code> clusters to RHEL 9 and switching <code>login.hpc.ugent.be</code> to RHEL 9 login nodes will be done at the same time.</p> <p>We will keep this page up to date when more specific dates have been planned.</p> <p>Warning</p> <p>This planning above is subject to change, some clusters may get migrated later than originally planned.</p> <p>Please check back regularly.</p>"}, {"location": "rhel9/#questions", "title": "Questions", "text": "<p>If you have any questions related to the migration to the RHEL 9 operating system, please contact the UAntwerpen-HPC.</p>"}, {"location": "running_batch_jobs/", "title": "Running batch jobs", "text": "<p>In order to have access to the compute nodes of a cluster, you have to use the job system. The system software that handles your batch jobs consists of two pieces: the queue- and resource manager TORQUE and the scheduler Moab. Together, TORQUE and Moab provide a suite of commands for submitting jobs, altering some of the properties of waiting jobs (such as reordering or deleting them), monitoring their progress and killing ones that are having problems or are no longer needed. Only the most commonly used commands are mentioned here.</p> <p></p> <p>When you connect to the UAntwerpen-HPC, you have access to (one of) the login nodes of the cluster. There you can prepare the work you want to get done on the cluster by, e.g., installing or compiling programs, setting up data sets, etc. The computations however, should not be performed on this login node. The actual work is done on the cluster's compute nodes. Each compute node contains a number of CPU cores. The compute nodes are managed by the job scheduling software (Moab) and a Resource Manager (TORQUE), which decides when and on which compute nodes the jobs can run. It is usually not necessary to log on to the compute nodes directly  . Users can (and should) monitor their jobs periodically as they run, but do not have to remain connected to the UAntwerpen-HPC the entire time.</p> <p>The documentation in this \"Running batch jobs\" section includes a description of the general features of job scripts, how to submit them for execution and how to monitor their progress.</p>"}, {"location": "running_batch_jobs/#modules", "title": "Modules", "text": "<p>Software installation and maintenance on a UAntwerpen-HPC cluster such as the VSC clusters poses a number of challenges not encountered on a workstation or a departmental cluster. We therefore need a system on the UAntwerpen-HPC, which is able to easily activate or deactivate the software packages that you require for your program execution.</p>"}, {"location": "running_batch_jobs/#environment-variables", "title": "Environment Variables", "text": "<p>The program environment on the UAntwerpen-HPC is controlled by pre-defined settings, which are stored in environment (or shell) variables. For more information about environment variables, see the chapter \"Getting started\", section \"Variables\" in the intro to Linux.</p> <p>All the software packages that are installed on the UAntwerpen-HPC cluster require different settings. These packages include compilers, interpreters, mathematical software such as MATLAB and SAS, as well as other applications and libraries.</p>"}, {"location": "running_batch_jobs/#the-module-command", "title": "The module command", "text": "<p>In order to administer the active software and their environment variables, the module system has been developed, which:</p> <ol> <li> <p>Activates or deactivates software packages and their dependencies.</p> </li> <li> <p>Allows setting and unsetting of environment variables, including     adding and deleting entries from list-like environment variables.</p> </li> <li> <p>Does this in a shell-independent fashion (necessary information is     stored in the accompanying module file).</p> </li> <li> <p>Takes care of versioning aspects: For many libraries, multiple     versions are installed and maintained. The module system also takes     care of the versioning of software packages. For instance, it does     not allow multiple versions to be loaded at same time.</p> </li> <li> <p>Takes care of dependencies: Another issue arises when one     considers library versions and the dependencies they require. Some     software requires an older version of a particular library to run     correctly (or at all). Hence a variety of version numbers is     available for important libraries. Modules typically load the     required dependencies automatically.</p> </li> </ol> <p>This is all managed with the <code>module</code> command, which is explained in the next sections.</p> <p>There is also a shorter <code>ml</code> command that does exactly the same as the <code>module</code> command and is easier to type. Whenever you see a <code>module</code> command, you can replace <code>module</code> with <code>ml</code>.</p>"}, {"location": "running_batch_jobs/#available-modules", "title": "Available modules", "text": "<p>A large number of software packages are installed on the UAntwerpen-HPC clusters. A list of all currently available software can be obtained by typing:</p> <pre><code>module available\n</code></pre> <p>It's also possible to execute <code>module av</code> or <code>module avail</code>, these are shorter to type and will do the same thing.</p> <p>This will give some output such as:</p> <pre><code>$ module av 2&gt;&amp;1 | more\n------------- /apps/antwerpen/modules/hopper/2015a/all ------------\nABINIT/7.10.2-intel-2015a\nADF/2014.05\nAdvisor/2015_update1\nBison/3.0.4-intel-2015a\nBoost/1.57.0-foss-2015a-Python-2.7.9\nBoost/1.57.0-intel-2015a-Python-2.7.9\nbzip2/1.0.6-foss-2015a\nbzip2/1.0.6-intel-2015a\n...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., LAMMPS) is installed on the UAntwerpen-HPC.</p> <pre><code>$ module av 2&gt;&amp;1 | grep -i -e \"LAMMPS\"\nLAMMPS/9Dec14-intel-2015a\nLAMMPS/30Oct14-intel-2014a\nLAMMPS/5Sep14-intel-2014a\n</code></pre> <p>As you are not aware of the capitals letters in the module name, we looked for a case-insensitive name with the \"-i\" option.</p> <p>This gives a full list of software packages that can be loaded.</p> <p>The casing of module names is important: lowercase and uppercase letters matter in module names.</p>"}, {"location": "running_batch_jobs/#organisation-of-modules-in-toolchains", "title": "Organisation of modules in toolchains", "text": "<p>The amount of modules on the VSC systems can be overwhelming, and it is not always immediately clear which modules can be loaded safely together if you need to combine multiple programs in a single job to get your work done.</p> <p>Therefore the VSC has defined so-called toolchains. A toolchain contains a C/C++ and Fortran compiler, a MPI library and some basic math libraries for (dense matrix) linear algebra and FFT. Two toolchains are defined on most VSC systems. One, the <code>intel</code> toolchain, consists of the Intel compilers, MPI library and math libraries. The other one, the <code>foss</code> toolchain, consists of Open Source components: the GNU compilers, OpenMPI, OpenBLAS and the standard LAPACK and ScaLAPACK libraries for the linear algebra operations and the FFTW library for FFT. The toolchains are refreshed twice a year, which is reflected in their name.</p> <p>E.g., <code>foss/2025a</code> is the first version of the <code>foss</code> toolchain in 2025.</p> <p>The toolchains are then used to compile a lot of the software installed on the VSC clusters. You can recognise those packages easily as they all contain the name of the toolchain after the version number in their name (e.g., <code>Python/3.12.3-GCCcore-13.3.0</code>). Only packages compiled with the same toolchain name and version can work together without conflicts.</p>"}, {"location": "running_batch_jobs/#loading-and-unloading-modules", "title": "Loading and unloading modules", "text": ""}, {"location": "running_batch_jobs/#module-load", "title": "module load", "text": "<p>To \"activate\" a software package, you load the corresponding module file using the <code>module load</code> command:</p> <pre><code>module load example\n</code></pre> <p>This will load the most recent version of example.</p> <p>For some packages, multiple versions are installed; the load command will automatically choose the default version (if it was set by the system administrators) or the most recent version otherwise (i.e., the lexicographical last after the <code>/</code>).</p> <p>**However, you should specify a particular version to avoid surprises when newer versions are installed:</p> <pre><code>module load secondexample/4.5.6-intel-2023a\n</code></pre> <p>The <code>ml</code> command is a shorthand for <code>module load</code>: <code>ml example/1.2.3</code> is equivalent to <code>module load example/1.2.3</code>.</p> <p>Modules need not be loaded one by one; the two <code>module load</code> commands can be combined as follows:</p> <pre><code>module load example/1.2.3 secondexample/4.5.6-intel-2023a\n</code></pre> <p>This will load the two modules as well as their dependencies (unless there are conflicts between both modules).</p>"}, {"location": "running_batch_jobs/#module-list", "title": "module list", "text": "<p>Obviously, you need to be able to keep track of the modules that are currently loaded. Assuming you have run the <code>module load</code> commands stated above, you will get the following:</p> <pre><code>$ module list\nCurrently Loaded Modules:\n  1) env/vsc/&lt;cluster&gt;              (S)   7) binutils/2.40-GCCcore-12.3.0            13) iimpi/2023a\n  2) env/slurm/&lt;cluster&gt;            (S)   8) intel-compilers/2023.1.0                14) imkl-FFTW/2023.1.0-iimpi-2023a\n  3) env/software/&lt;cluster&gt;         (S)   9) numactl/2.0.16-GCCcore-12.3.0           15) intel/2023a\n  4) cluster/&lt;cluster&gt;              (S)  10) UCX/1.14.1-GCCcore-12.3.0               16) secondexample/4.5.6-intel-2023a\n  5) GCCcore/12.3.0                      11) impi/2021.9.0-intel-compilers-2023.1.0  17) example/1.2.3\n  6) zlib/1.2.13-GCCcore-12.3.0          12) imkl/2023.1.0\n\n  Where:\n   S:  Module is Sticky, requires --force to unload or purge\n</code></pre> <p>You can also just use the <code>ml</code> command without arguments to list loaded modules.</p> <p>It is important to note at this point that other modules (e.g., <code>intel/2023a</code>) are also listed, although the user did not explicitly load them. This is because <code>secondexample/4.5.6-intel-2023a</code> depends on it (as indicated in its name), and the system administrator specified that the <code>intel/2023a</code> module should be loaded whenever this <code>secondexample</code> module is loaded. There are advantages and disadvantages to this, so be aware of automatically loaded modules whenever things go wrong: they may have something to do with it!</p>"}, {"location": "running_batch_jobs/#module-unload", "title": "module unload", "text": "<p>To unload a module, one can use the <code>module unload</code> command. It works consistently with the <code>load</code> command, and reverses the latter's effect. However, the dependencies of the package are NOT automatically unloaded; you will have to unload the packages one by one. When the <code>example</code> module is unloaded, only the following modules remain:</p> <pre><code>$ module unload example\n$ module list\nCurrently Loaded Modules:\n  1) env/vsc/&lt;cluster&gt;              (S)   7) binutils/2.40-GCCcore-12.3.0            13) iimpi/2023a\n  2) env/slurm/&lt;cluster&gt;            (S)   8) intel-compilers/2023.1.0                14) imkl-FFTW/2023.1.0-iimpi-2023a\n  3) env/software/&lt;cluster&gt;         (S)   9) numactl/2.0.16-GCCcore-12.3.0           15) intel/2023a\n  4) cluster/&lt;cluster&gt;              (S)  10) UCX/1.14.1-GCCcore-12.3.0               16) secondexample/4.5.6-intel-2023a\n  5) GCCcore/12.3.0                      11) impi/2021.9.0-intel-compilers-2023.1.0\n  6) zlib/1.2.13-GCCcore-12.3.0          12) imkl/2023.1.0\n\n  Where:\n   S:  Module is Sticky, requires --force to unload or purge\n</code></pre> <p>To unload the <code>example</code> module, you can also use <code>ml -example</code>.</p> <p>Notice that the version was not specified: there can only be one version of a module loaded at a time, so unloading modules by name is not ambiguous. However, checking the list of currently loaded modules is always a good idea, since unloading a module that is currently not loaded will not result in an error.</p>"}, {"location": "running_batch_jobs/#purging-all-modules", "title": "Purging all modules", "text": "<p>In order to unload all modules at once, and hence be sure to start in a clean state, you can use:</p> <pre><code>module purge\n</code></pre> <p>However, on some VSC clusters you may be left with a very empty list of available modules after executing <code>module purge</code>. On those systems, <code>module av</code> will show you a list of modules containing the name of a cluster or a particular feature of a section of the cluster, and loading the appropriate module will restore the module list applicable to that particular system.</p>"}, {"location": "running_batch_jobs/#using-explicit-version-numbers", "title": "Using explicit version numbers", "text": "<p>Once a module has been installed on the cluster, the executables or libraries it comprises are never modified. This policy ensures that the user's programs will run consistently, at least if the user specifies a specific version. Failing to specify a version may result in unexpected behaviour.</p> <p>Consider the following example: the user decides to use the <code>example</code> module and at that point in time, just a single version 1.2.3 is installed on the cluster. The user loads the module using:</p> <pre><code>module load example\n</code></pre> <p>rather than</p> <pre><code>module load example/1.2.3\n</code></pre> <p>Everything works fine, up to the point where a new version of <code>example</code> is installed, 4.5.6. From then on, the user's <code>load</code> command will load the latter version, rather than the intended one, which may lead to unexpected problems. See for example the following section on Module Conflicts.</p> <p>Consider the following <code>example</code> modules:</p> <pre><code>$ module avail example/\nexample/1.2.3 \nexample/4.5.6\n</code></pre> <p>Let's now generate a version conflict with the <code>example</code> module, and see what happens.</p> <pre><code>$ module load example/1.2.3  example/4.5.6\nLmod has detected the following error: A different version of the 'example' module is already loaded (see output of 'ml').\n$ module swap example/4.5.6\n</code></pre> <p>Note: A <code>module swap</code> command combines the appropriate <code>module unload</code> and <code>module load</code> commands.</p>"}, {"location": "running_batch_jobs/#search-for-modules", "title": "Search for modules", "text": "<p>With the <code>module spider</code> command, you can search for modules:</p> <pre><code>$ module spider example\n--------------------------------------------------------------------------------\n  example:\n--------------------------------------------------------------------------------\n    Description: \n        This is just an example\n\n    Versions: \n        example/1.2.3 \n        example/4.5.6\n--------------------------------------------------------------------------------\n  For detailed information about a specific \"example\" module (including how to load the modules) use the module's full name. \n  For example:\n\n    module spider example/1.2.3\n--------------------------------------------------------------------------------\n</code></pre> <p>It's also possible to get detailed information about a specific module:</p> <pre><code>$ module spider example/1.2.3\n------------------------------------------------------------------------------------------\n  example: example/1.2.3\n------------------------------------------------------------------------------------------\n  Description: \n    This is just an example \nThis module can be loaded directly: module load example/1.2.3\nHelp:\n\n        Description \n        =========== \n        This is just an example\n\n        More information \n        ================ \n         - Homepage: https://example.com\n</code></pre>"}, {"location": "running_batch_jobs/#get-detailed-info", "title": "Get detailed info", "text": "<p>To get a list of all possible commands, type:</p> <pre><code>module help\n</code></pre> <p>Or to get more information about one specific module package:</p> <pre><code>$ module help example/1.2.3\n----------- Module Specific Help for 'example/1.2.3' --------------------------- \n  This is just an example - Homepage: https://example.com/\n</code></pre>"}, {"location": "running_batch_jobs/#save-and-load-collections-of-modules", "title": "Save and load collections of modules", "text": "<p>If you have a set of modules that you need to load often, you can save these in a collection. This will enable you to load all the modules you need with a single command.</p> <p>In each <code>module</code> command shown below, you can replace <code>module</code> with <code>ml</code>.</p> <p>First, load all modules you want to include in the collections:</p> <pre><code>module load example/1.2.3 secondexample/4.5.6-intel-2023a\n</code></pre> <p>Now store it in a collection using <code>module save</code>. In this example, the collection is named <code>my-collection</code>.</p> <pre><code>module save my-collection\n</code></pre> <p>Later, for example in a jobscript or a new session, you can load all these modules with <code>module restore</code>:</p> <pre><code>module restore my-collection\n</code></pre> <p>You can get a list of all your saved collections with the <code>module savelist</code> command:</p> <pre><code>$ module savelist\nNamed collection list (For LMOD_SYSTEM_NAME = \"&lt;OS&gt;-&lt;CPU-ARCHITECTURE&gt;\"):\n  1) my-collection\n</code></pre> <p>To get a list of all modules a collection will load, you can use the <code>module describe</code> command:</p> <pre><code>$ module describe my-collection\nCurrently Loaded Modules:\n  1) env/vsc/&lt;cluster&gt;              (S)   7) binutils/2.40-GCCcore-12.3.0            13) iimpi/2023a\n  2) env/slurm/&lt;cluster&gt;            (S)   8) intel-compilers/2023.1.0                14) imkl-FFTW/2023.1.0-iimpi-2023a\n  3) env/software/&lt;cluster&gt;         (S)   9) numactl/2.0.16-GCCcore-12.3.0           15) intel/2023a\n  4) cluster/&lt;cluster&gt;              (S)  10) UCX/1.14.1-GCCcore-12.3.0               16) secondexample/4.5.6-intel-2023a\n  5) GCCcore/12.3.0                      11) impi/2021.9.0-intel-compilers-2023.1.0  17) example/1.2.3\n  6) zlib/1.2.13-GCCcore-12.3.0          12) imkl/2023.1.0\n</code></pre> <p>To remove a collection, remove the corresponding file in <code>$HOME/.lmod.d/</code>:</p> <pre><code>rm $HOME/.lmod.d/my-collection\n</code></pre>"}, {"location": "running_batch_jobs/#getting-module-details", "title": "Getting module details", "text": "<p>To see how a module would change the environment, you can use the <code>module show</code> command:</p> <pre><code>$ module show Python-bundle-PyPI/2024.06-GCCcore-13.3.0\nhelp([[\nDescription\n===========\nBundle of Python packages from PyPI\n...\nIncluded extensions\n===================\nalabaster-0.7.16, appdirs-1.4.4, asn1crypto-1.5.1, atomicwrites-1.4.1,\n...\nwcwidth-0.2.13, webencodings-0.5.1, xlrd-2.0.1, zipfile36-0.1.3, zipp-3.19.2\n]])\n...\nload(\"GCCcore/13.3.0\")\nload(\"Python/3.12.3-GCCcore-13.3.0\")\nload(\"cryptography/42.0.8-GCCcore-13.3.0\")\nload(\"virtualenv/20.26.2-GCCcore-13.3.0\")\n...\n</code></pre> <p>It's also possible to use the <code>ml show</code> command instead: they are equivalent.</p> <p>Here you can see that the <code>Python-bundle-PyPI/2024.06-GCCcore-13.3.0</code> comes with a lot of extensions: <code>alabaster</code>, <code>appdirs</code>, ... These are Python packages which can be used in your Python scripts.</p> <p>You can also see the modules the <code>Python-bundle-PyPI/2024.06-GCCcore-13.3.0</code> module loads: <code>GCCcore/13.3.0</code>, <code>Python/3.12.3-GCCcore-13.3.0</code>, ...</p> <p>If you're not sure what all of this means: don't worry, you don't have to know; just load the module and try to use the software.</p>"}, {"location": "running_batch_jobs/#getting-system-information-about-the-hpc-infrastructure", "title": "Getting system information about the HPC infrastructure", "text": ""}, {"location": "running_batch_jobs/#checking-the-general-status-of-the-hpc-infrastructure", "title": "Checking the general status of the HPC infrastructure", "text": "<p>To check how much jobs are running in what queues, you can use the <code>qstat -q</code> command:</p> <pre><code>$ qstat -q\nQueue            Memory CPU Time Walltime Node  Run Que Lm  State\n---------------- ------ -------- -------- ----  --- --- --  -----\ndefault            --      --       --      --    0   0 --   E R\nq72h               --      --    72:00:00   --    0   0 --   E R\nlong               --      --    72:00:00   --  316  77 --   E R\nshort              --      --    11:59:59   --   21   4 --   E R\nq1h                --      --    01:00:00   --    0   1 --   E R\nq24h               --      --    24:00:00   --    0   0 --   E R\n                                               ----- -----\n                                                337  82\n</code></pre> <p>Here, there are 316 jobs running on the <code>long</code> queue, and 77 jobs queued. We can also see that the <code>long</code> queue allows a maximum wall time of 72 hours.</p>"}, {"location": "running_batch_jobs/#getting-cluster-state", "title": "Getting cluster state", "text": "<p>You can check http://hpc.ugent.be/clusterstate to see information about the clusters: you can see the nodes that are down, free, partially filled with jobs, completely filled with jobs, ....</p> <p>You can also get this information in text form (per cluster separately) with the <code>pbsmon</code> command:</p> <pre><code>$ module swap cluster/donphan\n$ pbsmon\n 4001 4002 4003 4004 4005 4006 4007\n    _    j    j    j    _    _    .\n\n 4008 4009 4010 4011 4012 4013 4014\n    _    _    .    _    _    _    _\n\n 4015 4016\n    _    _\n\n   _ free                 : 11  |   X down                 : 0   |\n   j partial              : 3   |   x down_on_error        : 0   |\n   J full                 : 0   |   m maintenance          : 0   |\n                                |   . offline              : 2   |\n                                |   o other (R, *, ...)    : 0   |\n\nNode type:\n ppn=36, mem=751GB\n</code></pre> <p><code>pbsmon</code> only outputs details of the cluster corresponding to the currently loaded <code>cluster</code> module see the section on Specifying the cluster on which to run. It also shows details about the nodes in a cluster. In the example, all nodes have 36 cores and 751 GB of memory.</p>"}, {"location": "running_batch_jobs/#defining-and-submitting-your-job", "title": "Defining and submitting your job", "text": "<p>Usually, you will want to have your program running in batch mode, as opposed to interactively as you may be accustomed to. The point is that the program must be able to start and run without user intervention, i.e., without you having to enter any information or to press any buttons during program execution. All the necessary input or required options have to be specified on the command line, or needs to be put in input or configuration files.</p> <p>As an example, we will run a Perl script, which you will find in the examples subdirectory on the UAntwerpen-HPC. When you received an account to the UAntwerpen-HPC a subdirectory with examples was automatically generated for you.</p> <p>Remember that you have copied the contents of the HPC examples directory to your home directory, so that you have your own personal copy (editable and over-writable) and that you can start using the examples. If you haven't done so already, run these commands now:</p> <pre><code>cd\ncp -r /apps/antwerpen/tutorials/Intro-HPC/examples ~/\n</code></pre> <p>First go to the directory with the first examples by entering the command: <pre><code>cd ~/examples/Running-batch-jobs\n</code></pre></p> <p>Each time you want to execute a program on the UAntwerpen-HPC you'll need 2 things:</p> <p>The executable  The program to execute from the end-user, together with its     peripheral input files, databases and/or command options.</p> <p>A batch job script , which will define the computer resource requirements of the     program, the required additional software packages and which will     start the actual executable. The UAntwerpen-HPC needs to know:</p> <pre><code>1.  the type of compute nodes;\n\n2.  the number of CPUs;\n\n3.  the amount of memory;\n\n4.  the expected duration of the execution time (wall time: Time as\n    measured by a clock on the wall);\n\n5.  the name of the files which will contain the output (i.e.,\n    stdout) and error (i.e., stderr) messages;\n\n6.  what executable to start, and its arguments.\n</code></pre> <p>Later on, the UAntwerpen-HPC user shall have to define (or to adapt) his/her own job scripts. For now, all required job scripts for the exercises are provided for you in the examples subdirectories.</p> <p>List and check the contents with:</p> <pre><code>$ ls -l\ntotal 512\n-rw-r--r-- 1 vsc20167 193 Sep 11 10:34 fibo.pbs\n-rw-r--r-- 1 vsc20167 609 Sep 11 10:25 fibo.pl\n</code></pre> <p>In this directory you find a Perl script (named \"fibo.pl\") and a job script (named \"fibo.pbs\").</p> <ol> <li> <p>The Perl script calculates the first 30 Fibonacci numbers.</p> </li> <li> <p>The job script is actually a standard Unix/Linux shell script that     contains a few extra comments at the beginning that specify     directives to PBS. These comments all begin with #PBS.</p> </li> </ol> <p>We will first execute the program locally (i.e., on your current login-node), so that you can see what the program does.</p> <p>On the command line, you would run this using:</p> <pre><code>$ ./fibo.pl\n[0] -&gt; 0\n[1] -&gt; 1\n[2] -&gt; 1\n[3] -&gt; 2\n[4] -&gt; 3\n[5] -&gt; 5\n[6] -&gt; 8\n[7] -&gt; 13\n[8] -&gt; 21\n[9] -&gt; 34\n[10] -&gt; 55\n[11] -&gt; 89\n[12] -&gt; 144\n[13] -&gt; 233\n[14] -&gt; 377\n[15] -&gt; 610\n[16] -&gt; 987\n[17] -&gt; 1597\n[18] -&gt; 2584\n[19] -&gt; 4181\n[20] -&gt; 6765\n[21] -&gt; 10946\n[22] -&gt; 17711\n[23] -&gt; 28657\n[24] -&gt; 46368\n[25] -&gt; 75025\n[26] -&gt; 121393\n[27] -&gt; 196418\n[28] -&gt; 317811\n[29] -&gt; 514229\n</code></pre> <p>Remark: Recall that you have now executed the Perl script locally on one of the login-nodes of the UAntwerpen-HPC cluster. Of course, this is not our final intention; we want to run the script on any of the compute nodes. Also, it is not considered as good practice, if you \"abuse\" the login-nodes for testing your scripts and executables. It will be explained later on how you can reserve your own compute-node (by opening an interactive session) to test your software. But for the sake of acquiring a good understanding of what is happening, you are pardoned for this example since these jobs require very little computing power.</p> <p>The job script contains a description of the job by specifying the command that need to be executed on the compute node:</p> fibo.pbs<pre><code>#!/bin/bash -l\ncd $PBS_O_WORKDIR\n./fibo.pl\n</code></pre> <p>So, jobs are submitted as scripts (bash, Perl, Python, etc.), which specify the parameters related to the jobs such as expected runtime (walltime), e-mail notification, etc. These parameters can also be specified on the command line.</p> <p>This job script can now be submitted to the cluster's job system for execution, using the qsub (Queue SUBmit) command:</p> <pre><code>$ qsub fibo.pbs\n433253.leibniz\n</code></pre> <p>The qsub command returns a job identifier on the HPC cluster. The important part is the number (e.g., \"433253.leibniz \"); this is a unique identifier for the job and can be used to monitor and manage your job.</p> <p>Remark: the modules that were loaded when you submitted the job will not be loaded when the job is started. You should always specify the <code>module load</code> statements that are required for your job in the job script itself.</p> <p>To faciliate this, you can use a pre-defined module collection which you can restore using <code>module restore</code>, see the section on Save and load collections of modules for more information.</p> <p>Your job is now waiting in the queue for a free workernode to start on.</p> <p>Go and drink some coffee ...\u00a0but not too long. If you get impatient you can start reading the next section for more information on how to monitor jobs in the queue.</p> <p>After your job was started, and ended, check the contents of the directory:</p> <pre><code>$ ls -l\ntotal 768\n-rw-r--r-- 1 vsc20167 vsc20167   44 Feb 28 13:33 fibo.pbs\n-rw------- 1 vsc20167 vsc20167    0 Feb 28 13:33 fibo.pbs.e433253.leibniz\n-rw------- 1 vsc20167 vsc20167 1010 Feb 28 13:33 fibo.pbs.o433253.leibniz\n-rwxrwxr-x 1 vsc20167 vsc20167  302 Feb 28 13:32 fibo.pl\n</code></pre> <p>Explore the contents of the 2 new files:</p> <pre><code>$ more fibo.pbs.o433253.leibniz\n$ more fibo.pbs.e433253.leibniz\n</code></pre> <p>These files are used to store the standard output and error that would otherwise be shown in the terminal window. By default, they have the same name as that of the PBS script, i.e., \"fibo.pbs\" as base name, followed by the extension \".o\" (output) and \".e\" (error), respectively, and the job number ('433253.leibniz' for this example). The error file will be empty, at least if all went well. If not, it may contain valuable information to determine and remedy the problem that prevented a successful run. The standard output file will contain the results of your calculation (here, the output of the Perl script)</p>"}, {"location": "running_batch_jobs/#submitting-jobs-from-one-cluster-to-another", "title": "Submitting jobs from one cluster to another", "text": "<p>It is possible to submit jobs from a job to a cluster different than the one your job is running on. This could come in handy if, for example, the tool used to submit jobs only works on a particular cluster  (or only on the login nodes), but the jobs can be run on several clusters. An example of this is the <code>wsub</code> command of <code>worker</code>, see also here.</p> <p>To submit jobs to the <code>{{ othercluster }}</code> cluster, you can change only what is needed in your session environment  to submit jobs to that particular cluster by using <code>module swap env/slurm/{{ othercluster }}</code> instead of using  <code>module swap cluster/{{ othercluster }}</code>. The last command also activates the software modules that are installed specifically for {{ othercluster }},  which may not be compatible with the system you are working on. By only swapping to <code>env/slurm/donphan</code>, jobs that are submitted will be sent to the <code>{{ othercluster }}</code> cluster.  The same approach can be used to submit jobs to another cluster, of course.</p> <p>Each <code>cluster</code> module not only loads the corresponding <code>env/slurm/...</code> module to control where jobs are sent to,  but also two other <code>env/...</code> modules which control other parts of the environment. For example, for the <code>{{ defaultcluster }}</code> cluster,  loading the <code>cluster/{{ defaultcluster }}</code> module corresponds to loading 3 different <code>env/</code> modules:</p> <code>env/</code> module for <code>{{ defaultcluster }}</code> Purpose <code>env/slurm/{{ defaultcluster }}</code> Changes <code>$SLURM_CLUSTERS</code> which specifies the cluster where jobs are sent to. <code>env/software/{{ defaultcluster }}</code> Changes <code>$MODULEPATH</code>, which controls what software modules are available for loading. <code>env/vsc/{{ defaultcluster }}</code> Changes the set of <code>$VSC_</code> environment variables that are specific to the <code>{{ defaultcluster }}</code> cluster <p>We recommend that you do not use these separate <code>env/</code> modules directly unless you really need to, and only if you understand what they are doing exactly. Since mixing <code>cluster/</code> and <code>env/</code> modules of different clusters can result in surprises if you are not careful.</p> <p>We also recommend using a <code>module swap cluster</code> command after submitting the jobs. This to \"reset\" your environment to a sane state.</p>"}, {"location": "running_batch_jobs/#monitoring-and-managing-your-jobs", "title": "Monitoring and managing your job(s)", "text": "<p>Using the job ID that <code>qsub</code> returned, there are various ways to monitor the status of your job. In the following commands, replace <code>12345</code> with the job ID <code>qsub</code> returned.</p> <pre><code>qstat 12345\n</code></pre> <p>To show an estimated start time for your job (note that this may be very inaccurate, the margin of error on this figure can be bigger then 100% due to a sample in a population of 1.) This command is not available on all systems.</p> <p>::: prompt :::</p> <p>This is only a very rough estimate. Jobs may launch sooner than estimated if other jobs end faster than estimated, but may also be delayed if other higher-priority jobs enter the system.</p> <p>To show the status, but also the resources required by the job, with error messages that may prevent your job from starting:</p> <p>::: prompt :::</p> <p>To show on which compute nodes your job is running, at least, when it is running:</p> <pre><code>qstat -n 12345\n</code></pre> <p>To remove a job from the queue so that it will not run, or to stop a job that is already running.</p> <pre><code>qdel 12345\n</code></pre> <p>When you have submitted several jobs (or you just forgot about the job ID), you can retrieve the status of all your jobs that are submitted and are not yet finished using:</p> <pre><code>$ qstat\n:\nJob ID      Name    User      Time Use S Queue\n----------- ------- --------- -------- - -----\n433253.leibniz ....     mpi  vsc20167     0    Q short\n</code></pre> <p>Here:</p> <p>Job ID      the job's unique identifier</p> <p>Name        the name of the job</p> <p>User        the user that owns the job</p> <p>Time Use    the elapsed walltime for the job</p> <p>Queue       the queue the job is in</p> <p>The state S can be any of the following:</p>  State Meaning Q The job is queued and is waiting to start. R The job is currently running. E The job is currently exit after having run. C The job is completed after having run. H The job has a user or system hold on it and will not be eligible to run until the hold is removed. <p>User hold means that the user can remove the hold. System hold means that the system or an administrator has put the job on hold, very likely because something is wrong with it. Check with your helpdesk to see why this is the case.</p>"}, {"location": "running_batch_jobs/#examining-the-queue", "title": "Examining the queue", "text": "<p>As we learned above, Moab is the software application that actually decides when to run your job and what resources your job will run on.</p> <p>You can look at the queue by using the PBS command or the Moab command. By default, will display the queue ordered by , whereas will display jobs grouped by their state (\"running\", \"idle\", or \"hold\") then ordered by priority. Therefore, is often more useful. Note however that at some VSC-sites, these commands show only your jobs or may be even disabled to not reveal what other users are doing.</p> <p>The command displays information about active (\"running\"), eligible (\"idle\"), blocked (\"hold\"), and/or recently completed jobs. To get a summary:</p> <p>::: prompt active jobs: 163 eligible jobs: 133 blocked jobs: 243 Total jobs: 539 :::</p> <p>And to get the full detail of all the jobs, which are in the system:</p> <p>::: prompt active jobs------------------------ JOBID USERNAME STATE PROCS REMAINING STARTTIME 428024 vsc20167 Running 8 2:57:32 Mon Sep 2 14:55:05 153 active jobs 1307 of 3360 processors in use by local jobs (38.90 153 of 168 nodes active (91.07</p> <p>eligible jobs---------------------- JOBID USERNAME STATE PROCS WCLIMIT QUEUETIME 442604 vsc20167 Idle 48 7:00:00:00 Sun Sep 22 16:39:13 442605 vsc20167 Idle 48 7:00:00:00 Sun Sep 22 16:46:22</p> <p>135 eligible jobs</p> <p>blocked jobs----------------------- JOBID USERNAME STATE PROCS WCLIMIT QUEUETIME 441237 vsc20167 Idle 8 3:00:00:00 Thu Sep 19 15:53:10 442536 vsc20167 UserHold 40 3:00:00:00 Sun Sep 22 00:14:22 252 blocked jobs Total jobs: 540 :::</p> <p>There are 3 categories, the , and jobs.</p> Active jobs <p>are jobs that are running or starting and that consume computer resources. The amount of time remaining (w.r.t.\u00a0walltime, sorted to earliest completion time) and the start time are displayed. This will give you an idea about the foreseen completion time. These jobs could be in a number of states:</p> Started <p>attempting to start, performing pre-start tasks</p> Running <p>currently executing the user application</p> Suspended <p>has been suspended by scheduler or admin (still in place on the allocated resources, not executing)</p> Cancelling <p>has been cancelled, in process of cleaning up</p> Eligible jobs <p>are jobs that are waiting in the queues and are considered eligible for both scheduling and backfilling. They are all in the idle job state and do not violate any fairness policies or do not have any job holds in place. The requested walltime is displayed, and the list is ordered by job priority.</p> Blocked jobs <p>are jobs that are ineligible to be run or queued. These jobs could be in a number of states for the following reasons:</p> Idle <p>when the job violates a fairness policy</p> Userhold <p>or systemhold when it is user or administrative hold</p> Batchhold <p>when the requested resources are not available or the resource manager has repeatedly failed to start the job</p> Deferred <p>when a temporary hold when the job has been unable to start after a specified number of attempts</p> Notqueued <p>when scheduling daemon is unavailable</p>"}, {"location": "running_batch_jobs/#specifying-job-requirements", "title": "Specifying job requirements", "text": "<p>Without giving more information about your job upon submitting it with qsub, default values will be assumed that are almost never appropriate for real jobs.</p> <p>It is important to estimate the resources you need to successfully run your program, such as the amount of time the job will require, the amount of memory it needs, the number of CPUs it will run on, etc. This may take some work, but it is necessary to ensure your jobs will run properly.</p>"}, {"location": "running_batch_jobs/#generic-resource-requirements", "title": "Generic resource requirements", "text": "<p>The qsub command takes several options to specify the requirements, of which we list the most commonly used ones below.</p> <pre><code>qsub -l walltime=2:30:00 ...\n</code></pre> <p>For the simplest cases, only the amount of maximum estimated execution time (called \"walltime\") is really important. Here, the job requests 2 hours, 30 minutes. As soon as the job exceeds the requested walltime, it will be \"killed\" (terminated) by the job scheduler. There is no harm if you slightly overestimate the maximum execution time. If you omit this option, the queue manager will not complain but use a default value (one hour on most clusters).</p> <p>If you want to run some final steps (for example to copy files back) before the walltime kills your main process, you have to kill the main command yourself before the walltime runs out and then copy the file back. See the section on Running a command with a maximum time limit for how to do this.</p> <pre><code>qsub -l mem=4gb ...\n</code></pre> <p>The job requests 4 GB of RAM memory. As soon as the job tries to use more memory, it will be \"killed\" (terminated) by the job scheduler. There is no harm if you slightly overestimate the requested memory.</p> <pre><code>qsub -l nodes=5:ppn=2 ...\n</code></pre> <p>The job requests 5 compute nodes with two cores on each node (ppn stands for \"processors per node\", where \"processors\" here actually means \"CPU cores\").</p> <pre><code>qsub -l nodes=1:westmere\n</code></pre> <p>The job requests just one node, but it should have an Intel Westmere processor. A list with site-specific properties can be found in the next section or in the User Portal (\"VSC hardware\" section)1 of the VSC website.</p> <p>These options can either be specified on the command line, e.g.</p> <pre><code>qsub -l nodes=1:ppn,mem=2gb fibo.pbs\n</code></pre> <p>or in the job script itself using the #PBS-directive, so \"fibo.pbs\" could be modified to:</p> <pre><code>#!/bin/bash -l\n#PBS -l nodes=1:ppn=1\n#PBS -l mem=2gb\ncd $PBS_O_WORKDIR\n./fibo.pl\n</code></pre> <p>Note that the resources requested on the command line will override those specified in the PBS file.</p>"}, {"location": "running_batch_jobs/#node-specific-properties", "title": "Node-specific properties", "text": "<p>The following table contains some node-specific properties that can be used to make sure the job will run on nodes with a specific CPU or interconnect. Note that these properties may vary over the different VSC sites.</p> <p>ivybridge    only use Intel processors from the Ivy Bridge family (26xx-v2, hopper-only)   broadwell    only use Intel processors from the Broadwell family (26xx-v4, leibniz-only)   mem128       only use nodes with 128GB of RAM (leibniz)   mem256       only use nodes with 256GB of RAM (hopper and leibniz)   tesla, gpu   only use nodes with the NVIDUA P100 GPU (leibniz)</p> <p>Since both hopper and leibniz are homogeneous with respect to processor architecture, the CPU architecture properties are not really needed and only defined for compatibility with other VSC clusters.</p> <p>shanghai     only use AMD Shanghai processors (AMD 2378)   magnycours   only use AMD Magnycours processors (AMD 6134)   interlagos   only use AMD Interlagos processors (AMD 6272)   barcelona    only use AMD Shanghai and Magnycours processors   amd          only use AMD processors   ivybridge    only use Intel Ivy Bridge processors (E5-2680-v2)   intel        only use Intel processors   gpgpu        only use nodes with General Purpose GPUs (GPGPUs)   k20x         only use nodes with NVIDIA Tesla K20x GPGPUs   xeonphi      only use nodes with Xeon Phi co-processors   phi5110p     only use nodes with Xeon Phi 5110P co-processors</p> <p>To get a list of all properties defined for all nodes, enter</p> <p>::: prompt :::</p> <p>This list will also contain properties referring to, e.g., network components, rack number, etc.</p>"}, {"location": "running_batch_jobs/#job-output-and-error-files", "title": "Job output and error files", "text": "<p>At some point your job finishes, so you may no longer see the job ID in the list of jobs when you run qstat (since it will only be listed for a few minutes after completion with state \"C\"). After your job finishes, you should see the standard output and error of your job in two files, located by default in the directory where you issued the qsub command.</p> <p>When you navigate to that directory and list its contents, you should see them:</p> <pre><code>$ ls -l\ntotal 1024\n-rw-r--r-- 1 vsc20167  609 Sep 11 10:54 fibo.pl\n-rw-r--r-- 1 vsc20167   68 Sep 11 10:53 fibo.pbs\n-rw------- 1 vsc20167   52 Sep 11 11:03 fibo.pbs.e433253.leibniz\n-rw------- 1 vsc20167 1307 Sep 11 11:03 fibo.pbs.o433253.leibniz\n</code></pre> <p>In our case, our job has created both output ('fibo.pbs.') and error files ('fibo.pbs.') containing info written to stdout and stderr respectively.</p> <p>Inspect the generated output and error files:</p> <pre><code>$ cat fibo.pbs.o433253.leibniz\n...\n$ cat fibo.pbs.e433253.leibniz\n...\n</code></pre>"}, {"location": "running_batch_jobs/#e-mail-notifications", "title": "E-mail notifications", "text": ""}, {"location": "running_batch_jobs/#upon-job-failure", "title": "Upon job failure", "text": "<p>Whenever a job fails, an e-mail will be sent to the e-mail address that's connected to your VSC account. This is the e-mail address that is linked to the university account, which was used during the registration process.</p> <p>You can force a job to fail by specifying an unrealistic wall-time for the previous example. Lets give the \"fibo.pbs\" job just one second to complete:</p> <p>::: prompt :::</p> <p>Now, lets hope that the did not manage to run the job within one second, and you will get an e-mail informing you about this error.</p> <p>::: flattext PBS Job Id: Job Name: fibo.pbs Exec host: Aborted by PBS Server Job exceeded some resource limit (walltime, mem, etc.). Job was aborted. See Administrator for help :::</p>"}, {"location": "running_batch_jobs/#generate-your-own-e-mail-notifications", "title": "Generate your own e-mail notifications", "text": "<p>You can instruct the UAntwerpen-HPC to send an e-mail to your e-mail address whenever a job begins, ends and/or aborts, by adding the following lines to the job script <code>fibo.pbs</code>:</p> <pre><code>#PBS -m b \n#PBS -m e \n#PBS -m a\n</code></pre> <p>or</p> <pre><code>#PBS -m abe\n</code></pre> <p>These options can also be specified on the command line. Try it and see what happens:</p> <pre><code>qsub -m abe fibo.pbs\n</code></pre> <p>The system will use the e-mail address that is connected to your VSC account. You can also specify an alternate e-mail address with the <code>-M</code> option:</p> <pre><code>qsub -m b -M john.smith@example.com fibo.pbs\n</code></pre> <p>will send an e-mail to john.smith@example.com when the job begins.</p>"}, {"location": "running_batch_jobs/#running-a-job-after-another-job", "title": "Running a job after another job", "text": "<p>If you submit two jobs expecting that should be run one after another (for example because the first generates a file the second needs), there might be a problem as they might both be run at the same time.</p> <p>So the following example might go wrong:</p> <pre><code>$ qsub job1.sh\n$ qsub job2.sh\n</code></pre> <p>You can make jobs that depend on other jobs. This can be useful for breaking up large jobs into smaller jobs that can be run in a pipeline. The following example will submit 2 jobs, but the second job (<code>job2.sh</code>) will be held (<code>H</code> status in <code>qstat</code>) until the first job successfully completes. If the first job fails, the second will be cancelled.</p> <pre><code>$ FIRST_ID=$(qsub job1.sh)\n$ qsub -W depend=afterok:$FIRST_ID job2.sh\n</code></pre> <p><code>afterok</code> means \"After OK\", or in other words, after the first job successfully completed.</p> <p>It's also possible to use <code>afternotok</code> (\"After not OK\") to run the second job only if the first job exited with errors. A third option is to use <code>afterany</code> (\"After any\"), to run the second job after the first job (regardless of success or failure).</p> <ol> <li> <p>URL: https://vscdocumentation.readthedocs.io/en/latest/hardware.html \u21a9</p> </li> </ol>"}, {"location": "running_interactive_jobs/", "title": "Running interactive jobs", "text": ""}, {"location": "running_interactive_jobs/#introduction", "title": "Introduction", "text": "<p>Interactive jobs are jobs which give you an interactive session on one of the compute nodes. Importantly, accessing the compute nodes this way means that the job control system guarantees the resources that you have asked for.</p> <p>Interactive PBS jobs are similar to non-interactive PBS jobs in that they are submitted to PBS via the command qsub. Where an interactive job differs is that it does not require a job script, the required PBS directives can be specified on the command line.</p> <p>Interactive jobs can be useful to debug certain job scripts or programs, but should not be the main use of the UAntwerpen-HPC. Waiting for user input takes a very long time in the life of a CPU and does not make efficient usage of the computing resources.</p> <p>The syntax for qsub for submitting an interactive PBS job is:</p> <pre><code>$ qsub -I &lt;... pbs directives ...&gt;\n</code></pre>"}, {"location": "running_interactive_jobs/#interactive-jobs-without-x-support", "title": "Interactive jobs, without X support", "text": "<p>Tip</p> <p>Find the code in \"~/examples/Running_interactive_jobs\"</p> <p>First of all, in order to know on which computer you're working, enter:</p> <pre><code>$ hostname -f\nln2.leibniz.uantwerpen.vsc\n</code></pre> <p>This means that you're now working on the login node <code>ln2.leibniz.uantwerpen.vsc</code> of the cluster.</p> <p>The most basic way to start an interactive job is the following:</p> <pre><code>$ qsub -I\nqsub: waiting for job 433253.leibniz to start\nqsub: job 433253.leibniz ready\n</code></pre> <p>There are two things of note here.</p> <ol> <li> <p>The \"qsub\" command (with the interactive -I flag) waits until a     node is assigned to your interactive session, connects to the     compute node and shows you the terminal prompt on that node.</p> </li> <li> <p>You'll see that your directory structure of your home directory has     remained the same. Your home directory is actually located on a     shared storage system. This means that the exact same directory is     available on all login nodes and all compute nodes on all clusters.</p> </li> </ol> <p>In order to know on which compute-node you're working, enter again:</p> <pre><code>$ hostname -f\nr1c02cn3.leibniz.antwerpen.vsc\n</code></pre> <p>Note that we are now working on the compute-node called \"r1c02cn3.leibniz.antwerpen.vsc\". This is the compute node, which was assigned to us by the scheduler after issuing the \"qsub -I\" command.</p> <p>This computer name looks strange, but bears some logic in it. It provides the system administrators with information where to find the computer in the computer room.</p> <p>The computer \"r1c02cn3\" stands for:</p> <ol> <li> <p>\"r5\" is rack #5.</p> </li> <li> <p>\"c3\" is enclosure/chassis #3.</p> </li> <li> <p>\"cn08\" is compute node #08.</p> </li> </ol> <p>With this naming convention, the system administrator can easily find the physical computers when they need to execute some maintenance activities.</p> <p>Now, go to the directory of our second interactive example and run the program \"primes.py\". This program will ask you for an upper limit ($&gt; 1$) and will print all the primes between 1 and your upper limit:</p> <pre><code>$ cd ~/examples/Running_interactive_jobs\n$ ./primes.py\nThis program calculates all primes between 1 and your upper limit.\nEnter your upper limit (&gt;1): 50\nStart Time:  2013-09-11 15:49:06\n[Prime#1] = 1\n[Prime#2] = 2\n[Prime#3] = 3\n[Prime#4] = 5\n[Prime#5] = 7\n[Prime#6] = 11\n[Prime#7] = 13\n[Prime#8] = 17\n[Prime#9] = 19\n[Prime#10] = 23\n[Prime#11] = 29\n[Prime#12] = 31\n[Prime#13] = 37\n[Prime#14] = 41\n[Prime#15] = 43\n[Prime#16] = 47\nEnd Time:  2013-09-11 15:49:06\nDuration:  0 seconds.\n</code></pre> <p>You can exit the interactive session with:</p> <pre><code>$ exit\n</code></pre> <p>Note that you can now use this allocated node for 1 hour. After this hour you will be automatically disconnected. You can change this \"usage time\" by explicitly specifying a \"walltime\", i.e., the time that you want to work on this node. (Think of walltime as the time elapsed when watching the clock on the wall.)</p> <p>You can work for 3 hours by:</p> <pre><code>qsub -I -l walltime=03:00:00\n</code></pre> <p>If the walltime of the job is exceeded, the (interactive) job will be killed and your connection to the compute node will be closed. So do make sure to provide adequate walltime and that you save your data before your (wall)time is up (exceeded)! When you do not specify a walltime, you get a default walltime of 1 hour.</p>"}, {"location": "running_interactive_jobs/#interactive-jobs-with-graphical-support", "title": "Interactive jobs, with graphical support", "text": ""}, {"location": "running_interactive_jobs/#software-installation", "title": "Software Installation", "text": "<p>To display graphical applications from a Linux computer (such as the VSC clusters) on your machine, you need to install an X Window server on your local computer.</p> <p>An X Window server is packaged by default on most Linux distributions. If you have a graphical user interface this generally means that you are using an X Window server.</p> <p>The X Window system (commonly known as X11, based on its current major version being 11, or shortened to simply X) is the system-level software infrastructure for the windowing GUI on Linux, BSD and other UNIX-like operating systems. It was designed to handle both local displays, as well as displays sent across a network. More formally, it is a computer software system and network protocol that provides a basis for graphical user interfaces (GUIs) and rich input device capability for networked computers.</p>"}, {"location": "running_interactive_jobs/#connect-with-x-forwarding", "title": "Connect with X-forwarding", "text": "<p>In order to get the graphical output of your application (which is running on a compute node on the UAntwerpen-HPC) transferred to your personal screen, you will need to reconnect to the UAntwerpen-HPC with X-forwarding enabled, which is done with the \"-X\" option.</p> <p></p> <p>First exit and reconnect to the UAntwerpen-HPC with X-forwarding enabled:</p> <pre><code>$ exit\n$ ssh -X vsc20167@login.hpc.uantwerpen.be\n$ hostname -f\nln2.leibniz.uantwerpen.vsc\n</code></pre> <p>We first check whether our GUIs on the login node are decently forwarded to your screen on your local machine. An easy way to test it is by running a small X-application on the login node. Type:</p> <pre><code>$ xclock\n</code></pre> <p>And you should see a clock appearing on your screen.</p> <p></p> <p>You can close your clock and connect further to a compute node with again your X-forwarding enabled:</p> <pre><code>$ qsub -I -X\nqsub: waiting for job 433253.leibniz to start\nqsub: job 433253.leibniz ready\n$ hostname -f\nr1c02cn3.leibniz.antwerpen.vsc\n$ xclock\n</code></pre> <p>and you should see your clock again.</p>"}, {"location": "running_interactive_jobs/#run-simple-example", "title": "Run simple example", "text": "<p>We have developed a little interactive program that shows the communication in 2 directions. It will send information to your local screen, but also asks you to click a button.</p> <p>Now run the message program:</p> <pre><code>cd ~/examples/Running_interactive_jobs\n./message.py\n</code></pre> <p>You should see the following message appearing.</p> <p></p> <p>Click any button and see what happens.</p> <pre><code>-----------------------\n&lt; Enjoy the day! Mooh &gt;\n-----------------------\n     ^__^\n     (oo)\\_______\n     (__)\\       )\\/\\\n         ||----w |\n         ||     ||\n</code></pre>"}, {"location": "running_interactive_jobs/#run-your-interactive-application", "title": "Run your interactive application", "text": "<p>In this last example, we will show you that you can just work on this compute node, just as if you were working locally on your desktop. We will run the Fibonacci example of the previous chapter again, but now in full interactive mode in MATLAB.</p> <p>::: prompt :::</p> <p>And start the MATLAB interactive environment:</p> <p>::: prompt :::</p> <p>And start the fibo2.m program in the command window:</p> <p>::: prompt fx &gt;&gt; :::</p> <p>::: center  :::</p> <p>And see the displayed calculations, ...</p> <p>::: center  :::</p> <p>as well as the nice \"plot\" appearing:</p> <p>::: center  :::</p> <p>You can work in this MATLAB GUI, and finally terminate the application by entering \"\" in the command window again.</p> <p>::: prompt fx &gt;&gt; :::</p>"}, {"location": "running_jobs_with_input_output_data/", "title": "Running jobs with input/output data", "text": "<p>You have now learned how to start a batch job and how to start an interactive session. The next question is how to deal with input and output files, where your standard output and error messages will go to and where that you can collect your results.</p>"}, {"location": "running_jobs_with_input_output_data/#the-current-directory-and-output-and-error-files", "title": "The current directory and output and error files", "text": ""}, {"location": "running_jobs_with_input_output_data/#default-file-names", "title": "Default file names", "text": "<p>First go to the directory:</p> <pre><code>cd ~/examples/Running_jobs_with_input_output_data\n</code></pre> <p>Note</p> <p>If the example directory is not yet present, copy it to your home directory:</p> <pre><code>cp -r /apps/antwerpen/tutorials/Intro-HPC/examples ~/\n</code></pre> <p>List and check the contents with:</p> <pre><code>$ ls -l\ntotal 2304\n-rwxrwxr-x 1 vsc20167   682 Sep 13 11:34 file1.py\n-rw-rw-r-- 1 vsc20167   212 Sep 13 11:54 file1a.pbs\n-rw-rw-r-- 1 vsc20167   994 Sep 13 11:53 file1b.pbs\n-rw-rw-r-- 1 vsc20167   994 Sep 13 11:53 file1c.pbs\n-rw-r--r-- 1 vsc20167  1393 Sep 13 10:41 file2.pbs\n-rwxrwxr-x 1 vsc20167  2393 Sep 13 10:40 file2.py\n-rw-r--r-- 1 vsc20167  1393 Sep 13 10:41 file3.pbs\n-rwxrwxr-x 1 vsc20167  2393 Sep 13 10:40 file3.py\n</code></pre> <p>Now, let us inspect the contents of the first executable (which is just a Python script with execute permission).</p> file1.py<pre><code>#!/usr/bin/env python\n#\n# VSC        : Flemish Supercomputing Centre\n# Tutorial   : Introduction to HPC\n# Description: Writing to the current directory, stdout and stderr\n#\nimport sys\n\n# Step #1: write to a local file in your current directory\nlocal_f = open(\"Hello.txt\", 'w+')\nlocal_f.write(\"Hello World!\\n\")\nlocal_f.write(\"I am writing in the file:&lt;Hello.txt&gt;.\\n\")\nlocal_f.write(\"in the current directory.\\n\")\nlocal_f.write(\"Cheers!\\n\")\nlocal_f.close()\n\n# Step #2: Write to stdout\nsys.stdout.write(\"Hello World!\\n\")\nsys.stdout.write(\"I am writing to &lt;stdout&gt;.\\n\")\nsys.stdout.write(\"Cheers!\\n\")\n\n# Step #3: Write to stderr\nsys.stderr.write(\"Hello World!\\n\")\nsys.stderr.write(\"This is NO ERROR or WARNING.\\n\")\nsys.stderr.write(\"I am just writing to &lt;stderr&gt;.\\n\")\nsys.stderr.write(\"Cheers!\\n\")\n</code></pre> <p>The code of the Python script, is self explanatory:</p> <ol> <li> <p>In step 1, we write something to the file <code>hello.txt</code> in the current     directory.</p> </li> <li> <p>In step 2, we write some text to stdout.</p> </li> <li> <p>In step 3, we write to stderr.</p> </li> </ol> <p>Check the contents of the first job script:</p> file1a.pbs<pre><code>#!/bin/bash\n\n#PBS -l walltime=00:05:00\n\n# go to the (current) working directory (optional, if this is the\n# directory where you submitted the job)\ncd $PBS_O_WORKDIR  # the program itself\necho Start Job\ndate\n./file1.py\necho End Job\n</code></pre> <p>You'll see that there are NO specific PBS directives for the placement of the output files. All output files are just written to the standard paths.</p> <p>Submit it:</p> <pre><code>qsub file1a.pbs\n</code></pre> <p>After the job has finished, inspect the local directory again, i.e., the directory where you executed the qsub command:</p> <pre><code>$ ls -l\ntotal 3072\n-rw-rw-r-- 1 vsc20167   90 Sep 13 13:13 Hello.txt\n-rwxrwxr-x 1 vsc20167  693 Sep 13 13:03 file1.py*\n-rw-rw-r-- 1 vsc20167  229 Sep 13 13:01 file1a.pbs\n-rw------- 1 vsc20167   91 Sep 13 13:13 file1a.pbs.e433253.leibniz\n-rw------- 1 vsc20167  105 Sep 13 13:13 file1a.pbs.o433253.leibniz\n-rw-rw-r-- 1 vsc20167  143 Sep 13 13:07 file1b.pbs\n-rw-rw-r-- 1 vsc20167  177 Sep 13 13:06 file1c.pbs\n-rw-r--r-- 1 vsc20167 1393 Sep 13 10:41 file2.pbs\n-rwxrwxr-x 1 vsc20167 2393 Sep 13 10:40 file2.py*\n-rw-r--r-- 1 vsc20167 1393 Sep 13 10:41 file3.pbs\n-rwxrwxr-x 1 vsc20167 2393 Sep 13 10:40 file3.py*\n</code></pre> <p>Some observations:</p> <ol> <li> <p>The file <code>Hello.txt</code> was created in the current directory.</p> </li> <li> <p>The file <code>file1a.pbs.o433253.leibniz</code> contains all the text that was written to     the standard output stream (\"stdout\").</p> </li> <li> <p>The file <code>file1a.pbs.e433253.leibniz</code> contains all the text that was written to     the standard error stream (\"stderr\").</p> </li> </ol> <p>Inspect their contents ...\u00a0and remove the files</p> <pre><code>$ cat Hello.txt\n$ cat file1a.pbs.o433253.leibniz\n$ cat file1a.pbs.e433253.leibniz\n$ rm Hello.txt file1a.pbs.o433253.leibniz file1a.pbs.e433253.leibniz\n</code></pre> <p>Tip</p> <p>Type <code>cat H</code> and press the Tab button (looks like Tab), and it will expand into <code>cat Hello.txt</code>.</p>"}, {"location": "running_jobs_with_input_output_data/#filenames-using-the-name-of-the-job", "title": "Filenames using the name of the job", "text": "<p>Check the contents of the job script and execute it.</p> file1b.pbs<pre><code>#!/bin/bash\n\n#   Specify the \"name\" of the job\n#PBS -N my_serial_job         \n\ncd $PBS_O_WORKDIR  echo Start Job\ndate\n./file1.py\necho End Job\n</code></pre> <p>Inspect the contents again ...\u00a0and remove the generated files:</p> <pre><code>$ ls\nHello.txt file1a.pbs file1c.pbs file2.pbs file3.pbs my_serial_job.e433253.leibniz\nfile1.py* file1b.pbs file2.py* file3.py* my_serial_job.o433253.leibniz\n$ rm Hello.txt my_serial_job.*\n</code></pre> <p>Here, the option \"<code>-N</code>\" was used to explicitly assign a name to the job. This overwrote the JOBNAME variable, and resulted in a different name for the stdout and stderr files. This name is also shown in the second column of the \"<code>qstat</code>\" command. If no name is provided, it defaults to the name of the job script.</p>"}, {"location": "running_jobs_with_input_output_data/#user-defined-file-names", "title": "User-defined file names", "text": "<p>You can also specify the name of stdout and stderr files explicitly by adding two lines in the job script, as in our third example:</p> file1c.pbs<pre><code>#!/bin/bash\n\n# redirect standard output (-o) and error (-e)\n#PBS -o stdout.$PBS_JOBID\n#PBS -e stderr.$PBS_JOBID\n\ncd $PBS_O_WORKDIR  echo Start Job\ndate\n./file1.py\necho End Job\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#where-to-store-your-data-on-the-hpc", "title": "Where to store your data on the HPC", "text": "<p>The UAntwerpen-HPC cluster offers their users several locations to store their data. Most of the data will reside on the shared storage system, but all compute nodes also have their own (small) local disk.</p>"}, {"location": "running_jobs_with_input_output_data/#pre-defined-user-directories", "title": "Pre-defined user directories", "text": "<p>Three different pre-defined user directories are available, where each directory has been created for different purposes. The best place to store your data depends on the purpose, but also the size and type of usage of the data.</p> <p>The following locations are available:</p> Variable Description Long-term storage slow filesystem, intended for smaller files <code>$VSC_HOME</code> For your configuration files and other small files, see the section on your home directory. The default directory is <code>user/Antwerpen/xxx/vsc20167</code>. The same file system is accessible from all sites, i.e., you'll see the same contents in $VSC_HOME on all sites. <code>$VSC_DATA</code> A bigger \"workspace\", for datasets, results, logfiles, etc. see the section on your data directory. The default directory is <code>data/Antwerpen/xxx/vsc20167</code>. The same file system is accessible from all sites. Fast temporary storage <code>$VSC_SCRATCH_NODE</code> For temporary or transient data on the local compute node, where fast access is important; see the section on your scratch space. This space is available per node. The default directory is <code>/tmp</code>. On different nodes, you'll see different content. <code>$VSC_SCRATCH</code> For temporary or transient data that has to be accessible from all nodes of a cluster (including the login nodes). The default directory is <code>scratch/Antwerpen/xxx/vsc20167</code>. This directory is cluster- or site-specific: On different sites, and sometimes on different clusters on the same site, you'll get a different directory with different content. <code>$VSC_SCRATCH_SITE</code> Currently the same as $VSC_SCRATCH, but could be used for a scratch space shared across all clusters at a site in the future. See the section on your scratch space. <code>$VSC_SCRATCH_GLOBAL</code> Currently the same as $VSC_SCRATCH, but could be used for a scratch space shared across all clusters of the VSC in the future. See the section on your scratch space. <p>Since these directories are not necessarily mounted on the same locations over all sites, you should always (try to) use the environment variables that have been created.</p> <p>We elaborate more on the specific function of these locations in the following sections.</p>"}, {"location": "running_jobs_with_input_output_data/#your-home-directory-vsc_home", "title": "Your home directory ($VSC_HOME)", "text": "<p>Your home directory is where you arrive by default when you login to the cluster. Your shell refers to it as \"~\" (tilde), and its absolute path is also stored in the environment variable $VSC_HOME. Your home directory is shared across all clusters of the VSC.</p> <p>The data stored here should be relatively small (e.g., no files or directories larger than a few megabytes), and preferably should only contain configuration files. Note that various kinds of configuration files are also stored here, e.g., by MATLAB, Eclipse, ...</p> <p>The operating system also creates a few files and folders here to manage your account. Examples are:</p> File or Directory Description .ssh/ This directory contains some files necessary for you to login to the cluster and to submit jobs on the cluster. Do not remove them, and do not alter anything if you don't know what you are doing! .bash_profile When you login (type username and password) remotely via ssh, .bash_profile is executed to configure your shell before the initial command prompt. .bashrc This script is executed every time you start a session on the cluster: when you login to the cluster and when a job starts. .bash_history This file contains the commands you typed at your shell prompt, in case you need them again. <p>Furthermore, we have initially created some files/directories there (tutorial, docs, examples, examples.pbs) that accompany this manual and allow you to easily execute the provided examples.</p>"}, {"location": "running_jobs_with_input_output_data/#your-data-directory-vsc_data", "title": "Your data directory ($VSC_DATA)", "text": "<p>In this directory you can store all other data that you need for longer terms (such as the results of previous jobs, ...). It is a good place for, e.g., storing big files like genome data.</p> <p>The environment variable pointing to this directory is $VSC_DATA. This volume is shared across all clusters of the VSC. There are however no guarantees about the speed you will achieve on this volume. For guaranteed fast performance and very heavy I/O, you should use the scratch space instead. </p>"}, {"location": "running_jobs_with_input_output_data/#your-scratch-space-vsc_scratch", "title": "Your scratch space ($VSC_SCRATCH)", "text": "<p>To enable quick writing from your job, a few extra file systems are available on the compute nodes. These extra file systems are called scratch folders, and can be used for storage of temporary and/or transient data (temporary results, anything you just need during your job, or your batch of jobs).</p> <p>You should remove any data from these systems after your processing them has finished. There are no guarantees about the time your data will be stored on this system, and we plan to clean these automatically on a regular basis. The maximum allowed age of files on these scratch file systems depends on the type of scratch, and can be anywhere between a day and a few weeks. We don't guarantee that these policies remain forever, and may change them if this seems necessary for the healthy operation of the cluster.</p> <p>Each type of scratch has its own use:</p> <p>Node scratch ($VSC_SCRATCH_NODE).   Every node has its own scratch space, which is completely separated     from the other nodes. On some clusters, it will be on a local disk     in the node, while on other clusters it will be emulated through     another file server. Some drawbacks are that the storage can only be accessed on that     particular node and that the capacity is often very limited (e.g.,     100 GB). The performance will depend a lot on the particular     implementation in the cluster. In many cases, it will be     significantly slower than the cluster scratch as it typically     consists of just a single disk. However, if that disk is local to     the node (as on most clusters), the performance will not depend on     what others are doing on the cluster.</p> <p>Cluster scratch ($VSC_SCRATCH).  To allow a job running on multiple nodes (or multiple jobs running     on separate nodes) to share data as files, every node of the cluster     (including the login nodes) has access to this shared scratch     directory. Just like the home and data directories, every user has     its own scratch directory. Because this scratch is also available     from the login nodes, you could manually copy results to your data     directory after your job has ended. Also, this type of scratch is     usually implemented by running tens or hundreds of disks in parallel     on a powerful file server with fast connection to all the cluster     nodes and therefore is often the fastest file system available on a     cluster.     You may not get the same file system on different clusters, i.e.,     you may see different content on different clusters at the same     institute. </p> <pre><code>At the time of writing, the cluster scratch space is\nshared between both clusters at the University of Antwerp. This may change again in the future when storage gets updated.\n</code></pre> <p>Site scratch ($VSC_SCRATCH_SITE).  At the time of writing, the site scratch is just the same volume as     the cluster scratch, and thus contains the same data. In the future     it may point to a different scratch file system that is available     across all clusters at a particular site, which is in fact the case     for the cluster scratch on some sites.</p> <p>Global scratch ($VSC_SCRATCH_GLOBAL).   At the time of writing, the global scratch is just the same volume     as the cluster scratch, and thus contains the same data. In the     future it may point to a scratch file system that is available     across all clusters of the VSC, but at the moment of writing there     are no plans to provide this.</p>"}, {"location": "running_jobs_with_input_output_data/#pre-defined-quotas", "title": "Pre-defined quotas", "text": "<p>Quota is enabled on these directories, which means that the amount of data you can store there is limited. This holds for both the total size of all files as well as the total number of files that can be stored. The system works with a soft quota and a hard quota. You can temporarily exceed the soft quota, but you can never exceed the hard quota. The user will get warnings as soon as he exceeds the soft quota.</p> <p>The amount of data (called \"Block Limits\") that is currently in use by the user (\"KB\"), the soft limits (\"quota\") and the hard limits (\"limit\") for all 3 file-systems are always displayed when a user connects to the .</p> <p>With regards to the file limits, the number of files in use (\"files\"), its soft limit (\"quota\") and its hard limit (\"limit\") for the 3 file-systems are also displayed.</p> <p>::: prompt ---------------------------------------------------------- Your quota is:</p> <p>Block Limits Filesystem KB quota limit grace home 177920 3145728 3461120 none data 17707776 26214400 28835840 none scratch 371520 26214400 28835840 none</p> <p>File Limits Filesystem files quota limit grace home 671 20000 25000 none data 103079 100000 150000 expired scratch 2214 100000 150000 none</p> <p>:::</p> <p>Make sure to regularly check these numbers at log-in!</p> <p>The rules are:</p> <ol> <li> <p>You will only receive a warning when you have reached the soft limit     of either quota.</p> </li> <li> <p>You will start losing data and get I/O errors when you reach the     hard limit. In this case, data loss will occur since nothing can be     written anymore (this holds both for new files as well as for     existing files), until you free up some space by removing some     files. Also note that you will not be warned when data loss     occurs, so keep an eye open for the general quota warnings!</p> </li> <li> <p>The same holds for running jobs that need to write files: when you     reach your hard quota, jobs will crash.</p> </li> </ol> <p>We do realise that quota are often observed as a nuisance by users, especially if you're running low on it. However, it is an essential feature of a shared infrastructure. Quota ensure that a single user cannot accidentally take a cluster down (and break other user's jobs) by filling up the available disk space. And they help to guarantee a fair use of all available resources for all users. Quota also help to ensure that each folder is used for its intended purpose.</p>"}, {"location": "running_jobs_with_input_output_data/#writing-output-files", "title": "Writing Output files", "text": "<p>Tip</p> <p>Find the code of the exercises in \"~/examples/Running_jobs_with_input_output_data\"</p> <p>In the next exercise, you will generate a file in the $VSC_SCRATCH directory. In order to generate some CPU- and disk-I/O load, we will</p> <ol> <li> <p>take a random integer between 1 and 2000 and calculate all primes up     to that limit;</p> </li> <li> <p>repeat this action 30.000 times;</p> </li> <li> <p>write the output to the \"<code>primes_1.txt</code>\" output file in the     $VSC_SCRATCH-directory.</p> </li> </ol> <p>Check the Python and the PBS file, and submit the job: Remember that this is already a more serious (disk-I/O and computational intensive) job, which takes approximately 3 minutes on the UAntwerpen-HPC.</p> <pre><code>$ cat file2.py\n$ cat file2.pbs\n$ qsub file2.pbs\n$ qstat\n$ ls -l\n$ echo $VSC_SCRATCH\n$ ls -l $VSC_SCRATCH\n$ more $VSC_SCRATCH/primes_1.txt\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#reading-input-files", "title": "Reading Input files", "text": "<p>Tip</p> <p>Find the code of the exercise \"<code>file3.py</code>\" in \"~/examples/Running_jobs_with_input_output_data\".</p> <p>In this exercise, you will</p> <ol> <li> <p>Generate the file \"<code>primes_1.txt</code>\" again as in the previous     exercise;</p> </li> <li> <p>open the file;</p> </li> <li> <p>read it line by line;</p> </li> <li> <p>calculate the average of primes in the line;</p> </li> <li> <p>count the number of primes found per line;</p> </li> <li> <p>write it to the \"<code>primes_2.txt</code>\" output file in the     $VSC_SCRATCH-directory.</p> </li> </ol> <p>Check the Python and the PBS file, and submit the job:</p> <pre><code>$ cat file3.py\n$ cat file3.pbs\n$ qsub file3.pbs\n$ qstat\n$ ls -l\n$ more $VSC_SCRATCH/primes_2.txt\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#how-much-disk-space-do-i-get", "title": "How much disk space do I get?", "text": ""}, {"location": "running_jobs_with_input_output_data/#quota", "title": "Quota", "text": "<p>The available disk space on the UAntwerpen-HPC is limited. The actual disk capacity, shared by all users, can be found on the \"Available hardware\" page on the website. (https://vscdocumentation.readthedocs.io/en/latest/hardware.html) As explained in the section on predefined quota, this implies that there are also limits to:</p> <ul> <li> <p>the amount of disk space; and</p> </li> <li> <p>the number of files</p> </li> </ul> <p>that can be made available to each individual UAntwerpen-HPC user.</p> <p>The quota of disk space and number of files for each UAntwerpen-HPC user is:</p> <p>HOME         3 GB    20000   DATA        25 GB   100000   SCRATCH     25 GB   100000</p> <p>Tip</p> <p>The first action to take when you have exceeded your quota is to clean up your directories. You could start by removing intermediate, temporary or log files. Keeping your environment clean will never do any harm.</p> <p>Tip</p>"}, {"location": "running_jobs_with_input_output_data/#check-your-quota", "title": "Check your quota", "text": "<p>The \"<code>show_quota</code>\" command has been developed to show you the status of your quota in a readable format: <pre><code>$ show_quota\nVSC_DATA:    used 81MB (0%)  quota 25600MB\nVSC_HOME:    used 33MB (1%)  quota 3072MB\nVSC_SCRATCH:   used 28MB (0%)  quota 25600MB\nVSC_SCRATCH_GLOBAL: used 28MB (0%)  quota 25600MB\nVSC_SCRATCH_SITE:   used 28MB (0%)  quota 25600MB\n</code></pre></p> <p>or on the UAntwerp clusters <pre><code>$ module load scripts\n$ show_quota\nVSC_DATA:    used 81MB (0%)  quota 25600MB\nVSC_HOME:    used 33MB (1%)  quota 3072MB\nVSC_SCRATCH:   used 28MB (0%)  quota 25600MB\nVSC_SCRATCH_GLOBAL: used 28MB (0%)  quota 25600MB\nVSC_SCRATCH_SITE:   used 28MB (0%)  quota 25600MB\n</code></pre></p> <p>With this command, you can follow up the consumption of your total disk quota easily, as it is expressed in percentages. Depending of on which cluster you are running the script, it may not be able to show the quota on all your folders. E.g., when running on the tier-1 system Muk, the script will not be able to show the quota on $VSC_HOME or $VSC_DATA if your account is a KU\u00a0Leuven, UAntwerpen or VUB account.</p> <p>Once your quota is (nearly) exhausted, you will want to know which directories are responsible for the consumption of your disk space. You can check the size of all subdirectories in the current directory with the \"<code>du</code>\" (Disk Usage) command:</p> <pre><code>$ du\n256 ./ex01-matlab/log\n1536 ./ex01-matlab\n768 ./ex04-python\n512 ./ex02-python\n768 ./ex03-python\n5632\n</code></pre> <p>This shows you first the aggregated size of all subdirectories, and finally the total size of the current directory \".\" (this includes files stored in the current directory).</p> <p>If you also want this size to be \"human-readable\" (and not always the total number of kilobytes), you add the parameter \"-h\":</p> <pre><code>$ du -h\n256K ./ex01-matlab/log\n1.5M ./ex01-matlab\n768K ./ex04-python\n512K ./ex02-python\n768K ./ex03-python\n5.5M .\n</code></pre> <p>If the number of lower level subdirectories starts to grow too big, you may not want to see the information at that depth; you could just ask for a summary of the current directory:</p> <pre><code>$ du -s\n5632 .\n$ du -s -h\n</code></pre> <p>If you want to see the size of any file or top-level subdirectory in the current directory, you could use the following command:</p> <pre><code>$ du -h --max-depth 1\n1.5M ./ex01-matlab\n512K ./ex02-python\n768K ./ex03-python\n768K ./ex04-python\n256K ./example.sh\n1.5M ./intro-HPC.pdf\n700M ./.cache\n</code></pre> <p>Finally, if you don't want to know the size of the data in your current directory, but in some other directory (e.g., your data directory), you just pass this directory as a parameter. The command below will show the disk use in your home directory, even if you are currently in a different directory:</p> <pre><code>$ du -h --max-depth 1 $VSC_HOME\n22M /user/antwerpen/201/vsc20167/dataset01\n36M /user/antwerpen/201/vsc20167/dataset02\n22M /user/antwerpen/201/vsc20167/dataset03\n3.5M /user/antwerpen/201/vsc20167/primes.txt\n24M /user/antwerpen/201/vsc20167/.cache\n</code></pre> <p>We also want to mention the <code>tree</code> command, as it also provides an easy manner to see which files consumed your available quotas. Tree is a recursive directory-listing program that produces a depth indented listing of files.</p> <p>Try:</p> <pre><code>$ tree -s -d\n</code></pre> <p>However, we urge you to only use the <code>du</code> and <code>tree</code> commands when you really need them as they can put a heavy strain on the file system and thus slow down file operations on the cluster for all other users.</p>"}, {"location": "running_jobs_with_input_output_data/#groups", "title": "Groups", "text": "<p>Groups are a way to manage who can access what data. A user can belong to multiple groups at a time. Groups can be created and managed without any interaction from the system administrators.</p> <p>Please note that changes are not instantaneous: it may take about an hour for the changes to propagate throughout the entire HPC infrastructure.</p> <p>To change the group of a directory and it's underlying directories and files, you can use:</p> <pre><code>chgrp -R groupname directory\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#joining-an-existing-group", "title": "Joining an existing group", "text": "<ol> <li> <p>Get the group name you want to belong to.</p> </li> <li> <p>Go to https://account.vscentrum.be/django/group/new and fill in     the section named \"Join group\". You will be asked to fill in the     group name and a message for the moderator of the group, where you     identify yourself. This should look something like in the image below.</p> </li> <li> <p>After clicking the submit button, a message will be sent to the     moderator of the group, who will either approve or deny the request.     You will be a member of the group shortly after the group moderator     approves your request.</p> </li> </ol> <p></p>"}, {"location": "running_jobs_with_input_output_data/#creating-a-new-group", "title": "Creating a new group", "text": "<ol> <li> <p>Go to https://account.vscentrum.be/django/group/new and scroll     down to the section \"Request new group\". This should look something     like in the image below.</p> </li> <li> <p>Fill out the group name. This cannot contain spaces.</p> </li> <li> <p>Put a description of your group in the \"Info\" field.</p> </li> <li> <p>You will now be a member and moderator of your newly created group.</p> </li> </ol> <p></p>"}, {"location": "running_jobs_with_input_output_data/#managing-a-group", "title": "Managing a group", "text": "<p>Group moderators can go to https://account.vscentrum.be/django/group/edit to manage their group (see the image below). Moderators can invite and remove members. They can also promote other members to moderator and remove other moderators.</p> <p></p>"}, {"location": "running_jobs_with_input_output_data/#inspecting-groups", "title": "Inspecting groups", "text": "<p>You can get details about the current state of groups on the HPC infrastructure with the following command (<code>example</code> is the name of the group we want to inspect):</p> <pre><code>$ getent group example\nexample:*:1234567:vsc40001,vsc40002,vsc40003\n</code></pre> <p>We can see that the VSC id number is 1234567 and that there are three members in the group: <code>vsc40001</code>, <code>vsc40002</code> and <code>vsc40003</code>.</p>"}, {"location": "setting_up_python_virtual_environments/", "title": "Python Virtual Environments (venv's)", "text": ""}, {"location": "setting_up_python_virtual_environments/#introduction", "title": "Introduction", "text": "<p>A Python virtual environment (\"venv\" for short) is a tool to create an isolated Python workspace. Within this isolated environment, you can install additional Python packages without affecting the system-wide Python installation. Because a normal user cannot install packages globally, using a virtual environment allows you to install packages locally without needing administrator privileges. This is especially useful when you need to use a package that is not available as a module on the HPC cluster.</p> <p>Tip</p> <p>We recommend using the <code>vsc-venv</code> script to manage Python virtual environments. This script is available on the HPC clusters and simplifies the process of creating and managing virtual environments. For more information, see the section on vsc-venv. If you want to manage virtual environments manually, you can follow the instructions in the rest of this document.</p>"}, {"location": "setting_up_python_virtual_environments/#managing-python-environments", "title": "Managing Python Environments", "text": "<p>This section will explain how to create, activate, use and deactivate Python virtual environments.</p>"}, {"location": "setting_up_python_virtual_environments/#creating-a-python-virtual-environment", "title": "Creating a Python virtual environment", "text": "<p>A Python virtual environment can be created with the following command:</p> <pre><code>python -m venv myenv      # Create a new virtual environment named 'myenv'\n</code></pre> <p>This command creates a new subdirectory named <code>myenv</code> in the current working directory.  This directory will contain the packages, scripts, and binaries that are needed to manage the virtual environment.</p> <p>Warning</p> <p>When you create a virtual environment on top of a loaded Python module,  the environment becomes specific to the cluster you're working on.  This is because modules are built and optimized for the operating system and CPUs of the cluster. This means that you should create a new virtual environment for each cluster you work on.  See Creating a virtual environment for a specific cluster for more information.</p>"}, {"location": "setting_up_python_virtual_environments/#activating-a-virtual-environment", "title": "Activating a virtual environment", "text": "<p>To use the virtual environment, you need to activate it.  This will modify the shell environment to use the Python interpreter and packages from the virtual environment.</p> <pre><code>source myenv/bin/activate                    # Activate the virtual environment\n</code></pre>"}, {"location": "setting_up_python_virtual_environments/#installing-packages-in-a-virtual-environment", "title": "Installing packages in a virtual environment", "text": "<p>After activating the virtual environment, you can install additional Python packages with <code>pip install</code>:</p> <pre><code>pip install example_package1\npip install example_package2\n</code></pre> <p>These packages will be scoped to the virtual environment and will not affect the system-wide Python installation,  and are only available when the virtual environment is activated. No administrator privileges are required to install packages in a virtual environment.</p> <p>It is now possible to run Python scripts that use the installed packages in the virtual environment.</p> <p>Tip</p> <p>When creating a virtual environment, it's best to install only pure Python  packages. Pure Python packages consist solely of Python code and don't require compilation.  The installation method of these packages doesn't impact performance since they're not compiled.</p> <p>Compiled libraries with a Python wrapper (non-pure Python packages) are better loaded as modules  rather than installed in the virtual environment.  This is because modules are optimized for the HPC cluster\u2019s specific hardware and operating system.  If a non-pure Python package isn't available as a module, you can  submit a software installation request.</p> <p>To check if a package is available as a module, use:</p> <pre><code>module av package_name\n</code></pre> <p>Some Python packages are installed as extensions of modules. For example, <code>numpy</code>, <code>scipy</code> and <code>pandas</code> are  part of the <code>SciPy-bundle</code> module. You can use</p> <pre><code>module show module_name\n</code></pre> <p>to check which extensions are included in a module (if any).</p>"}, {"location": "setting_up_python_virtual_environments/#using-a-virtual-environment", "title": "Using a virtual environment", "text": "<p>Once the environment is activated and packages are installed,  you can run Python scripts that use the installed packages:</p> example.py<pre><code>import example_package1\nimport example_package2\n...\n</code></pre> <pre><code>python example.py\n</code></pre>"}, {"location": "setting_up_python_virtual_environments/#deactivating-a-virtual-environment", "title": "Deactivating a virtual environment", "text": "<p>When you are done using the virtual environment, you can deactivate it. To do that, run:</p> <pre><code>deactivate\n</code></pre>"}, {"location": "setting_up_python_virtual_environments/#combining-virtual-environments-with-centrally-installed-modules", "title": "Combining virtual environments with centrally installed modules", "text": "<p>You can combine Python packages installed in a virtual environment with environment modules.  The following script uses PyTorch (which is available as a module) and Poutyne (which we assume is not centrally installed):</p> pytorch_poutyne.py<pre><code>import torch\nimport poutyne\n\n...\n</code></pre> <p>We load a PyTorch package as a module and install Poutyne in a virtual environment:</p> <pre><code>module load PyTorch/2.1.2-foss-2023a\npython -m venv myenv\nsource myenv/bin/activate\npip install Poutyne\n</code></pre> <p>While the virtual environment is activated, we can run the script without any issues:</p> <pre><code>python pytorch_poutyne.py\n</code></pre> <p>Deactivate the virtual environment when you are done:</p> <pre><code>deactivate\n</code></pre>"}, {"location": "setting_up_python_virtual_environments/#creating-a-virtual-environment-for-a-specific-cluster", "title": "Creating a virtual environment for a specific cluster", "text": "<p>To create a virtual environment for a specific cluster, you need to start an interactive shell on that cluster. Let's say you want to create a virtual environment on the <code>donphan</code> cluster.</p> <pre><code>module swap cluster/donphan\nqsub -I\n</code></pre> <p>After some time, a shell will be started on the <code>donphan</code> cluster.  You can now create a virtual environment as described in the first section. This virtual environment can be used by jobs running on the <code>donphan</code> cluster.</p> <p>Naming a virtual environment</p> <p>When naming a virtual environment, it is recommended to include the name of the cluster it was created for. We can use the <code>$VSC_INSTITUTE_CLUSTER</code> variable to get the name of the current cluster.</p> <pre><code>python -m venv myenv_${VSC_INSTITUTE_CLUSTER}\n</code></pre>"}, {"location": "setting_up_python_virtual_environments/#example-python-job", "title": "Example Python job", "text": "<p>This section will combine the concepts discussed in the previous sections to:</p> <ol> <li>Create a virtual environment on a specific cluster.</li> <li>Combine packages installed in the virtual environment with modules.</li> <li>Submit a job script that uses the virtual environment.</li> </ol> <p>The example script that we will run is the following:</p> pytorch_poutyne.py<pre><code>import torch\nimport poutyne\n\nprint(f\"The version of PyTorch is: {torch.__version__}\")\nprint(f\"The version of Poutyne is: {poutyne.__version__}\")\n</code></pre> <p>First, we create a virtual environment on the <code>donphan</code> cluster:</p> <pre><code>module swap cluster/donphan\nqsub -I\n# Load module dependencies\nmodule load PyTorch/2.1.2-foss-2023a\npython -m venv myenv\nsource myenv/bin/activate\n# install virtual environment dependencies\npip install Poutyne\ndeactivate\n</code></pre> <p>Type <code>exit</code> to exit the interactive shell.  We now create a job script that loads the PyTorch module, enters the virtual environment and executes the script:</p> jobscript.pbs<pre><code>#!/bin/bash\n\n# Basic parameters\n#PBS -N python_job_example            ## Job name\n#PBS -l nodes=1:ppn=1                 ## 1 node, 1 processors per node\n#PBS -l walltime=01:00:00             ## Max time your job will run (no more than 72:00:00)\n\nmodule load PyTorch/2.1.2-foss-2023a  # Load the PyTorch module\ncd $PBS_O_WORKDIR                     # Change working directory to the location where the job was submitted\nsource myenv/bin/activate             # Activate the virtual environment\n\npython pytorch_poutyne.py             # Run your Python script, or any other command within the virtual environment\n\ndeactivate                            # Deactivate the virtual environment\n</code></pre> <p>Next, we submit the job script:</p> <pre><code>qsub jobscript.pbs\n</code></pre> <p>Two files will be created in the directory where the job was submitted:  <code>python_job_example.o433253.leibniz</code> and <code>python_job_example.e{{ job_id }}</code>, where 433253.leibniz is the id of your job. The <code>.o</code> file contains the output of the job.</p>"}, {"location": "setting_up_python_virtual_environments/#vsc-venv-python-virtual-environment-wrapper-script", "title": "vsc-venv: Python Virtual Environment Wrapper Script", "text": "<p><code>vsc-venv</code> is a script that encapsulates the creation and management of Python virtual environments.  This avoids multiple issues with the default <code>venv</code> included in Python (<code>python -m venv</code>).</p> <p>For instance, a virtual environment created for one cluster might not work on another.  Additionally, when activating a virtual environment,  the same centrally installed modules used during its creation must also be loaded. The <code>vsc-venv</code> command manages multiple virtual environments for different clusters in a transparent way,  while guaranteeing the same module environment.</p>"}, {"location": "setting_up_python_virtual_environments/#usage", "title": "Usage", "text": "<p>A virtual environment can be activated by running the following command:</p> <pre><code>$ module load vsc-venv\n$ source vsc-venv --activate --requirements requirements.txt [--modules modules.txt]\n</code></pre> <p>Here, <code>requirements.txt</code> is the path to a file containing the Python dependencies to install in the virtual environment. For more information on the <code>requirements.txt</code> file, see the pip documentation. The optional <code>--modules</code> option can be used to provide a <code>modules.txt</code> file that lists the modules to load before activating the virtual environment.</p> <p>Automatically, the modules are loaded and the environment is activated.  When running this command for the first time, the dependencies from the requirements file are installed.</p> <p>Now, the software can be run and Python packages installed in the virtual environment can be used, along with software provided via centrally installed modules.</p> <p>You can get insights on the current environment using the following commands: <pre><code>python --version    # Python version\npip list            # List of installed Python packages\nmodule list         # List of loaded modules\n</code></pre></p> <p>To deactivate the virtual environment, run:</p> <pre><code>$ source vsc-venv --deactivate\n</code></pre>"}, {"location": "setting_up_python_virtual_environments/#example", "title": "Example", "text": "<p>Suppose we are on the HPC-UGent Tier-2 login nodes, and we want to make a virtual environment for doduo, the default cluster. The following files are present in the current directory:</p> <p>modules.txt: <pre><code>SciPy-bundle/2023.11-gfbf-2023b\nPillow/10.2.0-GCCcore-13.2.0\n</code></pre></p> <p>and requirements.txt: <pre><code>beautifulsoup4==4.12.3\n</code></pre></p> <p>For more info on the <code>requirements.txt</code> file,  see the pip documentation.</p> <p>We run the following commands to enter the environment</p> <pre><code>$ module load vsc-venv\n$ source vsc-venv --activate --requirements requirements.txt --modules modules.txt\n</code></pre> <p>As this creates the virtual environment for the first time, a <code>venvs</code> subdirectory is created in the current directory.  Within <code>venvs/</code>, an additional subdirectory is created for the virtual environment: <code>venv-RHEL8-zen2</code>.</p> <p>Now, Python 3.12 is loaded and the <code>numpy</code> (provided by the <code>SciPy-bundle</code> module), <code>PIL</code> (provided by the <code>Pillow</code> module), and <code>bs4</code> Python packages can be used.</p> <p>To deactivate the virtual environment, run:</p> <pre><code>$ source vsc-venv --deactivate\n</code></pre>"}, {"location": "setting_up_python_virtual_environments/#making-a-virtual-environment-for-another-cluster", "title": "Making a virtual environment for another cluster", "text": "<p>If we want to create a virtual environment for another cluster, say donphan, we can use <code>vsc-venv</code> in an interactive job:</p> <pre><code>$ module swap cluster/donphan\n$ qsub -I\n$ cd my_project\n$ module load vsc-venv\n$ source vsc-venv --activate --requirements requirements.txt --modules modules.txt\n</code></pre> <p>the venvs folder now contains two folders:</p> <pre><code>$ ls venvs/\nvenv-RHEL8-cascadelake  \nvenv-RHEL8-zen2\n</code></pre>"}, {"location": "setting_up_python_virtual_environments/#troubleshooting", "title": "Troubleshooting", "text": ""}, {"location": "setting_up_python_virtual_environments/#illegal-instruction-error", "title": "Illegal instruction error", "text": "<p>Activating a virtual environment created on a different cluster can cause issues.  This happens because the binaries in the virtual environments from cluster A might not work with the CPU architecture of cluster B.</p> <p>For example, if we create a virtual environment on the gallade cluster,</p> <pre><code>module swap cluster/gallade\nqsub -I\n$ python -m venv myenv\n</code></pre> <p>return to the login node by pressing CTRL+D and try to use the virtual environment:</p> <pre><code>$ source myenv/bin/activate\n$ python\nIllegal instruction (core dumped)\n</code></pre> <p>we are presented with the illegal instruction error. More info on this here</p>"}, {"location": "setting_up_python_virtual_environments/#error-glibc-not-found", "title": "Error: GLIBC not found", "text": "<p>When running a virtual environment across clusters with different major OS versions,  you might encounter a variation of the following error:</p> <pre><code>python: /lib64/libc.so.6: version `GLIBC_2.34' not found (required by python)\n</code></pre> <p>Make sure you do not activate a virtual environment created on a different cluster. For more information on how to create a virtual environment for a specific cluster,  see Creating a virtual environment for a specific cluster. When following these steps, make sure you do not have any modules loaded when starting the interactive job.</p>"}, {"location": "setting_up_python_virtual_environments/#error-cannot-open-shared-object-file-no-such-file-or-directory", "title": "Error: cannot open shared object file: No such file or directory", "text": "<p>There are two main reasons why this error could occur.</p> <ol> <li>You have not loaded the <code>Python</code> module that was used to create the virtual environment.</li> <li>You loaded or unloaded modules while the virtual environment was activated.</li> </ol>"}, {"location": "setting_up_python_virtual_environments/#entering-a-virtual-environment-while-the-python-module-used-to-create-it-is-not-active", "title": "Entering a virtual environment while the Python module used to create it is not active", "text": "<p>If you loaded a <code>Python</code> module when creating a virtual environment, you need to make sure that the same module  is loaded when you enter the environment. This is because the virtual environment keeps a reference to the base python  used to create it.</p> <p>The following commands illustrate this issue:</p> <pre><code>$ module load Python/3.10.8-GCCcore-12.2.0  # Load a python module\n$ python -m venv myenv                      # Create a virtual environment with loaded python module\n$ module purge                              # unload all modules (WRONG!)\n$ source myenv/bin/activate                 # Activate the virtual environment\n$ python                                    # Start python\npython: error while loading shared libraries: libpython3.10.so.1.0: cannot open shared object file: No such file or directory\n</code></pre> <p>Here, the virtual environment tries to use the python module that was loaded when the environment was created. Since we used <code>module purge</code>, that module is no longer available. The solution is to load the same python module before activating the virtual environment:</p> <pre><code>module load Python/3.10.8-GCCcore-12.2.0  # Load the same python module\nsource myenv/bin/activate                 # Activate the virtual environment\n</code></pre>"}, {"location": "setting_up_python_virtual_environments/#modifying-modules-while-in-a-virtual-environment", "title": "Modifying modules while in a virtual environment", "text": "<p>You must not load or unload modules while in a virtual environment.  Loading and unloading modules modifies the <code>$PATH</code> variable in the current shell. When activating a virtual environment, it will store the <code>$PATH</code> variable of the shell at that moment. If you modify the <code>$PATH</code> variable while in a virtual environment by loading or unloading modules, and deactivate the virtual environment, the <code>$PATH</code> variable will be reset to the one stored in the virtual environment. Trying to use those modules will lead to errors:</p> <pre><code>$ module load Python/3.10.8-GCCcore-12.2.0  # Load a python module\n$ python -m venv myenv                      # Create a virtual environment\n$ source myenv/bin/activate                 # Activate the virtual environment (saves state of $PATH)\n$ module purge                              # Unload all modules (modifies the $PATH)\n$ deactivate                                # Deactivate the virtual environment (resets $PATH to saved state)\n$ python                                    # PATH contains a reference to the unloaded module\npython: error while loading shared libraries: libpython3.10.so.1.0: cannot open shared object file: No such file or directory\n</code></pre> <p>The solution is to only modify modules when not in a virtual environment.</p>"}, {"location": "singularity/", "title": "Singularity", "text": ""}, {"location": "singularity/#what-is-singularity", "title": "What is Singularity?", "text": "<p>Singularity is an open-source computer program that performs operating-system-level virtualization (also known as containerisation).</p> <p>One of the main uses of Singularity is to bring containers and reproducibility to scientific computing and the high-performance computing (HPC) world. Using Singularity containers, developers can work in reproducible environments of their choosing and design, and these complete environments can easily be copied and executed on other platforms.</p> <p>For more general information about the use of Singularity, please see the official documentation at https://docs.sylabs.io/guides/main/user-guide.</p> <p>This documentation only covers aspects of using Singularity on the infrastructure.</p>"}, {"location": "singularity/#restrictions-on-image-location", "title": "Restrictions on image location", "text": "<p>Some restrictions have been put in place on the use of Singularity. This is mainly done for performance reasons and to avoid that the use of Singularity impacts other users on the system.</p> <p>The Singularity image file must be located on either one of the scratch filesystems, the local disk of the workernode you are using or <code>/dev/shm</code>. The centrally provided <code>singularity</code> command will refuse to run using images that are located elsewhere, in particular on the <code>$VSC_HOME</code>, <code>/apps</code> or <code>$VSC_DATA</code> filesystems.</p> <p>In addition, this implies that running containers images provided via a URL (e.g., <code>shub://...</code> or <code>docker://...</code>) will not work.</p> <p>If these limitations are a problem for you, please let us know via .</p>"}, {"location": "singularity/#available-filesystems", "title": "Available filesystems", "text": "<p>All HPC-UGent shared filesystems will be readily available in a Singularity container, including the home, data and scratch filesystems, and they will be accessible via the familiar <code>$VSC_HOME</code>, <code>$VSC_DATA*</code> and <code>$VSC_SCRATCH*</code> environment variables.</p>"}, {"location": "singularity/#singularity-images", "title": "Singularity Images", "text": ""}, {"location": "singularity/#creating-singularity-images", "title": "Creating Singularity images", "text": "<p>Creating new Singularity images or converting Docker images, by default, requires admin privileges, which is obviously not available on the infrastructure. However, if you use the <code>--fakeroot</code> option, you can make new Singularity images or convert Docker images.</p> <p>When you make Singularity or convert Docker images you have some restrictions:</p> <ul> <li>Due to the nature of <code>--fakeroot</code> option, we recommend to write your     singularity image to a globally writable location, like <code>/tmp</code>, or     <code>/local</code> directories. Once the images is created, you should move it     to your desired destination.</li> </ul>"}, {"location": "singularity/#converting-docker-images", "title": "Converting Docker images", "text": "<p>For more information on converting existing Docker images to Singularity images, see https://docs.sylabs.io/guides/main/user-guide/singularity_and_docker.html.</p> <p>We strongly recommend the use of Docker Hub, see https://hub.docker.com/ for more information.</p>"}, {"location": "singularity/#execute-our-own-script-within-our-container", "title": "Execute our own script within our container", "text": "<p>Copy testing image from <code>/apps/gent/tutorials/Singularity</code> to <code>$VSC_SCRATCH</code>:</p> <p>::: prompt :::</p> <p>Create a job script like:</p> <p>Create an example <code>myscript.sh</code>:</p> <p>::: code bash #!/bin/bash</p> <p># prime factors factor 1234567 :::</p>"}, {"location": "singularity/#tensorflow-example", "title": "Tensorflow example", "text": "<p>We already have a Tensorflow example image, but you can also convert the Docker image (see https://hub.docker.com/r/tensorflow/tensorflow) to a Singularity image yourself</p> <p>Copy testing image from <code>/apps/gent/tutorials</code> to <code>$VSC_SCRATCH</code>:</p> <p>::: prompt :::</p> <p>You can download <code>linear_regression.py</code> from the official Tensorflow repository.</p>"}, {"location": "singularity/#mpi-example", "title": "MPI example", "text": "<p>It is also possible to execute MPI jobs within a container, but the following requirements apply:</p> <ul> <li> <p>Mellanox IB libraries must be available from the container (install     the <code>infiniband-diags</code>, <code>libmlx5-1</code> and <code>libmlx4-1</code> OS packages)</p> </li> <li> <p>Use modules within the container (install the <code>environment-modules</code>     or <code>lmod</code> package in your container)</p> </li> <li> <p>Load the required module(s) before <code>singularity</code> execution.</p> </li> <li> <p>Set <code>C_INCLUDE_PATH</code> variable in your container if it is required     during compilation time     (<code>export C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu/:$C_INCLUDE_PATH</code>     for Debian flavours)</p> </li> </ul> <p>Copy the testing image from <code>/apps/gent/tutorials/Singularity</code> to <code>$VSC_SCRATCH</code></p> <p>::: prompt :::</p> <p>For example to compile an MPI example:</p> <p>::: prompt :::</p> <p>Example MPI job script:</p>"}, {"location": "software_installation_requests/", "title": "Software installation requests", "text": ""}, {"location": "software_installation_requests/#submitting-a-request", "title": "Submitting a request", "text": "<p>To submit a software installation request, please use the available request form:</p> <p>https://www.ugent.be/hpc/en/support/software-installation-request</p>"}, {"location": "software_installation_requests/#software-usage-report", "title": "Software usage report", "text": "<p>By submitting a software installation request, you are committing to sending back a software usage report.</p> <p>Use the form, Luke</p> <p>To submit a software usage report you should use to dedicated form that is available in the HPC-UGent web portal:</p> <p>https://login.hpc.ugent.be/pun/sys/dashboard/support?category=swreport</p> <p>A software usage report provides answers to the following questions:</p> <ul> <li>How many times have you used this software so far?</li> <li>On which system(s) did you use this software?</li> <li>Is the software working as it should? If not, please elaborate.</li> <li>Is the performance of the software as you expect it to be? If not, please elaborate (and consider reporting problems).</li> <li>How often will you be using this software going forward?</li> <li>Describe how this software will help you with future research output.</li> <li>Provide an example of how to use this software, including the necessary information to run this example (where to get the input files, etc.), so we can consider documenting its usage.</li> </ul> <p>Timing</p> <p>Please provide the report no later than 1 month after the completion of the software installation.</p> <p>Take into account the following guidelines:</p> <ul> <li>Make sure to use the correct ticket number in the form to submit a software usage report;</li> <li>Keep it concise: a couple of sentences per answer is sufficient;</li> <li>Please submit one software usage report per ticket that corresponds to an installation request.   Do not combine usage reports for multiple requests, unless you requested multiple (related) software installations in   a single request (single ticket number).</li> </ul>"}, {"location": "teaching_training/", "title": "Teaching and training", "text": "<p>The HPC infrastructure can be used for teaching and training purposes, and HPC-UGent provides support for getting you organized.</p> <p>As a reminder, both Bachelor and Master students are allowed to use the HPC infrastructure, and it is also possible to organize trainings (or workshops). But in either case we do recommend preparing a fallback plan in case the HPC infrastructure becomes unavailable, e.g. because of an unexpected power failure.</p> <p>In general, we advise the use of the HPC webportal in combination with the interactive cluster for teaching and training, but deviations are possible upon request.</p> <p>In order to prepare things, make a teaching request by contacting the UAntwerpen-HPC with the following information (explained further below):</p> <ul> <li>Title and nickname</li> <li>Start and end date for your course or training</li> <li>VSC-ids of all teachers/trainers</li> <li>Participants based on UGent Course Code and/or list of VSC-ids</li> <li>Optional information<ul> <li>Additional storage requirements<ul> <li>Shared folder</li> <li>Groups folder for collaboration</li> <li>Quota</li> </ul> </li> <li>Reservation for resource requirements beyond the interactive cluster</li> <li>Ticket number for specific software needed for your course/training</li> <li>Details for a custom Interactive Application in the webportal</li> </ul> </li> </ul> <p>In addition, it could be beneficial to set up a short Teams call with HPC-UGent team members, especially if you are using a complex workflow for your course/workshop.</p> <p>Please make these requests well in advance, several weeks before the start of your course/workshop.</p>"}, {"location": "teaching_training/#title-and-nickname", "title": "Title and nickname", "text": "<p>The title of the course or training can be used in e.g. reporting.</p> <p>The nickname is a single (short) word or acronym that the students or participants can easily recognise, e.g. in the directory structure. In case of UGent courses, this is used next to the course code to help identify the course directory in the list of all courses one might follow.</p> <p>When choosing the nickname, try to make it unique, but this is not enforced nor checked.</p>"}, {"location": "teaching_training/#start-and-end-date", "title": "Start and end date", "text": "<p>The start date (and time) is used as a target for the HPC-UGent team to set up your course requirements. But note that this target is best-effort, depending on the load of the support team and the complexity of your requirements. Requests should be made well in advance, at least several weeks before the actual start of your course. The sooner you make the request, the better.</p> <p>The end date is used to automatically perform a cleanup when your course/workshop has finished,  as described in the course data policy:</p> <ul> <li>Course group and subgroups will be deactivated</li> <li>Residual data in the course directories will be archived or deleted</li> <li>Custom Interactive Applications will be disabled</li> </ul>"}, {"location": "teaching_training/#teachers-and-trainers", "title": "Teachers and trainers", "text": "<p>A course group is created with all students or participants, and the teachers or trainers are the group moderators (and also member of this group).</p> <p>This course group and the moderators group are used to manage the different privileges: moderators have additional privileges over non-moderator members e.g. they have read/write access in specific folders, can manage subgroups, ....</p> <p>Provide us with a list of all the VSC-ids for the teachers or trainers to indentify the moderators.</p>"}, {"location": "teaching_training/#participants", "title": "Participants", "text": "<p>The management of the list of students or participants depends if this is a UGent course or a training/workshop. </p>"}, {"location": "teaching_training/#ugent-courses", "title": "UGent Courses", "text": "<p>Based on the Course Code, we can create VSC accounts for all UGent students that have officially enrolled in your UGent course (if they do not have an account already). Students will then no longer have to take steps themselves to request a VSC account. The students do need to be officially enrolled, so that they are linked to your UGent Course Code.</p> <p>The created VSC accounts will be accounts without an ssh-key. This allows the students to use e.g. the portal, but if they require ssh access to the infrastructure, they will have to add an SSH key themselves.</p> <p>Additionally, for external, non-UGent students the teaching request must contain the list of their VSC-ids, so they can be added to the course group.</p> <p>A course group will be automatically created for your course, with all VSC accounts of registered students as member. Typical format <code>gcourse_&lt;coursecode&gt;_&lt;year&gt;</code>, e.g. <code>gcourse_e071400_2023</code>. Teachers are moderator of this course group, but will not be able to add unregistered students or moderators. VSC accounts that are not linked to the Course Code will be automatically removed from the course group. To get a student added to the course group, make sure that the student becomes officially enrolled in your course.</p>"}, {"location": "teaching_training/#trainings-and-workshops", "title": "Trainings and workshops", "text": "<p>(Currently under construction:) For trainings, workshops or courses that do not have a Course Code, you need to provide us with the list of all VSC-ids. A group will be made, based on the name of the workshop, with all VSC-ids as member. Teachers/trainers will be able to add/remove VSC accounts from this course group. But students will have to follow the procedure to request a VSC account themselves. There will be no automation.</p>"}, {"location": "teaching_training/#dedicated-storage", "title": "Dedicated storage", "text": "<p>For every course, a dedicated course directory will be created on the DATA filesystem under <code>/data/gent/courses/&lt;year&gt;/&lt;nickname&gt;_&lt;coursecode&gt;</code> (e.g. <code>/data/gent/courses/2023/cae_e071400</code>).</p> <p>This directory will be accessible by all members of your course group. (Hence, it is no longer necessary to set up dangerous workarounds e.g. invite course members to your virtual organization.)</p> <p>Every course directory will always contain the folders:</p> <ul> <li><code>input</code><ul> <li>ideally suited to distribute input data such as common datasets</li> <li>moderators have read/write access</li> <li>group members (students) only have read access</li> </ul> </li> <li><code>members</code><ul> <li>this directory contains a personal folder for every student in your course <code>members/vsc&lt;01234&gt;</code></li> <li>only this specific VSC-id will have read/write access to this folder</li> <li>moderators have read access to this folder</li> </ul> </li> </ul>"}, {"location": "teaching_training/#shared-and-groups", "title": "Shared and groups", "text": "<p>Optionally, we can also create these folders:</p> <ul> <li><code>shared</code><ul> <li>this is a folder for sharing files between any and all group members</li> <li>all group members and moderators have read/write access</li> <li>beware that group members will be able to alter/delete each others files in this folder if they set   permissions in specific/non-default ways</li> </ul> </li> <li><code>groups</code><ul> <li>a number of <code>groups/group_&lt;01&gt;</code> folders are created under the <code>groups</code> folder</li> <li>these folders are suitable if you want to let your students collaborate closely in smaller groups</li> <li>each of these <code>group_&lt;01&gt;</code> folders are owned by a dedicated group</li> <li>teachers are automatically made moderators of these dedicated groups</li> <li>moderators can populate these groups with VSC-ids of group members in the VSC accountpage   or ask the students to invite themselves via group edit.   When students invite them self, moderators still need to approve the group invites.</li> <li>only these VSC-ids will then be able to access a <code>group_&lt;01&gt;</code> folder, and will have read/write access.</li> </ul> </li> </ul> <p>If you need any of these additional folders, do indicate under Optional storage requirements of your teaching request:</p> <ul> <li><code>shared</code>: <code>yes</code></li> <li><code>subgroups</code>: <code>&lt;number of (sub)groups&gt;</code></li> </ul>"}, {"location": "teaching_training/#course-quota", "title": "Course Quota", "text": "<p>There are 4 quota settings that you can choose in your teaching request in the case the defaults are not sufficient:</p> <ul> <li>overall quota (defaults 10 GB volume and 20k files) are for the moderators and can be used for e.g. the <code>input</code> folder.</li> <li>member quota (defaults 5 GB volume and 10k files) are per student/participant</li> </ul> <p>The course data usage is not accounted for any other quota (like VO quota). It is solely dependent on these settings.</p>"}, {"location": "teaching_training/#course-data-policy", "title": "Course data policy", "text": "<p>The data policy for the dedicated course storage is the following: on the indicated end date of your course, the course directory will be made read-only to the moderators (possibly on the form of an archive zipfile). One year after the end date it will be permanently removed. We assume that teachers/trainers always have an own copy of the course data as a starting point for a next course.</p>"}, {"location": "teaching_training/#resource-requirements-beyond-the-interactive-cluster", "title": "Resource requirements beyond the interactive cluster", "text": "<p>We assume that your course requirements are such that the interactive cluster can be used. If these resources are insufficient, you will need to request and motivate a reservation.</p> <p>Indicate which cluster you would need and the number of nodes, cores and/or GPUs. Also, clearly indicate when you would need these resources, i.e. the dates and times of each course session.</p> <p>Be aware that students will have no access to the reservation outside the course sessions. This might be relevant when requesting a custom application.</p> <p>Reservations take away precious resources for all HPC users, so only request this when it is really needed for your course. In our experience, the interactive cluster is more than sufficient for the majority of cases.</p>"}, {"location": "teaching_training/#specific-software", "title": "Specific software", "text": "<p>In case you need software for your course/workshop that is unavailable or that needs to be updated, make a separate software installation request. Add the OTRS ticket number in your teaching request.</p> <p>We will try to make the software available before the start of your course/workshop. But this is always best effort, depending on the load of the support team and the complexity of your software request. Typically, software installation requests must be made at least one month before the course/workshop starts.</p> <p>Ideally, courses/workshops rely on software that is already in use (and thus also well tested).</p>"}, {"location": "teaching_training/#custom-interactive-application-in-the-webportal", "title": "Custom Interactive Application in the webportal", "text": "<p>HPC-UGent can create a custom interactive application in the web portal for your course/workshop. Typically, this is a generic interactive application such as cluster desktop, Jupyter notebook, ... in which a number of options are preset or locked down: e.g. the number of cores, software version, cluster selection, autostart code, etc. This could make it easier for teachers and students, since students are less prone to making mistakes and do not have to spend time copy-pasting specific settings.</p> <p>A custom interactive application will only be available to the members of your course group. It will appear in the <code>Interactive Apps</code> menu in the webportal, under the section <code>Courses</code>. After the indicated end date of your course, this application will be removed.</p> <p>If you would like this for your course, provide more details in your teaching request, including:</p> <ul> <li> <p>what interactive application would you like to get launched (cluster desktop, Jupyter Notebook, ...)</p> </li> <li> <p>which cluster you want to use</p> </li> <li> <p>how many nodes/cores/GPUs are needed</p> </li> <li> <p>which software modules you are loading</p> </li> <li> <p>custom code you are launching (e.g. autostart a GUI)</p> </li> <li> <p>required environment variables that you are setting</p> </li> <li> <p>...</p> </li> </ul> <p>We will try to make the custom interactive application available before the start of your course/workshop, but this is always best effort, depending on the load of the support team and the complexity of your request.</p> <p>A caveat for the teacher and students is that students do not learn to work with the generic application, and do not see the actual commands or customization code. Therefore, per custom interactive application, HPC-UGent will make a dedicated section in the web portal chapter of the HPC user documentation. This section will briefly explain what happens under the hood of the interactive application. We would recommend that you as a teacher take some time to show and explain this to the students. Note that the custom interactive application will disappear for students after the indicated end of your course, but the section in the web portal will remain there for several years, for reference.</p>"}, {"location": "torque_frontend_via_jobcli/", "title": "Torque frontend via jobcli", "text": ""}, {"location": "torque_frontend_via_jobcli/#what-is-torque", "title": "What is Torque", "text": "<p>Torque is a resource manager for submitting and managing jobs on an HPC cluster. It is an implementation of PBS (Portable Batch System). Torque is not widely used anymore, so the UAntwerpen-HPC no longer uses Torque in the backend since 2021 in favor of Slurm. The Torque user interface, which consists of commands like <code>qsub</code> and <code>qstat</code>, was kept however, to avoid that researchers had to learn other commands to submit and manage jobs.</p>"}, {"location": "torque_frontend_via_jobcli/#slurm-backend", "title": "Slurm backend", "text": "<p>Slurm is a resource manager for submitting and managing jobs on an HPC cluster, similar to Torque (but more advanced/modern in some ways). Currently, Slurm is the most popular workload manager on HPC systems worldwide, but it has a user interface that is different and in some sense less user friendly than Torque/PBS.</p>"}, {"location": "torque_frontend_via_jobcli/#jobcli", "title": "jobcli", "text": "<p>Jobcli is a Python library that was developed by UAntwerpen-HPC to make it possible for the UAntwerpen-HPC to use a Torque frontend and a Slurm backend. In addition to that, it adds some additional options for Torque commands. Put simply, jobcli can be thought of as a Python script that \"translates\" Torque commands into equivalent Slurm commands, and in the case of <code>qsub</code> also makes some changes to the provided job script to make it compatible with Slurm.</p>"}, {"location": "torque_frontend_via_jobcli/#additional-options-for-torque-commands-supported-by-jobcli", "title": "Additional options for Torque commands supported by jobcli", "text": ""}, {"location": "torque_frontend_via_jobcli/#help-option", "title": "help option", "text": "<p>Adding <code>--help</code> to a Torque command when using it on the UAntwerpen-HPC will output an extensive overview of all supported options for that command, including all possible options for that command (including the original ones from Torque and the ones added by jobcli) and a short description for each one.</p> <p>For example: <pre><code>$ qsub --help\nusage: qsub [--version] [--debug] [--dryrun] [--pass OPTIONS] [--dump PATH]...\n\nSubmit job script\n\npositional arguments:\n  script_file_path      Path to job script to be submitted (default: read job\n                        script from stdin)\n\noptional arguments:\n  -A ACCOUNT            Charge resources used by this job to specified account\n  ...\n</code></pre></p>"}, {"location": "torque_frontend_via_jobcli/#dryrun-option", "title": "dryrun option", "text": "<p>Adding <code>--dryrun</code> to a Torque command when using it on the UAntwerpen-HPC will show the user what Slurm commands are generated by that Torque command by jobcli. Using <code>--dryrun</code> will not actually execute the Slurm backend command.</p> <p>See also the examples below.</p>"}, {"location": "torque_frontend_via_jobcli/#debug-option", "title": "debug option", "text": "<p>Similarly to <code>--dryrun</code>, adding <code>--debug</code> to a Torque command when using it on the UAntwerpen-HPC will show the user what Slurm commands are generated by that Torque command by jobcli. However in contrast to <code>--dryrun</code>, using <code>--debug</code> will actually run the Slurm backend command.</p> <p>See also the examples below.</p>"}, {"location": "torque_frontend_via_jobcli/#examples", "title": "Examples", "text": "<p>The following examples illustrate the working of the <code>--dryrun</code> and <code>--debug</code> options with an example jobscript.</p> <p><code>example.sh</code>:</p> <pre><code>#/bin/bash\n#PBS -l nodes=1:ppn=8\n#PBS -l walltime=2:30:00\n\nmodule load SciPy-bundle/2023.11-gfbf-2023b\n\npython script.py &gt; script.out.${PBS_JOBID}\n</code></pre>"}, {"location": "torque_frontend_via_jobcli/#example-of-the-dryrun-option", "title": "Example of the dryrun option", "text": "<p>Running the following command:</p> <pre><code>$ qsub --dryrun example.sh -N example\n</code></pre> <p>will generate this output:</p> <p><pre><code>Command that would have been run:\n---------------------------------\n\n/usr/bin/sbatch\n\nJob script that would have been submitted:\n------------------------------------------\n\n#!/bin/bash\n#SBATCH --chdir=\"/user/gent/400/vsc20167\"\n#SBATCH --error=\"/kyukon/home/gent/400/vsc20167/examples/%x.e%A\"\n#SBATCH --export=\"NONE\"\n#SBATCH --get-user-env=\"60L\"\n#SBATCH --job-name=\"example\"\n#SBATCH --mail-type=\"NONE\"\n#SBATCH --nodes=\"1\"\n#SBATCH --ntasks-per-node=\"8\"\n#SBATCH --ntasks=\"8\"\n#SBATCH --output=\"/kyukon/home/gent/400/vsc20167/examples/%x.o%A\"\n#SBATCH --time=\"02:30:00\"\n\n### (start of lines that were added automatically by jobcli)\n#\n# original submission command:\n# qsub --dryrun example.sh -N example\n#\n# directory where submission command was executed:\n# /kyukon/home/gent/400/vsc20167/examples\n#\n# original script header:\n# #PBS -l nodes=1:ppn=8\n# #PBS -l walltime=2:30:00\n#\n### (end of lines that were added automatically by jobcli)\n\n#/bin/bash\n\nmodule load SciPy-bundle/2023.11-gfbf-2023b\n\npython script.py &gt; script.out.${PBS_JOBID}\n</code></pre> This output consist of a few components. For our example the most important lines are the ones that start with <code>#SBATCH</code> since these contain the translation of the Torque commands to Slurm commands. For example the job-name is the one we specified with the <code>-N</code> option in the command.</p> <p>With this dryrun, you can see that the only changes were made to the header, the job script itself is not changed at all. If the job script were to use any PBS-related structures, like <code>$PBS_JOBID</code>, they are retained. Slurm is configured such on the UAntwerpen-HPC that common <code>PBS_*</code> environment variables are defined in the job environment, next to the Slurm equivalents.</p>"}, {"location": "torque_frontend_via_jobcli/#example-of-the-debug-option", "title": "Example of the debug option", "text": "<p>Similarly to the <code>--dryrun</code> example, we start by running the following command:</p> <pre><code>$ qsub --debug example.sh -N example\n</code></pre> <p>which generates this output:</p> <p><pre><code>DEBUG: Submitting job script location at example.sh\nDEBUG: Generated script header\n#SBATCH --chdir=\"/user/gent/400/vsc20167\"\n#SBATCH --error=\"/kyukon/home/gent/400/vsc20167/examples/%x.e%A\"\n#SBATCH --export=\"NONE\"\n#SBATCH --get-user-env=\"60L\"\n#SBATCH --job-name=\"example\"\n#SBATCH --mail-type=\"NONE\"\n#SBATCH --nodes=\"1\"\n#SBATCH --ntasks-per-node=\"8\"\n#SBATCH --ntasks=\"8\"\n#SBATCH --output=\"/kyukon/home/gent/400/vsc20167/examples/%x.o%A\"\n#SBATCH --time=\"02:30:00\"\nDEBUG: HOOKS: Looking for hooks in directory '/etc/jobcli/hooks'\nDEBUG: HOOKS: Directory '/etc/jobcli/hooks' does not exist, so no hooks there\nDEBUG: Running command '/usr/bin/sbatch'\n64842138\n</code></pre> The output once again consists of the translated Slurm commands with some additional debug information and a job id for the job that was submitted.</p>"}, {"location": "torque_options/", "title": "TORQUE options", "text": ""}, {"location": "torque_options/#torque-submission-flags-common-and-useful-directives", "title": "TORQUE Submission Flags: common and useful directives", "text": "<p>Below is a list of the most common and useful directives.</p> Option System type Description Jobscript comment -k All Send \"stdout\" and/or \"stderr\" to your home directory when the job runs #PBS -k o or #PBS -k e or #PBS -koe -l All Precedes a resource request, e.g., processors, wallclock -M All Send an e-mail message to an alternative e-mail address #PBS -M me@mymail.be -m All Send an e-mail when a job begins execution, ends, or aborts #PBS -m b or #PBS -m be or #PBS -m ba mem Shared Memory Memory &amp; Specifies the amount of memory you need for a job. #PBS -I mem=90gb mpiproces Clusters Number of processes per node on a cluster. This usually equals the number of processors on a node. #PBS -l mpiprocs=4 -N All Give your job a unique name #PBS -N galaxies1234 -ncpus Shared Memory The number of processors to use for a shared memory job. #PBS ncpus=4 -r All Control whether or not jobs should automatically re-run from the start if the system crashes or reboots. #PBS -r n or #PBS -r y select Clusters Number of compute nodes to use. Usually combined with the mpiprocs directive #PBS -l select=2 -V All Ensure that the environment in which the job runs is the same as the one in which it was submitted #PBS -V Walltime All Maximum time a job can run before being stopped. Format is HH:MM:SS #PBS -l walltime=12:00:00"}, {"location": "torque_options/#environment-variables-in-batch-job-scripts", "title": "Environment Variables in Batch Job Scripts", "text": "<p>TORQUE-related environment variables in batch job scripts.</p> <pre><code># Using PBS - Environment Variables:\n# When a batch job starts execution, a number of environment variables are\n# predefined, which include:\n#\n#      Variables defined on the execution host.\n#      Variables exported from the submission host with\n#                -v (selected variables) and -V (all variables).\n#      Variables defined by PBS.\n#\n# The following reflect the environment where the user ran qsub:\n# PBS_O_HOST    The host where you ran the qsub command.\n# PBS_O_LOGNAME Your user ID where you ran qsub.\n# PBS_O_HOME    Your home directory where you ran qsub.\n# PBS_O_WORKDIR The working directory where you ran qsub.\n#\n# These reflect the environment where the job is executing:\n# PBS_ENVIRONMENT       Set to PBS_BATCH to indicate the job is a batch job,\n#         or to PBS_INTERACTIVE to indicate the job is a PBS interactive job.\n# PBS_O_QUEUE   The original queue you submitted to.\n# PBS_QUEUE     The queue the job is executing from.\n# PBS_JOBID     The job's PBS identifier.\n# PBS_JOBNAME   The job's name.\n</code></pre> <p>IMPORTANT!! All PBS directives MUST come before the first line of executable code in your script, otherwise they will be ignored.</p> <p>When a batch job is started, a number of environment variables are created that can be used in the batch job script. A few of the most commonly used variables are described here.</p> Variable Description PBS_ENVIRONMENT set to PBS_BATCH to indicate that the job is a batch job; otherwise, set to PBS_INTERACTIVE to indicate that the job is a PBS interactive job. PBS_JOBID the job identifier assigned to the job by the batch system. This is the same number you see when you do qstat. PBS_JOBNAME the job name supplied by the user PBS_NODEFILE the name of the file that contains the list of the nodes assigned to the job . Useful for Parallel jobs if you want to refer the node, count the node etc. PBS_QUEUE the name of the queue from which the job is executed PBS_O_HOME value of the HOME variable in the environment in which qsub was executed PBS_O_LANG value of the LANG variable in the environment in which qsub was executed PBS_O_LOGNAME value of the LOGNAME variable in the environment in which qsub was executed PBS_O_PATH value of the PATH variable in the environment in which qsub was executed PBS_O_MAIL value of the MAIL variable in the environment in which qsub was executed PBS_O_SHELL value of the SHELL variable in the environment in which qsub was executed PBS_O_TZ value of the TZ variable in the environment in which qsub was executed PBS_O_HOST the name of the host upon which the qsub command is running PBS_O_QUEUE the name of the original queue to which the job was submitted PBS_O_WORKDIR the absolute path of the current working directory of the qsub command. This is the most useful. Use it in every job script. The first thing you do is, cd $PBS_O_WORKDIR after defining the resource list. This is because, pbs throw you to your $HOME directory. PBS_VERSION Version Number of TORQUE, e.g., TORQUE-2.5.1 PBS_MOMPORT active port for mom daemon PBS_TASKNUM number of tasks requested PBS_JOBCOOKIE job cookie PBS_SERVER Server Running TORQUE"}, {"location": "transcribe/", "title": "Transcribe", "text": ""}, {"location": "transcribe/#what-is-transcribe", "title": "What is Transcribe", "text": "<p><code>Transcribe</code> is a non-interactive application that offers audio transcription based on <code>OpenAI</code> <code>Whisper</code> (and derivatives thereoff).</p> <p>The main use case is sporadic transcription of audio or video files. There is intentionally no bulk mode (or API or library) to help with large scale projects.</p> <p>The supported flow is:</p> <ul> <li> <p>Upload audio or video file using the <code>Files</code> interface of the web portal</p> </li> <li> <p>Configure transcription via the <code>Interactive Apps</code> -&gt; <code>Transcribe</code> application (currently under <code>Testing</code> section at the bottom);   you can select <code>Whisper inputfile</code> and <code>Whisper language</code>.</p> </li> <li> <p>Launch it and wait. Connecting to the running transcription is entirely optional; there is nothing interactive to do.   You will also receive an email when the transcritpion started.</p> </li> <li> <p>Upon completion, you will receive an email with link to the result directory. This info will also be shown in the application session under   <code>My interactive sessions</code> (but the session data is only available for a week).</p> </li> </ul> <p>The result directory has a subdirectory per language (transcription and optional translation)   with the text files and some metadata in JSON format of the transcritpion itself and input file.</p> <p>This is intentionally kept simple. There is also no risk of loosing previous results (although some previous result directories might get renamed when input file names are reused).</p> <p>If you have issues, please report them via the <code>Problems with this session? Submit support ticket</code> link.</p>"}, {"location": "transcribe/#performance-and-default-settings", "title": "Performance and default settings", "text": "<p>The defaults should give the best balance between quality, performance and time to result. You can expect approximate 10 minutes of transcription time per hour of input and approximate 1 minute per translation language using the default flavour. This performance combined with an almost immediate start time is the best combination for the intended use case. There should be enough resources available to get this result most of the time.</p>"}, {"location": "transcribe/#advanced-options", "title": "Advanced options", "text": "<p>There are some advanced options one can choose from. They should not be needed for normal usage.</p> <p>They are intended for corner cases, or to compare results between different <code>Whisper</code> models and/or different implementation flavours (<code>whisper</code> and <code>whisper-ctranslate2</code>) with respect to speed and quality.</p>"}, {"location": "transcribe/#whisper-language", "title": "Whisper language", "text": "<p>The selected language will also determine the output language. However, this is not meant as a translation feature; although the quality is not that bad if your languages have enough similarity.</p>"}, {"location": "transcribe/#translation-target-languages", "title": "Translation target languages", "text": "<p>Select one or more languages to translate to. Hold the <code>Ctrl</code> button pressed while clicking to select (or unselect) languages.</p> <p>Warning</p> <p>Right-to-left languages might generate incorrect subtitles. If you have any examples, you can use the <code>Problems with this session? Submit support ticket</code> to report this so we can investigate properly.</p> <p>The translation is run after the transcription, and is separate from the Whisper based process. If you select a language to translate to that is also the <code>Whisper language</code>, there will be no translation generated for it.</p> <p>The default languages are <code>Dutch</code> and <code>English</code>.  If e.g. you have a Dutch spoken video (and select Dutch as the <code>Whisper language</code>), the end result will be a Dutch transcription and an English translation of the Dutch transcription. (And thus no <code>Dutch-to-Dutch</code> translation.)</p> <p>There is thus no need to unselect the languages each time based on changing input languages.</p>"}, {"location": "transcribe/#model", "title": "Model", "text": "<p>Default model is <code>large-v3</code>, others can be choosen but should be careful to compare resulting speed and/or quality differences.</p>"}, {"location": "transcribe/#flavour", "title": "Flavour", "text": "<p>We currently support 2 flavours: <code>whisper</code> (the OpenAI reference implementation), and <code>whisper-ctranslate2</code> (a faster version with some extras). Benchmarks indicate that <code>whisper-ctranslate2</code> is about 4 times faster than <code>whisper</code>, but might have some lower quality.</p>"}, {"location": "transcribe/#task", "title": "Task", "text": "<p>From the selected (or auto-detected) source speech language, you can choose to transcribe to the same language or to <code>English</code>. You can use this last option to translate to English (as opposed to force the detection of the source language as if it was spoken in English).</p>"}, {"location": "transcribe/#cluster", "title": "Cluster", "text": "<p>Changing the cluster from the interactive cluster will give you access to much better GPU, but at a penalty of having to wait in the queue of the other cluster typically for a much longer time than it will take to complete the transcription on the default cluster.</p>"}, {"location": "transcribe/#resources", "title": "Resources", "text": "<p>Default settings of 4 cores with at least 10GB of RAM and 1 hour (wall)time should be enough for most transcriptions.</p>"}, {"location": "troubleshooting/", "title": "Troubleshooting", "text": ""}, {"location": "troubleshooting/#job_does_not_run_faster", "title": "Why does my job not run faster when using more nodes and/or cores?", "text": "<p>Requesting more resources for your job, more specifically using multiple cores and/or nodes,  does not automatically imply that your job will run faster.  There are various factors that determine to what extent these extra resources can be used and how efficiently they can be used.  More information on this in the subsections below.</p>"}, {"location": "troubleshooting/#using-multiple-cores", "title": "Using multiple cores", "text": "<p>When you want to speed up your jobs by requesting multiple cores, you also need to use software that is actually capable of  using them (and use them efficiently, ideally). Unless a particular parallel programming paradigm like OpenMP threading  (shared memory) or MPI (distributed memory) is used,  software will run sequentially (on a single core).</p> <p>To use multiple cores, the software needs to be able to create, manage, and synchronize multiple threads or processes.  More on how to implement parallelization for you exact programming language can be found online. Note that when using software that only uses threads to use multiple cores, there is no point in asking for multiple nodes,  since with a multi-threading (shared memory) approach you can only use the resources (cores, memory) of a single node.</p> <p>Even if your software is able to use multiple cores, maybe there is no point in going beyond a single core or a handful of cores,  for example because the workload you are running is too small or does not parallelize well. You can test this by increasing the amount of cores step-wise, and look at the speedup you gain. For example,  test with 2, 4, 16, a quarter of, half of, and all available cores.</p> <p>Other reasons why using more cores may not lead to a (significant) speedup include:</p> <ul> <li> <p>Overhead: When you use multi-threading (OpenMP) or multi-processing (MPI),  you should not expect that doubling the amount of cores will result in a 2x speedup.  This is due to the fact that time is needed to create, manage and synchronize the threads/processes. When this \"bookkeeping\" overhead exceeds the time gained by parallelization, you will not observe any speedup (or even see slower runs). For example, this can happen when you split your program in too many (tiny) tasks to run in parallel -  creating a thread/process for each task may even take longer than actually running the task itself.</p> </li> <li> <p>Amdahl's Law is often used in parallel computing to predict the maximum achievable (theoretical) speedup when using multiple cores.  It states that \"the overall performance improvement gained by optimizing a single part of a system is limited by the fraction of time that the improved part is actually used\".  For example, if a program needs 20 hours to complete using a single core, but a one-hour portion of the program can not be parallelized,  only the remaining 19 hours of execution time can be sped up using parallelization.  Regardless of how many cores are devoted to a parallelized execution of this program, the minimum execution time is always more than 1 hour.  So when you reach this theoretical limit, using more cores will not help at all to speed up the computational workload.</p> </li> <li> <p>Resource contention: When two or more threads/processes want to access the same resource, they need to wait on each other - this is called resource contention.  As a result, 1 thread/process will need to wait until the other one is finished using that resource.  When each thread uses the same resource, it will definitely run slower than if it doesn't need to wait for other threads to finish.</p> </li> <li> <p>Software limitations: It is possible that the software you are using is just not really optimized for parallelization.  An example of a software that is not really optimized for multi-threading is Python (although this has improved over the years). This is due to the fact that in Python threads are implemented in a way that multiple threads can not run at the same time, due to the global interpreter lock (GIL).  Instead of using multi-threading in Python to speedup a CPU bound program, you should use multi-processing instead,  which uses multiple processes (multiple instances of the same program) instead of multiple threads in a single program instance. Using multiple processes can speed up your CPU bound programs a lot more in Python than threads can do, even though they are much less efficient to create. In other programming languages (which don't have a GIL), you would probably still want to use threads.</p> </li> <li> <p>Affinity and core pinning:  Even when the software you are using is able to efficiently use multiple cores, you may not see any speedup (or even a significant slowdown). This could be due to threads or processes that are not pinned to specific cores and keep hopping around between cores,  or because the pinning is done incorrectly and several threads/processes are being pinned to the same core(s), and thus keep \"fighting\" each other.</p> </li> <li> <p>Lack of sufficient memory: When there is not enough memory available, or not enough memory bandwidth,  it is likely that you will not see a significant speedup when using more cores (since each thread or process most likely requires additional memory).</p> </li> </ul> <p>More info on running multi-core workloads on the UAntwerpen-HPC can be found here.</p>"}, {"location": "troubleshooting/#using-multiple-nodes", "title": "Using multiple nodes", "text": "<p>When trying to use multiple (worker)nodes to improve the performance of your workloads, you may not see (significant) speedup.</p> <p>Parallelizing code across nodes is fundamentally different from leveraging multiple cores via multi-threading within a single node. The scalability achieved through multi-threading does not extend seamlessly to distributing computations across multiple nodes. This means that just changing <code>#PBS -l nodes=1:ppn=10</code> to <code>#PBS -l nodes=2:ppn=10</code> may only increase the waiting time to get your job running (because twice as many resources are requested), and will not improve the execution time.</p> <p>Actually using additional nodes is not as straightforward as merely asking for multiple nodes when submitting your job. The resources on these additional nodes often need to discovered, managed, and synchronized. This introduces complexities in distributing work effectively across the nodes. Luckily, there exist some libraries that do this for you.</p> <p>Using the resources of multiple nodes is often done using a Message Passing Interface (MPI) library. MPI allows nodes to communicate and coordinate, but it also introduces additional complexity.</p> <p>An example of how you can make beneficial use of multiple nodes can be found here.</p> <p>You can also use MPI in Python, some useful packages that are also available on the HPC are:</p> <ul> <li>mpi4py</li> <li>Boost.MPI</li> </ul> <p>We advise to maximize core utilization before considering using multiple nodes. Our infrastructure has clusters with a lot of cores per node so we suggest that you first try to use all the cores on 1 node before you expand to more nodes. In addition, when running MPI software we strongly advise to use our mympirun tool.</p>"}, {"location": "troubleshooting/#how-do-i-know-if-my-software-can-run-in-parallel", "title": "How do I know if my software can run in parallel?", "text": "<p>If you are not sure if the software you are using can efficiently use multiple cores or run across multiple nodes,  you should check its documentation for instructions on how to run in parallel,  or check for options that control how many threads/cores/nodes can be used.</p> <p>If you can not find any information along those lines, the software you are using can probably only use a single core  and thus requesting multiple cores and/or nodes will only result in wasted resources.</p>"}, {"location": "troubleshooting/#walltime-issues", "title": "Walltime issues", "text": "<p>If you get from your job output an error message similar to this:</p> <pre><code>=&gt;&gt; PBS: job killed: walltime &lt;value in seconds&gt; exceeded limit  &lt;value in seconds&gt;\n</code></pre> <p>This occurs when your job did not complete within the requested walltime. See section\u00a0on Specifying Walltime for more information about how to request the walltime.</p>"}, {"location": "troubleshooting/#out-of-quota-issues", "title": "Out of quota issues", "text": "<p>Sometimes a job hangs at some point or it stops writing in the disk. These errors are usually related to the quota usage. You may have reached your quota limit at some storage endpoint. You should move (or remove) the data to a different storage endpoint (or request more quota) to be able to write to the disk and then resubmit the jobs. </p>"}, {"location": "troubleshooting/#sec:connecting-issues", "title": "Issues connecting to login node", "text": "<p>If you are confused about the SSH public/private key pair concept, maybe the key/lock analogy in How do SSH keys work? can help.</p> <p>If you have errors that look like:</p> <pre><code>vsc20167@login.hpc.uantwerpen.be: Permission denied\n</code></pre> <p>or you are experiencing problems with connecting, here is a list of things to do that should help:</p> <ol> <li> <p>Keep in mind that it can take up to an hour for your VSC account to     become active after it has been approved; until then, logging in     to your VSC account will not work.</p> </li> <li> <p>Make sure you are connecting from an IP address that is allowed to     access the VSC login nodes, see     section Connection restrictions     for more information.</p> </li> <li> <p>Your SSH private key may not be in the default location     (<code>$HOME/.ssh/id_rsa</code>). There are several ways to deal with this     (using one of these is sufficient):</p> <ol> <li>Use the <code>ssh -i</code> (see section Connect) OR;</li> <li>Use <code>ssh-add</code> (see section Using an SSH agent) OR;</li> <li>Specify the location of the key in <code>$HOME/.ssh/config</code>. You will             need to replace the VSC login id in the <code>User</code> field with your own:             <pre><code>Host Leibniz\n    Hostname login.hpc.uantwerpen.be\n    IdentityFile /path/to/private/key\n    User vsc20167\n</code></pre>     Now you can connect with <code>ssh Leibniz</code>.</li> </ol> </li> <li> <p>Please double/triple check your VSC login ID. It should look     something like vsc20167: the letters <code>vsc</code>, followed by exactly 5 digits.     Make sure it's the same one as the one on     https://account.vscentrum.be/.</p> </li> <li> <p>You previously connected to the UAntwerpen-HPC from another machine, but now have     another machine? Please follow the procedure for adding additional     keys in section Adding multiple SSH public keys. You may need to wait for     15-20 minutes until the SSH public key(s) you added become active.</p> </li> <li> <p>When using an SSH key in a non-default location, make sure you supply the path of the private key (and not the path of the public key) to <code>ssh</code>. <code>id_rsa.pub</code> is the usual filename of the public key, <code>id_rsa</code> is the usual filename of the private key. (See also section\u00a0Connect)</p> </li> <li> <p>If you have multiple private keys on your machine, please make sure     you are using the one that corresponds to (one of) the public key(s)     you added on https://account.vscentrum.be/.</p> </li> <li> <p>Please do not use someone else's private keys. You must never share     your private key, they're called private for a good reason.</p> </li> </ol> <p>If you've tried all applicable items above and it doesn't solve your problem, please contact hpc@uantwerpen.be and include the following information:</p> <p>Please add <code>-vvv</code> as a flag to <code>ssh</code> like:</p> <pre><code>ssh -vvv vsc20167@login.hpc.uantwerpen.be\n</code></pre> <p>and include the output of that command in the message.</p>"}, {"location": "troubleshooting/#security-warning-about-invalid-host-key", "title": "Security warning about invalid host key", "text": "<p>If you get a warning that looks like the one below, it is possible that someone is trying to intercept the connection between you and the system you are connecting to. Another possibility is that the host key of the system you are connecting to has changed.</p> <pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n@     WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!    @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! \nSomeone could be\neavesdropping on you right now (man-in-the-middle attack)! \nIt is also possible that a host key has just been changed. \nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:1MNKFTfl1T9sm6tTWAo4sn7zyEfiWFLKbk/mlT+7S5s. \nPlease contact your system administrator. \nAdd correct host key in \u00a0~/.ssh/known_hosts to get rid of this message. \nOffending ECDSA key in \u00a0~/.ssh/known_hosts:21\nECDSA host key for login.hpc.uantwerpen.be has changed and you have requested strict checking.\nHost key verification failed.\n</code></pre> <p>You will need to remove the line it's complaining about (in the example, line 21). To do that, open <code>~/.ssh/known_hosts</code> in an editor, and remove the line. This results in <code>ssh</code> \"forgetting\" the system you are connecting to.</p> <p>Alternatively you can use the command that might be shown by the warning under <code>remove with:</code> and it should be something like this:</p> <pre><code>ssh-keygen -f \"~/.ssh/known_hosts\" -R \"login.hpc.uantwerpen.be\"\n</code></pre> <p>If the command is not shown, take the file from the \"Offending ECDSA key in\", and the host name from \"ECDSA host key for\" lines.</p> <p>After you've done that, you'll need to connect to the UAntwerpen-HPC again. See Warning message when first connecting to new host to verify the fingerprints.</p>"}, {"location": "troubleshooting/#doswindows-text-format", "title": "DOS/Windows text format", "text": "<p>If you get errors like:</p> <pre><code>$ qsub fibo.pbs\nqsub: script is written in DOS/Windows text format\n</code></pre> <p>or</p> <pre><code>sbatch: error: Batch script contains DOS line breaks (\\r\\n)\n</code></pre> <p>It's probably because you transferred the files from a Windows computer. See the section about <code>dos2unix</code> in Linux tutorial to fix this error.</p>"}, {"location": "troubleshooting/#warning-message-when-first-connecting-to-new-host", "title": "Warning message when first connecting to new host", "text": "<pre><code>$ ssh vsc20167@login.hpc.uantwerpen.be\nThe authenticity of host login.hpc.uantwerpen.be (&lt;IP-adress&gt;) can't be established. \n&lt;algorithm&gt; key fingerprint is &lt;hash&gt;\nAre you sure you want to continue connecting (yes/no)?\n</code></pre> <p>Now you can check the authenticity by checking if the line that is at the place of the underlined piece of text matches one of the following lines:</p> <pre><code>{{ opensshFirstConnect }}\n</code></pre> <p>If it does, type yes. If it doesn't, please contact support: hpc@uantwerpen.be.</p>"}, {"location": "troubleshooting/#memory-limits", "title": "Memory limits", "text": "<p>To avoid jobs allocating too much memory, there are memory limits in place by default. It is possible to specify higher memory limits if your jobs require this.</p> <p>Note</p> <p>Memory is not the same as storage. Memory or RAM is used for temporary,  fast access to data when the program is running, while storage is used for long-term data retention. If you are running into problems because you reached your storage quota, see Out of quota issues.</p>"}, {"location": "troubleshooting/#how-will-i-know-if-memory-limits-are-the-cause-of-my-problem", "title": "How will I know if memory limits are the cause of my problem?", "text": "<p>If your program fails with a memory-related issue, there is a good chance it failed because of the memory limits and you should increase the memory limits for your job.</p> <p>Examples of these error messages are: <code>malloc failed</code>, <code>Out of memory</code>, <code>Could not allocate memory</code> or in Java: <code>Could not reserve enough space for object heap</code>. Your program can also run into a <code>Segmentation fault</code> (or <code>segfault</code>) or crash due to bus errors.</p> <p>You can check the amount of virtual memory (in Kb) that is available to you via the <code>ulimit -v</code> command in your job script.</p>"}, {"location": "troubleshooting/#how-do-i-specify-the-amount-of-memory-i-need", "title": "How do I specify the amount of memory I need?", "text": "<p>See Generic resource requirements to set memory and other requirements, see Specifying memory requirements to finetune the amount of memory you request.</p>"}, {"location": "useful_linux_commands/", "title": "Useful Linux Commands", "text": ""}, {"location": "useful_linux_commands/#basic-linux-usage", "title": "Basic Linux Usage", "text": "<p>All the UAntwerpen-HPC clusters run some variant of the \"RedHat Enterprise Linux\" operating system. This means that, when you connect to one of them, you get a command line interface, which looks something like this:</p> <pre><code>vsc20167@ln01[203] $\n</code></pre> <p>When you see this, we also say you are inside a \"shell\". The shell will accept your commands, and execute them.</p> Command Description <code>ls</code> Shows you a list of files in the current directory <code>cd</code> Change current working directory <code>rm</code> Remove file or directory <code>echo</code> Prints its parameters to the screen <code>joe</code> Text editor <p>Most commands will accept or even need parameters, which are placed after the command, separated by spaces. A simple example with the \"echo\" command:</p> <pre><code>$ echo This is a test\nThis is a test\n</code></pre> <p>Important here is the \"$\" sign in front of the first line. This should not be typed, but is a convention meaning \"the rest of this line should be typed at your shell prompt\". The lines not starting with the \"$\" sign are usually the feedback or output from the command.</p> <p>More commands will be used in the rest of this text, and will be explained then if necessary. If not, you can usually get more information about a command, say the item or command \"ls\", by trying either of the following:</p> <pre><code>$ ls --help \n$ man ls\n$ info ls\n</code></pre> <p>(You can exit the last two \"manuals\" by using the \"q\" key.) For more exhaustive tutorials about Linux usage, please refer to the following site: https://www.geeksforgeeks.org/linux-tutorial/</p>"}, {"location": "useful_linux_commands/#how-to-get-started-with-shell-scripts", "title": "How to get started with shell scripts", "text": "<p>In a shell script, you will put the commands you would normally type at your shell prompt in the same order. This will enable you to execute all those commands at any time by only issuing one command: starting the script.</p> <p>Scripts are basically non-compiled pieces of code: they are just text files. Since they don't contain machine code, they are executed by what is called a \"parser\" or an \"interpreter\". This is another program that understands the command in the script, and converts them to machine code. There are many kinds of scripting languages, including Perl and Python.</p> <p>Another very common scripting language is shell scripting. In a shell script, you will put the commands you would normally type at your shell prompt in the same order. This will enable you to execute all those commands at any time by only issuing one command: starting the script.</p> <p>Typically in the following examples they'll have on each line the next command to be executed although it is possible to put multiple commands on one line. A very simple example of a script may be:</p> <pre><code>echo \"Hello! This is my hostname:\" \nhostname\n</code></pre> <p>You can type both lines at your shell prompt, and the result will be the following:</p> <pre><code>$ echo \"Hello! This is my hostname:\"\nHello! This is my hostname:\n$ hostname\nln2.leibniz.uantwerpen.vsc\n</code></pre> <p>Suppose we want to call this script \"foo\". You open a new file for editing, and name it \"foo\", and edit it with your favourite editor</p> <pre><code>$ vi foo\n</code></pre> <p>or use the following commands:</p> <pre><code>echo \"echo 'Hello! This is my hostname:'\" &gt; foo\necho hostname &gt;&gt; foo\n</code></pre> <p>The easiest ways to run a script is by starting the interpreter and pass the script as parameter. In case of our script, the interpreter may either be \"sh\" or \"bash\" (which are the same on the cluster). So start the script:</p> <pre><code>$ bash foo\nHello! This is my hostname:\nln2.leibniz.uantwerpen.vsc\n</code></pre> <p>Congratulations, you just created and started your first shell script!</p> <p>A more advanced way of executing your shell scripts is by making them executable by their own, so without invoking the interpreter manually. The system can not automatically detect which interpreter you want, so you need to tell this in some way. The easiest way is by using the so called \"shebang\" notation, explicitly created for this function: you put the following line on top of your shell script \"#!/path/to/your/interpreter\".</p> <p>You can find this path with the \"which\" command. In our case, since we use bash as an interpreter, we get the following path:</p> <pre><code>$ which bash\n/bin/bash\n</code></pre> <p>We edit our script and change it with this information:</p> <pre><code>#!/bin/bash\necho \"Hello! This is my hostname:\"\nhostname\n</code></pre> <p>Note that the \"shebang\" must be the first line of your script! Now the operating system knows which program should be started to run the script.</p> <p>Finally, we tell the operating system that this script is now executable. For this we change its file attributes:</p> <pre><code>chmod +x foo\n</code></pre> <p>Now you can start your script by simply executing it:</p> <pre><code>$ ./foo\nHello! This is my hostname:\nln2.leibniz.uantwerpen.vsc\n</code></pre> <p>The same technique can be used for all other scripting languages, like Perl and Python.</p> <p>Most scripting languages understand that lines beginning with \"#\" are comments, and should be ignored. If the language you want to use does not ignore these lines, you may get strange results ...</p>"}, {"location": "useful_linux_commands/#linux-quick-reference-guide", "title": "Linux Quick reference Guide", "text": ""}, {"location": "useful_linux_commands/#archive-commands", "title": "Archive Commands", "text": "Command Description <code>tar</code> An archiving program designed to store and extract files from an archive known as a tar file. <code>tar -cvf foo.tar foo/</code> Compress the contents of <code>foo</code> folder to <code>foo.tar</code> <code>tar -xvf foo.tar</code> Extract <code>foo.tar</code> <code>tar -xvzf foo.tar.gz</code> Extract gzipped <code>foo.tar.gz</code>"}, {"location": "useful_linux_commands/#basic-commands", "title": "Basic Commands", "text": "Command Description <code>ls</code> Shows you a list of files in the current directory <code>cd</code> Change the current directory <code>rm</code> Remove file or directory <code>mv</code> Move file or directory <code>echo</code> Display a line or text <code>pwd</code> Print working directory <code>mkdir</code> Create directories <code>rmdir</code> Remove directories"}, {"location": "useful_linux_commands/#editor", "title": "Editor", "text": "Command Description <code>emacs</code> <code>nano</code> Nano's ANOther editor, an enhanced free Pico clone <code>vi</code> A programmer's text editor"}, {"location": "useful_linux_commands/#file-commands", "title": "File Commands", "text": "Command Description <code>cat</code> Read one or more files and print them to standard output <code>cmp</code> Compare two files byte by byte <code>cp</code> Copy files from a source to the same or different target(s) <code>du</code> Estimate disk usage of each file and recursively for directories <code>find</code> Search for files in directory hierarchy <code>grep</code> Print lines matching a pattern <code>ls</code> List directory contents <code>mv</code> Move file to different targets <code>rm</code> Remove files <code>sort</code> Sort lines of text files <code>wc</code> Print the number of new lines, words, and bytes in files"}, {"location": "useful_linux_commands/#help-commands", "title": "Help Commands", "text": "Command Description <code>man</code> Displays the manual page of a command with its name, synopsis, description, author, copyright, etc."}, {"location": "useful_linux_commands/#network-commands", "title": "Network Commands", "text": "Command Description <code>hostname</code> Show or set the system's host name <code>ifconfig</code> Display the current configuration of the network interface. It is also useful to get the information about IP address, subnet mask, set remote IP address, netmask, etc. <code>ping</code> Send ICMP ECHO_REQUEST to network hosts. You will get back an ICMP packet if the host responds. This command is useful to check whether your computer is connected or not."}, {"location": "useful_linux_commands/#other-commands", "title": "Other Commands", "text": "Command Description <code>logname</code> Print user's login name <code>quota</code> Display disk usage and limits <code>which</code> Returns the pathnames of the files that would be executed in the current environment <code>whoami</code> Displays the login name of the current effective user"}, {"location": "useful_linux_commands/#process-commands", "title": "Process Commands", "text": "Command Description <code>&amp;</code> In order to execute a command in the background, place an ampersand (<code>&amp;</code>) at the end of the command line. A user job number (in brackets) and a system process number are displayed. The system process number identifies the job, while the user job number is used by the user. <code>at</code> Executes commands at a specified time <code>bg</code> Places a suspended job in the background <code>crontab</code> A file which contains the schedule of entries to run at specified times <code>fg</code> A process running in the background will be processed in the foreground <code>jobs</code> Lists the jobs being run in the background <code>kill</code> Cancels a job running in the background; it takes either the user job number or the system process number as an argument <code>ps</code> Reports a snapshot of the current processes <code>top</code> Displays Linux tasks"}, {"location": "useful_linux_commands/#user-account-commands", "title": "User Account Commands", "text": "Command Description <code>chmod</code> Modify properties for users"}, {"location": "vscodetunnel/", "title": "VS Code Tunnel", "text": "<p>Please keep in mind, that this is not a <code>VS Code</code> manual, it is only our recommendation how to connect to the UAntwerpen-HPC using the <code>VS Code</code> tunnel. </p> <p>For <code>VS Code</code> documentation, see https://code.visualstudio.com/docs</p> <p>We only support <code>VS Code</code> tunnel access via the <code>VS Code</code> application (installed locally). To connect to the <code>VS Code</code> tunnel using the URL via a web browser is not supported, since web access might not work from all browser or operational system. The only confirmed way to connect via a browser is using Windows 11 and Edge. </p>"}, {"location": "vscodetunnel/#prerequisites", "title": "Prerequisites", "text": "<p>We do recommend to install the remote development extension pack for the <code>VS Code</code> App.</p>"}, {"location": "vscodetunnel/#connection", "title": "Connection", "text": "<p>In the web portal, under the \"Interactive Apps\" choose <code>VS Code</code> Tunnel, select the parameters and launch your job by clicking Launch When your job has started, connect by clicking Connect</p> <p>In the new browser tab or window, for the question <code>How would you like to log in to Visual Studio Code?</code> choose <code>Microsoft Account</code>  (using the arrow keys on your keyboard, then hit Enter). Then follow the instruction to authenticate yourself.</p> <p>Warning</p> <p>If you are an UGent user, and you get an error message something like \"You do not have access to this\" during the Microsoft Authentication, then you might have to whitelist yourself You can use as motivation \"Needed for <code>VS Code</code> tunnel for HPC\" (You have to do it only once.)</p> <p>Please be aware, that it might take up to half an hour until the whitelisting become effective.</p> <p>If you are not connected automatically to the tunnel, please select \"connect to...\" and then \"Connect to Tunnel\" using Microsoft Account and select the tunnel named <code>vsc-&lt;your vsc account&gt;-&lt;cluster&gt;</code>. Please note that right now you can only have one tunnel per cluster.</p> <p>If you are asked to update <code>VS Code</code> CLI on your remote server, choose Not Now. You do not have permission to update the CLI, as it is centrally installed. This means that your <code>VS Code</code> App is newer than the CLI on our systems. We update the centrally installed CLI time to time, but the upgrade rate of the App/CLI is very high, so it is hard for us to follow it tightly. If you suspect that the too old version of CLI might cause problem, please send us a software installation request for <code>code-cli</code>. </p> <p>Please do not use <code>VS Code</code> to ssh to the login nodes, but always use a <code>VS Code</code> Tunnel connection, preferably using the interactive and debug cluster </p>"}, {"location": "web_portal/", "title": "Using the HPC-UGent web portal", "text": "<p>The HPC-UGent web portal provides \"one stop shop\" for the HPC-UGent infrastructure. It is based on Open OnDemand (or <code>OoD</code> for short).</p> <p>Via this web portal you can upload and download files, create, edit, submit, and monitor jobs, run GUI applications, and connect via SSH, all via a standard web browser like Firefox, Chrome or Safari. You do not need to install or configure any client software, and no SSH key is required to connect to your VSC account via this web portal.\\ Please note that we do recommend to use our interactive and debug cluster (see chapter interactive and debug cluster) with <code>OoD</code>.</p> <p>To connect to the HPC-UGent infrastructure via the web portal, visit https://login.hpc.ugent.be</p> <p>Note that you may only see a \"Submitting...\" message appear for a couple of seconds, which is perfectly normal.</p> <p>Through this web portal, you can:</p> <ul> <li> <p>browse through the files &amp; directories in your VSC account, and     inspect, manage or change them;</p> </li> <li> <p>consult active jobs (across all HPC-UGent Tier-2 clusters);</p> </li> <li> <p>submit new jobs to the HPC-UGent Tier-2 clusters, either from     existing job scripts or from job templates;</p> </li> <li> <p>start an interactive graphical user interface (a desktop     environment), either on the login nodes or on a cluster workernode;</p> </li> <li> <p>open a terminal session directly in your web browser;</p> </li> </ul> <p>More detailed information is available below, as well as in the Open OnDemand documentation. A walkthrough video is available on YouTube here.</p>"}, {"location": "web_portal/#pilot-access", "title": "Pilot access", "text": ""}, {"location": "web_portal/#known-issues-limitations", "title": "Known issues &amp; limitations", "text": ""}, {"location": "web_portal/#limited-resources", "title": "Limited resources", "text": "<p>All web portal sessions are currently served through a single separate login node, so the available resources are relatively limited. We will monitor the resources used by the active web portal sessions throughout the pilot phase to evaluate whether more resources are required.</p>"}, {"location": "web_portal/#login", "title": "Login", "text": "<p>When visiting the HPC-UGent web portal you will be automatically logged in via the VSC accountpage (see also Section\u00a0Applying for the account).</p>"}, {"location": "web_portal/#first-login", "title": "First login", "text": "<p>The first time you visit https://login.hpc.ugent.be permission will be requested to let the web portal access some of your personal information (VSC login ID, account status, login shell and institute name), as shown in this screenshot below:</p> <p></p> <p>Please click \"Authorize\" here.</p> <p>This request will only be made once, you should not see this again afterwards.</p>"}, {"location": "web_portal/#start-page", "title": "Start page", "text": "<p>Once logged in, you should see this start page:</p> <p></p> <p>This page includes a menu bar at the top, with buttons on the left providing access to the different features supported by the web portal, as well as a Help menu, your VSC account name, and a Log Out button on the top right, and the familiar HPC-UGent welcome message with a high-level overview of the HPC-UGent Tier-2 clusters.</p> <p>If your browser window is too narrow, the menu is available at the top right through the \"hamburger\" icon:</p> <p></p>"}, {"location": "web_portal/#features", "title": "Features", "text": "<p>We briefly cover the different features provided by the web portal, going from left to right in the menu bar at the top.</p>"}, {"location": "web_portal/#file-browser", "title": "File browser", "text": "<p>Via the Files drop-down menu at the top left, you can browse through the files and directories in your VSC account using an intuitive interface that is similar to a local file browser, and manage, inspect or change them.</p> <p>The drop-down menu provides short-cuts to the different <code>$VSC_*</code> directories and filesystems you have access to. Selecting one of the directories will open a new browser tab with the File Explorer:</p> <p></p> <p>Here you can:</p> <ul> <li> <p>Click a directory in the tree view on the left to open it;</p> </li> <li> <p>Use the buttons on the top to:</p> <ul> <li> <p>go to a specific subdirectory by typing in the path (via Go     To...);</p> </li> <li> <p>open the current directory in a terminal (shell) session (via     Open in Terminal);</p> </li> <li> <p>create a new file (via New File) or subdirectory (via New     Dir) in the current directory;</p> </li> <li> <p>upload files or directories from your local workstation into     your VSC account, in the correct directory (via Upload);</p> </li> <li> <p>show hidden files and directories, of which the name starts with     a dot (<code>.</code>) (via Show Dotfiles);</p> </li> <li> <p>show the owner and permissions in the file listing (via Show     Owner/Mode);</p> </li> </ul> </li> <li> <p>Double-click a directory in the file listing to open that directory;</p> </li> <li> <p>Select one or more files and/or directories in the file listing,     and:</p> <ul> <li> <p>use the View button to see the contents (use the button at the     top right to close the resulting popup window);</p> </li> <li> <p>use the Edit button to open a simple file editor in a new     browser tab which you can use to make changes to the selected     file and save them;</p> </li> <li> <p>use the Rename/Move button to rename or move the selected     files and/or directories to a different location in your VSC     account;</p> </li> <li> <p>use the Download button to download the selected files and     directories from your VSC account to your local workstation;</p> </li> <li> <p>use the Copy button to copy the selected files and/or     directories, and then use the Paste button to paste them in a     different location;</p> </li> <li> <p>use the (Un)Select All button to select (or unselect) all     files and directories in the current directory;</p> </li> <li> <p>use the Delete button to (permanently!) remove the selected files and     directories;</p> </li> </ul> </li> </ul> <p>For more information, see also https://www.osc.edu/resources/online_portals/ondemand/file_transfer_and_management.</p>"}, {"location": "web_portal/#job-management", "title": "Job management", "text": "<p>Via the Jobs menu item, you can consult your active jobs or submit new jobs using the Job Composer.</p> <p>For more information, see the sections below as well as https://www.osc.edu/resources/online_portals/ondemand/job_management.</p>"}, {"location": "web_portal/#active-jobs", "title": "Active jobs", "text": "<p>To get an overview of all your currently active jobs, use the Active Jobs menu item under Jobs.</p> <p>A new browser tab will be opened that shows all your current queued and/or running jobs:</p> <p></p> <p>You can control which jobs are shown using the Filter input area, or select a particular cluster from the drop-down menu All Clusters, both at the top right.</p> <p>Jobs that are still queued or running can be deleted using the red button on the right.</p> <p>Completed jobs will also be visible in this interface, but only for a short amount of time after they have stopped running.</p> <p>For each listed job, you can click on the arrow ($&gt;$) symbol to get a detailed overview of that job, and get quick access to the corresponding output directory (via the Open in File Manager and Open in Terminal buttons at the bottom of the detailed overview).</p>"}, {"location": "web_portal/#job-composer", "title": "Job composer", "text": "<p>To submit new jobs, you can use the Job Composer menu item under Jobs. This will open a new browser tab providing an interface to create new jobs:</p> <p></p> <p>This extensive interface allows you to create jobs from one of the available templates, or by copying an existing job.</p> <p>You can carefully prepare your job and the corresponding job script via the Job Options button and by editing the job script (see lower right).</p> <p>Don't forget to actually submit your job to the system via the green Submit button!</p>"}, {"location": "web_portal/#job-templates", "title": "Job templates", "text": "<p>In addition, you can inspect provided job templates, copy them or even create your own templates via the Templates button on the top:</p> <p></p>"}, {"location": "web_portal/#shell-access", "title": "Shell access", "text": "<p>Through the Shell Access button that is available under the Clusters menu item, you can easily open a terminal (shell) session into your VSC account, straight from your browser!</p> <p></p> <p>Using this interface requires being familiar with a Linux shell environment (see Appendix\u00a0Useful Linux Commands).</p> <p>To exit the shell session, type <code>exit</code> followed by Enter and then close the browser tab.</p> <p>Note that you can not access a shell session after you closed a browser tab, even if you didn't exit the shell session first (unless you use terminal multiplexer tool like <code>screen</code> or <code>tmux</code>).</p>"}, {"location": "web_portal/#interactive-applications", "title": "Interactive applications", "text": ""}, {"location": "web_portal/#graphical-desktop-environment", "title": "Graphical desktop environment", "text": "<p>To create a graphical desktop environment, use on of the desktop on... node buttons under Interactive Apps menu item. For example:</p> <p></p> <p>You can either start a desktop environment on a login node for some lightweight tasks, or on a workernode of one of the HPC-UGent Tier-2 clusters if more resources are required. Keep in mind that for desktop sessions on a workernode the regular queueing times are applicable dependent on requested resources.</p> <p>Do keep in mind that desktop environments on a cluster workernode are limited to a maximum of 72 hours, just like regular jobs are.</p> <p>To access the desktop environment, click the My Interactive Sessions menu item at the top, and then use the Launch desktop on ... node button if the desktop session is Running:</p> <p></p> <p>It is also possible to relaunch a desktop session that has ended by clicking the icon on the top-right of the desktop session box:</p> <p></p>"}, {"location": "web_portal/#jupyter-notebook", "title": "Jupyter notebook", "text": "<p>See dedicated page on Jupyter notebooks</p>"}, {"location": "web_portal/#transcribe", "title": "Transcribe", "text": "<p>See dedicated page on audio transcription app Transcribe</p>"}, {"location": "web_portal/#restarting-your-web-server-in-case-of-problems", "title": "Restarting your web server in case of problems", "text": "<p>In case of problems with the web portal, it could help to restart the web server running in your VSC account.</p> <p>You can do this via the Restart Web Server button under the Help menu item:</p> <p></p> <p>Of course, this only affects your own web portal session (not those of others).</p>"}, {"location": "web_portal/#enable-debug-logging-for-interactive-apps", "title": "Enable debug logging for interactive apps", "text": "<p>When investigating an issue with an interactive app (e.g. failure to start), it can be very helpful (or you will be asked to by support) to provide more debugging information in the output log file. To do so, tick <code>Show advanced options</code> button (right above the <code>Launch</code> button), and tick <code>Enable extra debugging code to help debug problems</code> button that right above it.</p> <p>Once the issue is resolved, you can do the same steps to untick the <code>Enable extra debugging code to help debug problems</code> button again or it will add the additional commands and output with every interactive app you start, and it is not recommended to do this by default.</p>"}, {"location": "web_portal/#custom-apps", "title": "Custom apps", "text": "<ul> <li>ABAQUS for CAE course</li> </ul>"}, {"location": "x2go/", "title": "Graphical applications with X2Go", "text": "<p>X2Go is being phased out in favor of the web portal which is superior and easier in use.</p>"}, {"location": "xdmod/", "title": "XDMoD portal", "text": "<p>The XDMoD web portal provides information about completed jobs, storage usage and the HPC UGent cloud infrastructure usage.</p> <p>To connect to the XDMoD portal, turn on your VPN connection to UGent and visit https://shieldon.ugent.be/xdmod.</p> <p>Note that you may need to authorise XDMoD to obtain information from your VSC account through the VSC accountpage.</p> <p>After you log in for the first time, you can take the tour, where the web application shows you several features through a series of tips.</p> <p>Located in the upper right corner of the web page is the help button, taking you to the XDMoD User Manual. As things may change, we recommend checking out the provided documenation for information on XDMoD use  https://shieldon.ugent.be/xdmod/user_manual/index.php.</p>"}, {"location": "examples/Getting_Started/tensorflow_mnist/", "title": "Index", "text": "<p>TensorFlow example copied from https://github.com/EESSI/eessi-demo/tree/main/TensorFlow</p> <p>Loads MNIST datasets and trains a neural network to recognize hand-written digits.</p> <p>Runtime: ~1 min. on 8 cores (Intel Skylake)</p> <p>See https://www.tensorflow.org/tutorials/quickstart/beginner</p>"}, {"location": "linux-tutorial/", "title": "Introduction", "text": "<p>Welcome to the Linux tutorial, a comprehensive guide designed to give you essential skills for smooth interaction within a Linux environment.</p> <p>These skills are important to the UAntwerpen-HPC, which operates on RedHat Enterprise Linux. For more information see introduction to HPC.</p> <p>The guide aims to make you familiar with the Linux command line environment quickly.</p> <p>The tutorial goes through the following steps:</p> <ol> <li>Getting Started</li> <li>Navigating</li> <li>Manipulating files and directories</li> <li>Uploading files</li> <li>Beyond the basics</li> </ol> <p>Do not forget Common pitfalls, as this can save you some troubleshooting.</p>"}, {"location": "linux-tutorial/#useful-topics", "title": "Useful topics", "text": "<ul> <li>More on the HPC infrastructure.</li> <li>Cron Scripts: run scripts automatically at periodically fixed times, dates, or intervals.</li> </ul>"}, {"location": "linux-tutorial/beyond_the_basics/", "title": "Beyond the basics", "text": "<p>Now that you've seen some of the more basic commands, let's take a look at some of the deeper concepts and commands.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#inputoutput", "title": "Input/output", "text": "<p>To redirect output to files, you can use the redirection operators: <code>&gt;</code>, <code>&gt;&gt;</code>, <code>&amp;&gt;</code>, and <code>&lt;</code>.</p> <p>First, it's important to make a distinction between two different output channels:</p> <ol> <li> <p><code>stdout</code>: standard output channel, for regular output</p> </li> <li> <p><code>stderr</code>: standard error channel, for errors and warnings</p> </li> </ol>"}, {"location": "linux-tutorial/beyond_the_basics/#redirecting-stdout", "title": "Redirecting <code>stdout</code>", "text": "<p><code>&gt;</code> writes the (<code>stdout</code>) output of a command to a file and overwrites whatever was in the file before. <pre><code>$ echo hello &gt; somefile\n$ cat somefile\nhello\n$ echo hello2 &gt; somefile\n$ cat somefile\nhello2\n</code></pre></p> <p><code>&gt;&gt;</code> appends the (<code>stdout</code>) output of a command to a file; it does not clobber whatever was in the file before: <pre><code>$ echo hello &gt; somefile\n$ cat somefile \nhello\n$ echo hello2 &gt;&gt; somefile\n$ cat somefile\nhello\nhello2\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#reading-from-stdin", "title": "Reading from <code>stdin</code>", "text": "<p><code>&lt;</code> reads a file from standard input (piped or typed input). So you would use this to simulate typing into a terminal. <code>&lt; somefile.txt</code> is largely equivalent to <code>cat somefile.txt |</code>.</p> <p>One common use might be to take the results of a long-running command and store the results in a file, so you don't have to repeat it while you refine your command line. For example, if you have a large directory structure you might save a list of all the files you're interested in and then reading in the file list when you are done: <pre><code>$ find . -name .txt &gt; files\n$ xargs grep banana &lt; files\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#redirecting-stderr", "title": "Redirecting <code>stderr</code>", "text": "<p>To redirect the <code>stderr</code> output (warnings, messages), you can use <code>2&gt;</code>, just like <code>&gt;</code> <pre><code>$ ls one.txt nosuchfile.txt 2&gt; errors.txt\none.txt\n$ cat errors.txt\nls: nosuchfile.txt: No such file or directory\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#combining-stdout-and-stderr", "title": "Combining <code>stdout</code> and <code>stderr</code>", "text": "<p>To combine both output channels (<code>stdout</code> and <code>stderr</code>) and redirect them to a single file, you can use <code>&amp;&gt;</code> <pre><code>$ ls one.txt nosuchfile.txt &amp;&gt; ls.out\n$ cat ls.out\nls: nosuchfile.txt: No such file or directory\none.txt\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#command-piping", "title": "Command piping", "text": "<p>Part of the power of the command line is to string multiple commands together to create useful results. The core of these is the pipe: <code>|</code>. For example, to see the number of files in a directory, we can pipe the (<code>stdout</code>) output of <code>ls</code> to <code>wc</code> (word count, but can also be used to count the number of lines with the <code>-l</code> flag). <pre><code>$ ls | wc -l\n    42\n</code></pre></p> <p>A common pattern is to pipe the output of a command to <code>less</code> so you can examine or search the output: <pre><code>$ find . | less\n</code></pre></p> <p>Or to look through your command history: <pre><code>$ history | less\n</code></pre></p> <p>You can put multiple pipes in the same line. For example, which <code>cp</code> commands have we run? <pre><code>$ history | grep cp | less\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#shell-expansion", "title": "Shell expansion", "text": "<p>The shell will expand certain things, including:</p> <ol> <li> <p><code>*</code> wildcard: for example <code>ls t*txt</code> will list all files starting     with 't' and ending in 'txt'</p> </li> <li> <p>tab completion: hit the <code>&lt;tab&gt;</code> key to make the shell complete your     command line; works for completing file names, command names, etc.</p> </li> <li> <p><code>$...</code> or <code>${...}</code>: environment variables will be replaced with     their value; example: <code>echo \"I am $USER\"</code> or <code>echo \"I am ${USER}\"</code></p> </li> <li> <p>square brackets can be used to list a number of options for a     particular characters;  example: <code>ls *.[oe][0-9]</code>.  This will list all     files starting with whatever characters (<code>*</code>), then a dot (<code>.</code>),     then either an 'o' or an 'e' (<code>[oe]</code>), then a character from '0' to     '9' (so any digit) (<code>[0-9]</code>). So this filename will match:     <code>anything.o5</code>, but this one won't: <code>anything.o52</code>.</p> </li> </ol>"}, {"location": "linux-tutorial/beyond_the_basics/#process-information", "title": "Process information", "text": ""}, {"location": "linux-tutorial/beyond_the_basics/#ps-and-pstree", "title": "<code>ps</code> and <code>pstree</code>", "text": "<p><code>ps</code> lists processes running. By default, it will only show you the processes running in the local shell. To see all of your processes running on the system, use: <pre><code>$ ps -fu $USER\n</code></pre></p> <p>To see all the processes: <pre><code>$ ps -elf\n</code></pre></p> <p>To see all the processes in a forest view, use: <pre><code>$ ps auxf\n</code></pre></p> <p>The last two will spit out a lot of data, so get in the habit of piping it to <code>less</code>.</p> <p><code>pstree</code> is another way to dump a tree/forest view. It looks better than <code>ps auxf</code> but it has much less information so its value is limited.</p> <p><code>pgrep</code> will find all the processes where the name matches the pattern and print the process IDs (PID). This is used in piping the processes together as we will see in the next section.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#kill", "title": "<code>kill</code>", "text": "<p><code>ps</code> isn't very useful unless you can manipulate the processes. We do this using the <code>kill</code> command. Kill will send a message (SIGINT) to the process to ask it to stop. <pre><code>$ kill 1234\n$ kill $(pgrep misbehaving_process)\n</code></pre></p> <p>Usually, this ends the process, giving it the opportunity to flush data to files, etc. However, if the process ignored your signal, you can send it a different message (SIGKILL) which the OS will use to unceremoniously terminate the process: <pre><code>$ kill -9 1234\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#top", "title": "<code>top</code>", "text": "<p><code>top</code> is a tool to see the current status of the system. You've probably used something similar in Task Manager on Windows or Activity Monitor in macOS. <code>top</code> will update every second and has a few interesting commands.</p> <p>To see only your processes, type <code>u</code> and your username after starting <code>top</code>, (you can also do this with  <code>top -u $USER</code> ). The default is to sort the display by <code>%CPU</code>. To change the sort order, use <code>&lt;</code> and <code>&gt;</code> like arrow keys.</p> <p>There are a lot of configuration options in <code>top</code>, but if you're interested in seeing a nicer view, you can run <code>htop</code> instead. Be aware that it's not installed everywhere, while <code>top</code> is.</p> <p>To exit <code>top</code>, use <code>q</code> (for 'quit').</p> <p>For more information, see Brendan Gregg's excellent site dedicated to performance analysis.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#ulimit", "title": "ulimit", "text": "<p><code>ulimit</code> is a utility to get or set user limits on the machine. For example, you may be limited to a certain number of processes. To see all the limits that have been set, use: <pre><code>$ ulimit -a\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#counting-wc", "title": "Counting: <code>wc</code>", "text": "<p>To count the number of lines, words, and characters (or bytes) in a file, use <code>wc</code> (word count): <pre><code>$ wc example.txt\n      90     468     3189   example.txt\n</code></pre></p> <p>The output indicates that the file named <code>example.txt</code> contains 90 lines, 468 words, and 3189 characters/bytes.</p> <p>To only count the number of lines, use <code>wc -l</code>: <pre><code>$ wc -l example.txt\n      90    example.txt\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#searching-file-contents-grep", "title": "Searching file contents: <code>grep</code>", "text": "<p><code>grep</code> is an important command. It was originally an abbreviation for \"globally search a regular expression and print\" but it's entered the common computing lexicon and people use 'grep' to mean searching for anything. To use grep, you give a pattern and a list of files. <pre><code>$ grep banana fruit.txt\n$ grep banana fruit_bowl1.txt fruit_bowl2.txt\n$ grep banana fruit*txt\n</code></pre></p> <p><code>grep</code> also lets you search for Regular Expressions, but these are not in scope for this introductory text.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#cut", "title": "<code>cut</code>", "text": "<p><code>cut</code> is used to pull fields out of files or pipes streams. It's a useful glue when you mix it with <code>grep</code> because <code>grep</code> can find the lines where a string occurs and <code>cut</code> can pull out a particular field. For example, to pull the first column (<code>-f 1</code>, the first field) from (an unquoted) CSV (comma-separated values, so <code>-d ','</code>: delimited by <code>,</code>) file, you can use the following: <pre><code>$ cut -f 1 -d ',' mydata.csv\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#sed", "title": "<code>sed</code>", "text": "<p><code>sed</code> is the stream editor. It is used to replace text in a file or piped stream. In this way, it works like grep, but instead of just searching, it can also edit files. This is like \"Search and Replace\" in a text editor. <code>sed</code> has a lot of features, but almost everyone uses the extremely basic version of string replacement: <pre><code>$ sed 's/oldtext/newtext/g' myfile.txt\n</code></pre></p> <p>By default, sed will just print the results. If you want to edit the file inplace, use <code>-i</code>, but be very careful that the results will be what you want before you go around destroying your data!</p>"}, {"location": "linux-tutorial/beyond_the_basics/#awk", "title": "<code>awk</code>", "text": "<p><code>awk</code> is a basic language that builds on <code>sed</code> to do much more advanced stream editing. Going in depth is far out of scope of this tutorial, but there are two examples that are worth knowing.</p> <p>First, <code>cut</code> is very limited in pulling fields apart based on whitespace. For example, if you have padded fields then <code>cut -f 4 -d ' '</code> will almost certainly give you a headache as there might be an uncertain number of spaces between each field. <code>awk</code> does better whitespace splitting. So, pulling out the fourth field in a whitespace delimited file is as follows: <pre><code>$ awk '{print $4}' mydata.dat\n</code></pre></p> <p>You can use <code>-F ':'</code> to change the delimiter (F for field separator).</p> <p>The next example is used to sum numbers from a field: <pre><code>$ awk -F ',' '{sum += $1} END {print sum}' mydata.csv\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#basic-shell-scripting", "title": "Basic Shell Scripting", "text": "<p>The basic premise of a script is to execute automate the execution of multiple commands. If you find yourself repeating the same commands over and over again, you should consider writing one script to do the same. A script is nothing special, it is just a text file like any other. Any commands you put in there will be executed from the top to bottom.</p> <p>However, there are some rules you need to abide by.</p> <p>Here is a very detailed guide should you need more information.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#shebang", "title": "Shebang", "text": "<p>The first line of the script is the so-called shebang (<code>#</code> is sometimes called hash and <code>!</code> is sometimes called bang). This line tells the shell which command should execute the script. In most cases, this will simply be the shell itself. The line itself looks a bit weird, but you can copy-paste this line as you need not worry about it further. It is however very important this is the very first line of the script! These are all valid shebangs, but you should only use one of them:</p> <p><pre><code>#!/bin/sh\n</code></pre> <pre><code>#!/bin/bash\n</code></pre> <pre><code>#!/usr/bin/env bash\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#conditionals", "title": "Conditionals", "text": "<p>Sometimes you only want certain commands to be executed when a certain condition is met. For example, only move files to a directory if that directory exists. The syntax: <pre><code>if [ -d directory ] &amp;&amp; [ -f file ]\nthen mv file directory fi\n\nOr you only want to do something if a file exists:\n\nif [ -f filename ] then echo \"it exists\" fi\n</code></pre> Or only if a certain variable is bigger than one: <pre><code>if [ $AMOUNT -gt 1 ]\nthen\necho \"More than one\"\n# more commands\nfi\n</code></pre> Several pitfalls exist with this syntax. You need spaces surrounding the brackets, the then needs to be at the beginning of a line. It is best to just copy this example and modify it.</p> <p>In the initial example, we used <code>-d</code> to test if a directory existed. There are several more checks.</p> <p>Another useful example, is to test if a variable contains a value (so it's not empty): <pre><code>if [ -z $PBS_ARRAYID ]\nthen\necho \"Not an array job, quitting.\"\nexit 1\nfi\n</code></pre></p> <p>the <code>-z</code> will check if the length of the variable's value is greater than zero.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#loops", "title": "Loops", "text": "<p>Are you copy-pasting commands? Are you doing the same thing with just different options? You most likely can simplify your script by using a loop.</p> <p>Let's look at a simple example: <pre><code>for i in 1 2 3\ndo\necho $i\ndone\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#subcommands", "title": "Subcommands", "text": "<p>Subcommands are used all the time in shell scripts. What they do is storing the output of a command in a variable. So this can later be used in a conditional or a loop for example. <pre><code>CURRENTDIR=`pwd`  # using backticks\nCURRENTDIR=$(pwd)  # recommended (easier to type)\n</code></pre></p> <p>In the above example you can see the 2 different methods of using a subcommand. <code>pwd</code> will output the current working directory, and its output will be stored in the CURRENTDIR variable. The recommended way to use subcommands is with the <code>$()</code> syntax.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#errors", "title": "Errors", "text": "<p>Sometimes some things go wrong and a command or script you ran causes an error. How do you properly deal with these situations?</p> <p>Firstly a useful thing to know for debugging and testing is that you can run any command like this: <pre><code>command 2&gt;&amp;1 output.log   # one single output file, both output and errors\n</code></pre></p> <p>If you add <code>2&gt;&amp;1 output.log</code> at the end of any command, it will combine <code>stdout</code> and <code>stderr</code>, outputting it into a single file named <code>output.log</code>.</p> <p>If you want regular and error output separated you can use: <pre><code>command &gt; output.log 2&gt; output.err  # errors in a separate file\n</code></pre></p> <p>this will write regular output to <code>output.log</code> and error output to <code>output.err</code>.</p> <p>You can then look for the errors with <code>less</code> or search for specific text with <code>grep</code>.</p> <p>In scripts, you can use: <pre><code>set -e\n</code></pre></p> <p>This will tell the shell to stop executing any subsequent commands when a single command in the script fails. This is most convenient as most likely this causes the rest of the script to fail as well.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#advanced-error-checking", "title": "Advanced error checking", "text": "<p>Sometimes you want to control all the error checking yourself, this is also possible. Everytime you run a command, a special variable <code>$?</code> is used to denote successful completion of the command. A value other than zero signifies something went wrong. So an example use case: <pre><code>command_with_possible_error\nexit_code=$?  # capture exit code of last command\nif [ $exit_code -ne 0 ]\nthen\necho \"something went wrong\"\nfi\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#bashrc-login-script", "title": "<code>.bashrc</code> login script", "text": "<p>If you have certain commands executed every time you log in (which includes every time a job starts), you can add them to your <code>$HOME/.bashrc</code> file. This file is a shell script that gets executed every time you log in.</p> <p>Examples include:</p> <ul> <li> <p>modifying your <code>$PS1</code> (to tweak your shell prompt)</p> </li> <li> <p>printing information about the current/jobs environment (echoing     environment variables, etc.)</p> </li> <li> <p>selecting a specific cluster to run on with     <code>module swap cluster/...</code></p> </li> </ul> <p>Some recommendations:</p> <ul> <li> <p>Avoid using <code>module load</code> statements in your <code>$HOME/.bashrc</code> file</p> </li> <li> <p>Don't directly edit your <code>.bashrc</code> file: if there's an error in your     <code>.bashrc</code> file, you might not be able to log in again. To     prevent that, use another file to test your changes, then copy them     over when you tested the script.</p> </li> </ul>"}, {"location": "linux-tutorial/beyond_the_basics/#scripting-for-the-cluster", "title": "Scripting for the cluster", "text": "<p>When writing scripts to be submitted on the cluster there are some tricks you need to keep in mind.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#example-job-script", "title": "Example job script", "text": "<pre><code>#!/bin/bash\n#PBS -l nodes=1:ppn=1\n#PBS -N FreeSurfer_per_subject-time-longitudinal\n#PBS -l walltime=48:00:00\n#PBS -q long\n#PBS -m abe\n#PBS -j oe\nexport DATADIR=$VSC_DATA/example\n# $PBS_JOBID is unique for each job, so this creates a unique directory\nexport WORKDIR=$VSC_SCRATCH_NODE/$PBS_JOBID\nmkdir -p $WORKDIR\n# copy files to local storage\ncp -a $DATADIR/workfiles $WORKDIR/\n\n# load software we need\nmodule load FreeSurfer\ncd $WORKDIR\n# recon-all ... &amp;&gt; output.log  # this command takes too long, let's show a more practical example\necho $PBS_ARRAYID &gt; $WORKDIR/$PBS_ARRAYID.txt\n# create results directory if necessary\nmkdir -p $DATADIR/results\n# copy work files back\ncp $WORKDIR/$PBS_ARRAYID.txt $DATADIR/results/\n</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#pbs-pragmas", "title": "PBS pragmas", "text": "<p>The scheduler needs to know about the requirements of the script, for example: how much memory will it use, and how long will it run. These things can be specified inside a script with what we call PBS pragmas.</p> <p>This pragma (a pragma is a special comment) tells PBS to use 1 node and core: <pre><code>#PBS -l nodes=1:ppn=1 # single-core\n</code></pre></p> <p>For parallel software, you can request multiple cores (OpenMP) and/or multiple nodes (MPI). Only use this when the software you use is capable of working in parallel. Here is an example: <pre><code>#PBS -l nodes=1:ppn=16  # single-node, multi-core\n#PBS -l nodes=5:ppn=16  # multi-node\n</code></pre></p> <p>We intend to submit it on the long queue: <pre><code>#PBS -q long\n</code></pre></p> <p>We request a total running time of 48 hours (2 days). <pre><code>#PBS -l walltime=48:00:00\n</code></pre></p> <p>We specify a desired name of our job: <pre><code>#PBS -N FreeSurfer_per_subject-time-longitudinal\n</code></pre> This specifies mail options: <pre><code>#PBS -m abe\n</code></pre></p> <ol> <li> <p><code>a</code> means mail is sent when the job is aborted.</p> </li> <li> <p><code>b</code> means mail is sent when the job begins.</p> </li> <li> <p><code>e</code> means mail is sent when the job ends.</p> </li> </ol> <p>Joins error output with regular output: <pre><code>#PBS -j oe\n</code></pre></p> <p>All of these options can also be specified on the command-line and will overwrite any pragmas present in the script.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#exercises", "title": "Exercises", "text": "<ol> <li> <p>Create a file that contains this message: \"Hello, I am &lt;user&gt;\",     where <code>&lt;user&gt;</code> is replaced by your username. Don't cheat by using an     editor, use a command to create the file.</p> </li> <li> <p>Use another command to add this line to the same file: \"I am on     system &lt;hostname&gt; in directory &lt;current\u00a0directory&gt;\". Words     between <code>&lt;&gt;</code> should be replaced with their value (hint: use     environment variables).</p> </li> <li> <p>How many files and directories are in <code>/tmp</code>?</p> </li> <li> <p>What's the name of the 5th file/directory in alphabetical order in     <code>/tmp</code>?</p> </li> <li> <p>List all files that start with <code>t</code> in <code>/tmp</code>.</p> </li> <li> <p>Create a file containing \"My home directory &lt;home&gt; is available     using $HOME\". <code>&lt;home&gt;</code> should be replaced with your home directory,     but <code>$HOME</code> should remain as-is.</p> </li> <li> <p>How many processes are you currently running? How many are you     allowed to run? Where are they coming from?</p> </li> </ol>"}, {"location": "linux-tutorial/common_pitfalls/", "title": "Common Pitfalls", "text": "<p>This page highlights common pitfalls in Linux usage, offering insights into potential challenges users might face.  By understanding these pitfalls, you can avoid unnecessary hurdles.</p>"}, {"location": "linux-tutorial/common_pitfalls/#location", "title": "Location", "text": "<p>If you receive an error message which contains something like the following: <pre><code>No such file or directory\n</code></pre></p> <p>It probably means that you haven't placed your files in the correct directory, or you have mistyped the file name or path.</p> <p>Try and figure out the correct location using <code>ls</code>, <code>cd</code> and using the different <code>$VSC_*</code> variables.</p>"}, {"location": "linux-tutorial/common_pitfalls/#spaces", "title": "Spaces", "text": "<p>Filenames should not contain any spaces! If you have a long filename you should use underscores or dashes (e.g., <code>very_long_filename</code>). <pre><code>$ cat some file\nNo such file or directory 'some'\n</code></pre></p> <p>Spaces are permitted, however they result in surprising behaviour. To cat the file <code>'some file'</code> as above, you can escape the space with a backslash (\"<code>\\</code>\") or you can put the filename in quotes: <pre><code>$ cat some\\ file\n...\n$ cat \"some file\"\n...\n</code></pre></p> <p>This is especially error-prone if you are piping results of <code>find</code>: <pre><code>$ find . -type f | xargs cat\nNo such file or directory name \u2019some\u2019\nNo such file or directory name \u2019file\u2019\n</code></pre></p> <p>This can be worked around using the <code>-print0</code> flag: <pre><code>$ find . -type f -print0 | xargs -0 cat\n...\n</code></pre></p> <p>But, this is tedious, and you can prevent errors by simply colouring within the lines and not using spaces in filenames.</p>"}, {"location": "linux-tutorial/common_pitfalls/#missingmistyped-environment-variables", "title": "Missing/mistyped environment variables", "text": "<p>If you use a command like <code>rm -r</code> with environment variables you need to be careful to make sure that the environment variable exists. If you mistype an environment variable then it will resolve into a blank string. This means the following resolves to <code>rm -r ~/*</code> which will remove every file in your home directory! <pre><code>$ rm -r ~/$PROJETC/*\n</code></pre></p>"}, {"location": "linux-tutorial/common_pitfalls/#typing-dangerous-commands", "title": "Typing dangerous commands", "text": "<p>A good habit when typing dangerous commands is to precede the line with <code>#</code>, the comment character. This will let you type out the command without fear of accidentally hitting enter and running something unintended. <pre><code>$ #rm -r ~/$POROJETC/*\n</code></pre> Then you can go back to the beginning of the line (<code>Ctrl-A</code>) and remove the first character (<code>Ctrl-D</code>) to run the command. You can also just press enter to put the command in your history so you can come back to it later (e.g., while you go check the spelling of your environment variables).</p>"}, {"location": "linux-tutorial/common_pitfalls/#permissions", "title": "Permissions", "text": "<pre><code>$ ls -l script.sh # File with correct permissions\n-rwxr-xr-x 1 vsc40000 vsc40000 2983 Jan 30 09:13 script.sh\n$ ls -l script.sh # File with incorrect permissions\n-rw-r--r-- 1 vsc40000 vsc40000 2983 Jan 30 09:13 script.sh\n</code></pre> <p>Before submitting the script, you'll need to add execute permissions to make sure it can be executed: <pre><code>$ chmod +x script_name.sh\n</code></pre></p>"}, {"location": "linux-tutorial/common_pitfalls/#help", "title": "Help", "text": "<p>If you stumble upon an error, don't panic! Read the error output, it might contain a clue as to what went wrong. You can copy the error message into Google (selecting a small part of the error without filenames). It can help if you surround your search terms in double quotes (for example <code>\"No such file or directory\"</code>), that way Google will consider the error as one thing, and won't show results just containing these words in random order.</p> <p>If you need help about a certain command, you should consult its so-called \"man page\": <pre><code>$ man command\n</code></pre></p> <p>This will open the manual of this command. This manual contains detailed explanation of all the options the command has. Exiting the manual is done by pressing 'q'.</p> <p>Don't be afraid to contact hpc@uantwerpen.be. They are here to help and will do so for even the  smallest of problems!</p>"}, {"location": "linux-tutorial/common_pitfalls/#more-information", "title": "More information", "text": "<ol> <li> <p>Unix Power Tools - A fantastic  book about most of these tools (see also The Second Edition)</p> </li> <li> <p>http://linuxcommand.org/: A great place to start with many     examples. There is an associated book which gets a lot of good     reviews</p> </li> <li> <p>The Linux Documentation Project: More guides on various topics relating to the Linux command line</p> </li> <li> <p>basic shell     usage</p> </li> <li> <p>Bash for     beginners</p> </li> <li> <p>MOOC</p> </li> </ol> <p>Please don't hesitate to contact in case of questions or problems.</p>"}, {"location": "linux-tutorial/getting_started/", "title": "Getting Started", "text": ""}, {"location": "linux-tutorial/getting_started/#logging-in", "title": "Logging in", "text": "<p>To get started with the HPC-UGent infrastructure, you need to obtain a VSC account, see HPC manual. Keep in mind that you must keep your private key to yourself!</p> <p>You can look at your public/private key pair as a lock and a key: you give us the lock (your public key), we put it on the door, and then you can use your key to open the door and get access to the HPC infrastructure. Anyone who has your key can use your VSC account!</p> <p>Details on connecting to the HPC infrastructure are available in HPC manual connecting section.</p>"}, {"location": "linux-tutorial/getting_started/#getting-help", "title": "Getting help", "text": "<p>To get help:</p> <ol> <li>use the documentation available on the system, through the     <code>help</code>, <code>info</code> and <code>man</code> commands (use <code>q</code> to exit).     <pre><code>help cd \ninfo ls \nman cp \n</code></pre></li> <li> <p>use Google</p> </li> <li> <p>contact hpc@uantwerpen.be in case of problems or questions (even for basic things!)</p> </li> </ol>"}, {"location": "linux-tutorial/getting_started/#errors", "title": "Errors", "text": "<p>Sometimes when executing a command, an error occurs. Most likely there will be error output or a message explaining you this. Read this carefully and try to act on it. Try googling the error first to find any possible solution, but if you can't come up with something in 15 minutes, don't hesitate to mail  hpc@uantwerpen.be</p>"}, {"location": "linux-tutorial/getting_started/#basic-terminal-usage", "title": "Basic terminal usage", "text": "<p>The basic interface is the so-called shell prompt, typically ending with <code>$</code> (for <code>bash</code> shells).</p> <p>You use the shell by executing commands, and hitting <code>&lt;enter&gt;</code>. For example: </p> <pre><code>$ echo hello \nhello \n</code></pre> <p>You can go to the start or end of the command line using <code>Ctrl-A</code> or <code>Ctrl-E</code>.</p> <p>To go through previous commands, use <code>&lt;up&gt;</code> and <code>&lt;down&gt;</code>, rather than retyping them.</p>"}, {"location": "linux-tutorial/getting_started/#command-history", "title": "Command history", "text": "<p>A powerful feature is that you can \"search\" through your command history, either using the <code>history</code> command, or using <code>Ctrl-R</code>:  <pre><code>$ history\n    1 echo hello\n\n# hit Ctrl-R, type 'echo' \n(reverse-i-search)`echo': echo hello\n</code></pre></p>"}, {"location": "linux-tutorial/getting_started/#stopping-commands", "title": "Stopping commands", "text": "<p>If for any reason you want to stop a command from executing, press <code>Ctrl-C</code>. For example, if a command is taking too long, or you want to rerun it with different arguments.</p>"}, {"location": "linux-tutorial/getting_started/#variables", "title": "Variables", "text": "<p>At the prompt we also have access to shell variables, which have both a name and a value.</p> <p>They can be thought of as placeholders for things we need to remember.</p> <p>For example, to print the path to your home directory, we can use the shell variable named <code>HOME</code>:</p> <pre><code>$ echo $HOME \n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>This prints the value of this variable.</p>"}, {"location": "linux-tutorial/getting_started/#defining-variables", "title": "Defining variables", "text": "<p>There are several variables already defined for you when you start your session, such as <code>$HOME</code> which contains the path to your home directory.</p> <p>For a full overview of defined environment variables in your current session, you can use the <code>env</code> command. You can sort this output with <code>sort</code> to make it easier to search in:</p> <pre><code>$ env | sort \n...\nHOME=/user/home/gent/vsc400/vsc40000 \n... \n</code></pre> <p>You can also use the <code>grep</code> command to search for a piece of text. The following command will output all VSC-specific variable names and their values:</p> <pre><code>$ env | sort | grep VSC\n</code></pre> <p>But we can also define our own. this is done with the <code>export</code> command (note: variables are always all-caps as a convention):</p> <pre><code>$ export MYVARIABLE=\"value\"\n</code></pre> <p>It is important you don't include spaces around the <code>=</code> sign. Also note the lack of <code>$</code> sign in front of the variable name.</p> <p>If we then do  <pre><code>$ echo $MYVARIABLE\n</code></pre></p> <p>this will output <code>value</code>. Note that the quotes are not included, they were only used when defining the variable to escape potential spaces in the value.</p>"}, {"location": "linux-tutorial/getting_started/#changing-your-prompt-using-ps1", "title": "Changing your prompt using <code>$PS1</code>", "text": "<p>You can change what your prompt looks like by redefining the special-purpose variable <code>$PS1</code>.</p> <p>For example: to include the current location in your prompt: <pre><code>$ export PS1='\\w $'\n~ $ cd test \n~/test $ \n</code></pre></p> <p>Note that <code>~</code> is short representation of your home directory.</p> <p>To make this persistent across session, you can define this custom value for <code>$PS1</code> in your <code>.profile</code> startup script: <pre><code>$ echo 'export PS1=\"\\w $ \" ' &gt;&gt; ~/.profile\n</code></pre></p>"}, {"location": "linux-tutorial/getting_started/#using-non-defined-variables", "title": "Using non-defined variables", "text": "<p>One common pitfall is the (accidental) use of non-defined variables. Contrary to what you may expect, this does not result in error messages, but the variable is considered to be empty instead.</p> <p>This may lead to surprising results, for example:  <pre><code>$ export WORKDIR=/tmp/test \n$ pwd\n/user/home/gent/vsc400/vsc40000 \n$ echo $HOME\n/user/home/gent/vsc400/vsc40000 \n</code></pre></p> <p>To understand what's going on here, see the section on <code>cd</code> below.</p> <p>The moral here is: be very careful to not use empty variables unintentionally.</p> <p>Tip for job scripts: use <code>set -e -u</code> to avoid using empty variables accidentally.</p> <p>The <code>-e</code> option will result in the script getting stopped if any command fails.</p> <p>The <code>-u</code> option will result in the script getting stopped if empty variables are used. (see https://ss64.com/bash/set.html for a more detailed explanation and more options)</p> <p>More information can be found at https://www.tldp.org/LDP/abs/html/variables.html.</p>"}, {"location": "linux-tutorial/getting_started/#restoring-your-default-environment", "title": "Restoring your default environment", "text": "<p>If you've made a mess of your environment, you shouldn't waste too much time trying to fix it. Just log out and log in again and you will be given a pristine environment.</p>"}, {"location": "linux-tutorial/getting_started/#basic-system-information", "title": "Basic system information", "text": "<p>Basic information about the system you are logged into can be obtained in a variety of ways.</p> <p>We limit ourselves to determining the hostname:  <pre><code>$ hostname \ngligar01.gligar.os\n\n$ echo $HOSTNAME \ngligar01.gligar.os \n</code></pre></p> <p>And querying some basic information about the Linux kernel: <pre><code>$ uname -a \nLinux gligar01.gligar.os 2.6.32-573.8.1.el6.ug.x86_64 #1 SMP Mon Nov 16 15:12:09\n    CET 2015 x86_64 x86_64 x86_64 GNU/Linux \n</code></pre></p>"}, {"location": "linux-tutorial/getting_started/#exercises", "title": "Exercises", "text": "<ul> <li>Print the full path to your home directory</li> <li>Determine the name of the environment variable to your personal scratch directory</li> <li>What's the name of the system you\\'re logged into? Is it the same for everyone?</li> <li>Figure out how to print the value of a variable without including a newline</li> <li>How do you get help on using the <code>man</code> command?</li> </ul> <p>Next chapter teaches you on how to navigate.</p>"}, {"location": "linux-tutorial/hpc_infrastructure/", "title": "More on the HPC infrastructure", "text": ""}, {"location": "linux-tutorial/hpc_infrastructure/#filesystems", "title": "Filesystems", "text": "<p>Multiple different shared filesystems are available on the HPC infrastructure, each with their own purpose. See section Where to store your data on the UAntwerpen-HPC for a list of available locations.</p>"}, {"location": "linux-tutorial/hpc_infrastructure/#quota", "title": "Quota", "text": "<p>Space is limited on the cluster's storage. To check your quota, see section Pre-defined quota.</p> <p>To figure out where your quota is being spent, the <code>du</code> (isk sage) command can come in useful: <pre><code>$ du -sh test\n59M test\n</code></pre></p> <p>Do not (frequently) run <code>du</code> on directories where large amounts of data are stored, since that will:</p> <ol> <li> <p>take a long time</p> </li> <li> <p>result in increased load on the shared storage since (the metadata     of) every file in those directories will have to be inspected.</p> </li> </ol>"}, {"location": "linux-tutorial/hpc_infrastructure/#modules", "title": "Modules", "text": "<p>Software is provided through so-called environment modules.</p> <p>The most commonly used commands are:</p> <ol> <li> <p><code>module avail</code>: show all available modules</p> </li> <li> <p><code>module avail &lt;software name&gt;</code>: show available modules for a     specific software name</p> </li> <li> <p><code>module list</code>: show list of loaded modules</p> </li> <li> <p><code>module load &lt;module name&gt;</code>: load a particular module</p> </li> </ol> <p>More information is available in section Modules.</p>"}, {"location": "linux-tutorial/hpc_infrastructure/#using-the-clusters", "title": "Using the clusters", "text": "<p>The use the clusters beyond the login node(s) which have limited resources, you should create job scripts and submit them to the clusters.</p> <p>Detailed information is available in section submitting your job.</p>"}, {"location": "linux-tutorial/hpc_infrastructure/#exercises", "title": "Exercises", "text": "<p>Create and submit a job script that computes the sum of 1-100 using Python, and prints the numbers to a unique output file in <code>$VSC_SCRATCH</code>.</p> <p>Hint: <code>python -c \"print(sum(range(1, 101)))\"</code></p> <ul> <li>How many modules are available for Python version 3.6.4?</li> <li>How many modules get loaded when you load the <code>Python/3.12.3-GCCcore-13.3.0</code> module?</li> <li> <p>Which <code>cluster</code> modules are available?</p> </li> <li> <p>What's the full path to your personal home/data/scratch directories?</p> </li> <li>Determine how large your personal directories are.</li> <li>What's the difference between the size reported by <code>du -sh $HOME</code> and by <code>ls -ld $HOME</code>?</li> </ul>"}, {"location": "linux-tutorial/manipulating_files_and_directories/", "title": "Manipulating files and directories", "text": "<p>Being able to manage your data is an important part of using the HPC infrastructure. The bread and butter commands for doing this are mentioned here. It might seem annoyingly terse at first, but with practice you will realise that it's very practical to have such common commands short to type.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#file-contents-cat-head-tail-less-more", "title": "File contents: \"cat\", \"head\", \"tail\", \"less\", \"more\"", "text": "<p>To print the contents of an entire file, you can use <code>cat</code>; to only see the first or last N lines, you can use <code>head</code> or <code>tail</code>: <pre><code>$ cat one.txt\n1\n2\n3\n4\n5\n\n$ head -2 one.txt\n1\n2\n\n$ tail -2 one.txt\n4\n5\n</code></pre></p> <p>To check the contents of long text files, you can use the <code>less</code> or <code>more</code> commands which support scrolling with \"&lt;up&gt;\", \"&lt;down&gt;\", \"&lt;space&gt;\", etc.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#copying-files-cp", "title": "Copying files: \"cp\"", "text": "<pre><code>$ cp source target\n</code></pre> <p>This is the <code>cp</code> command, which copies a file from source to target. To copy a directory, we use the <code>-r</code> option: <pre><code>$ cp -r sourceDirectory target\n</code></pre></p> <p>A last more complicated example: <pre><code>$ cp -a sourceDirectory target\n</code></pre></p> <p>Here we used the same <code>cp</code> command, but instead we gave it the <code>-a</code> option which tells cp to copy all the files and keep timestamps and permissions.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#creating-directories-mkdir", "title": "Creating directories: \"mkdir\"", "text": "<pre><code>$ mkdir directory\n</code></pre> <p>which will create a directory with the given name inside the current directory.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#renamingmoving-files-mv", "title": "Renaming/moving files: \"mv\"", "text": "<pre><code>$ mv source target\n</code></pre> <p><code>mv</code> will move the source path to the destination path. Works for both directories as files.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#removing-files-rm", "title": "Removing files: \"rm\"", "text": "<p>Note: there are NO backups, there is no 'trash bin'. If you remove files/directories, they are gone. <pre><code>$ rm filename\n</code></pre> <code>rm</code> will remove a file or directory. (<code>rm -rf directory</code> will remove every file inside a given directory). WARNING: files removed will be lost forever, there are no backups, so beware when using this command!</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#removing-a-directory-rmdir", "title": "Removing a directory: \"rmdir\"", "text": "<p>You can remove directories using <code>rm -r directory</code>, however, this is error-prone and can ruin your day if you make a mistake in typing. To prevent this type of error, you can remove the contents of a directory using <code>rm</code> and then finally removing the directory with: <pre><code>$ rmdir directory\n</code></pre></p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#changing-permissions-chmod", "title": "Changing permissions: \"chmod\"", "text": "<p>Every file, directory, and link has a set of permissions. These permissions consist of permission groups and permission types. The permission groups are:</p> <ol> <li> <p>User - a particular user (account)</p> </li> <li> <p>Group - a particular group of users (may be user-specific group with     only one member)</p> </li> <li> <p>Other - other users in the system</p> </li> </ol> <p>The permission types are:</p> <ol> <li> <p>Read - For files, this gives permission to read the contents of a     file</p> </li> <li> <p>Write - For files, this gives permission to write data to the file.     For directories, it allows users to add or remove files to a     directory.</p> </li> <li> <p>Execute - For files this gives permission to execute a file as     through it were a script. For directories, it allows users to open     the directory and look at the contents.</p> </li> </ol> <p>Any time you run <code>ls -l</code> you'll see a familiar line of <code>-rwx------</code> or similar combination of the letters <code>r</code>, <code>w</code>, <code>x</code> and <code>-</code> (dashes). These are the permissions for the file or directory. (See also the  previous section on permissions) <pre><code>$ ls -l\ntotal 1\n-rw-r--r--. 1 vsc40000 mygroup 4283648 Apr 12 15:13 articleTable.csv\ndrwxr-x---. 2 vsc40000 mygroup 40 Apr 12 15:00 Project_GoldenDragon\n</code></pre></p> <p>Here, we see that <code>articleTable.csv</code> is a file (beginning the line with <code>-</code>) has read and write permission for the user <code>vsc40000</code> (<code>rw-</code>), and read permission for the group <code>mygroup</code> as well as all other users (<code>r--</code> and <code>r--</code>).</p> <p>The next entry is <code>Project_GoldenDragon</code>. We see it is a directory because the line begins with a <code>d</code>. It also has read, write, and execute permission for the <code>vsc40000</code> user (<code>rwx</code>). So that user can look into the directory and add or remove files. Users in the <code>mygroup</code> can also look into the directory and read the files. But they can't add or remove files (<code>r-x</code>). Finally, other users can read files in the directory, but other users have no permissions to look in the directory at all (<code>---</code>).</p> <p>Maybe we have a colleague who wants to be able to add files to the directory. We use <code>chmod</code> to change the modifiers to the directory to let people in the group write to the directory: <pre><code>$ chmod g+w Project_GoldenDragon\n$ ls -l\ntotal 1\n-rw-r--r--. 1 vsc40000 mygroup 4283648 Apr 12 15:13 articleTable.csv\ndrwxrwx---. 2 vsc40000 mygroup 40 Apr 12 15:00 Project_GoldenDragon\n</code></pre></p> <p>The syntax used here is <code>g+x</code> which means group was given write permission. To revoke it again, we use <code>g-w</code>. The other roles are <code>u</code> for user and <code>o</code> for other.</p> <p>You can put multiple changes on the same line: <code>chmod o-rwx,g-rxw,u+rx,u-w somefile</code> will take everyone's permission away except the user's ability to read or execute the file.</p> <p>You can also use the <code>-R</code> flag to affect all the files within a directory, but this is dangerous. It's best to refine your search using <code>find</code> and then pass the resulting list to <code>chmod</code> since it's not usual for all files in a directory structure to have the same permissions.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#access-control-lists-acls", "title": "Access control lists (ACLs)", "text": "<p>However, this means that all users in <code>mygroup</code> can add or remove files. This could be problematic if you only wanted one person to be allowed to help you administer the files in the project. We need a new group. To do this in the HPC environment, we need to use access control lists (ACLs): <pre><code>$ setfacl -m u:otheruser:w Project_GoldenDragon\n$ ls -l Project_GoldenDragon\ndrwxr-x---+ 2 vsc40000 mygroup 40 Apr 12 15:00 Project_GoldenDragon\n</code></pre></p> <p>This will give the user <code>otheruser</code> permissions to write to <code>Project_GoldenDragon</code></p> <p>Now there is a <code>+</code> at the end of the line. This means there is an ACL attached to the directory. <code>getfacl Project_GoldenDragon</code> will print the ACLs for the directory.</p> <p>Note: most people don't use ACLs, but it's sometimes the right thing and you should be aware it exists.</p> <p>See https://linux.die.net/man/1/setfacl for more information.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#zipping-gzipgunzip-zipunzip", "title": "Zipping: \"gzip\"/\"gunzip\", \"zip\"/\"unzip\"", "text": "<p>Files should usually be stored in a compressed file if they're not being used frequently. This means they will use less space and thus you get more out of your quota. Some types of files (e.g., CSV files with a lot of numbers) compress as much as 9:1. The most commonly used compression format on Linux is gzip. To compress a file using gzip, we use: <pre><code>$ ls -lh myfile\n-rw-r--r--. 1 vsc40000 vsc40000 4.1M Dec 2 11:14 myfile\n$ gzip myfile\n$ ls -lh myfile.gz\n-rw-r--r--. 1 vsc40000 vsc40000 1.1M Dec 2 11:14 myfile.gz\n</code></pre></p> <p>Note: if you zip a file, the original file will be removed. If you unzip a file, the compressed file will be removed. To keep both, we send the data to <code>stdout</code> and redirect it to the target file: <pre><code>$ gzip -c myfile &gt; myfile.gz\n$ gunzip -c myfile.gz &gt; myfile\n</code></pre></p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#zip-and-unzip", "title": "\"zip\" and \"unzip\"", "text": "<p>Windows and macOS seem to favour the zip file format, so it's also important to know how to unpack those. We do this using unzip: <pre><code>$ unzip myfile.zip\n</code></pre></p> <p>If we would like to make our own zip archive, we use zip: <pre><code>$ zip myfiles.zip myfile1 myfile2 myfile3\n</code></pre></p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#working-with-tarballs-tar", "title": "Working with tarballs: \"tar\"", "text": "<p>Tar stands for \"tape archive\" and is a way to bundle files together in a bigger file.</p> <p>You will normally want to unpack these files more often than you make them. To unpack a <code>.tar</code> file you use: <pre><code>$ tar -xf tarfile.tar\n</code></pre></p> <p>Often, you will find <code>gzip</code> compressed <code>.tar</code> files on the web. These are called tarballs. You can recognize them by the filename ending in <code>.tar.gz</code>. You can uncompress these using <code>gunzip</code> and then unpacking them using <code>tar</code>. But <code>tar</code> knows how to open them using the <code>-z</code> option: <pre><code>$ tar -zxf tarfile.tar.gz\n$ tar -zxf tarfile.tgz\n</code></pre></p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#order-of-arguments", "title": "Order of arguments", "text": "<p>Note: Archive programs like <code>zip</code>, <code>tar</code>, and <code>jar</code> use arguments in the \"opposite direction\" of copy commands. <pre><code># cp, ln: &amp;lt;source(s)&amp;gt; &amp;lt;target&amp;gt;\n$ cp source1 source2 source3 target\n$ ln -s source target\n\n# zip, tar: &amp;lt;target&amp;gt; &amp;lt;source(s)&amp;gt;\n$ zip zipfile.zip source1 source2 source3\n$ tar -cf tarfile.tar source1 source2 source3\n</code></pre></p> <p>If you use <code>tar</code> with the source files first then the first file will be overwritten. You can control the order of arguments of <code>tar</code> if it helps you remember:</p> <pre><code>$ tar -c source1 source2 source3 -f tarfile.tar\n</code></pre>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#exercises", "title": "Exercises", "text": "<ol> <li> <p>Create a subdirectory in your home directory named <code>test</code> containing     a single, empty file named <code>one.txt</code>.</p> </li> <li> <p>Copy <code>/etc/hostname</code> into the <code>test</code> directory and then check what's     in it. Rename the file to <code>hostname.txt</code>.</p> </li> <li> <p>Make a new directory named <code>another</code> and copy the entire <code>test</code>     directory to it. <code>another/test/one.txt</code> should then be an empty     file.</p> </li> <li> <p>Remove the <code>another/test</code> directory with a single command.</p> </li> <li> <p>Rename <code>test</code> to <code>test2</code>. Move <code>test2/hostname.txt</code> to your home     directory.</p> </li> <li> <p>Change the permission of <code>test2</code> so only you can access it.</p> </li> <li> <p>Create an empty job script named <code>job.sh</code>, and make it executable.</p> </li> <li> <p>gzip <code>hostname.txt</code>, see how much smaller it becomes, then unzip it     again.</p> </li> </ol> <p>The next chapter is on uploading files, especially important when using HPC-infrastructure.</p>"}, {"location": "linux-tutorial/navigating/", "title": "Navigating", "text": "<p>This chapter serves as a guide to navigating within a Linux shell, giving users essential techniques to traverse directories. A very important skill.</p>"}, {"location": "linux-tutorial/navigating/#current-directory-pwd-and-pwd", "title": "Current directory: \"pwd\" and \"$PWD\"", "text": "<p>To print the current directory, use <code>pwd</code> or <code>\\$PWD</code>: <pre><code>$ cd $HOME \n$ pwd\n/user/home/gent/vsc400/vsc40000 \n$ echo \"The current directory is: $PWD\" \nThe current directory is: /user/home/gent/vsc400/vsc40000\n</code></pre></p>"}, {"location": "linux-tutorial/navigating/#listing-files-and-directories-ls", "title": "Listing files and directories: \"ls\"", "text": "<p>A very basic and commonly used command is <code>ls</code>, which can be used to list files and directories.</p> <p>In its basic usage, it just prints the names of files and directories in the current directory. For example:  <pre><code>$ ls\nafile.txt some_directory \n</code></pre></p> <p>When provided an argument, it can be used to list the contents of a directory:  <pre><code>$ ls some_directory \none.txt two.txt\n</code></pre></p> <p>A couple of commonly used options include:</p> <ul> <li> <p>detailed listing using <code>ls -l</code>:</p> <pre><code>$ ls -l\n    total 4224 \n    -rw-rw-r-- 1 vsc40000 vsc40000 2157404 Apr 12 13:17 afile.txt \n    drwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory\n</code></pre> </li> <li> <p>To print the size information in human-readable form, use the <code>-h</code> flag:</p> <pre><code>$ ls -lh\n    total 4.1M \n    -rw-rw-r-- 1 vsc40000 vsc40000 2.1M Apr 12 13:16 afile.txt\n    drwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory\n</code></pre> </li> <li> <p>also listing hidden files using the <code>-a</code> flag:</p> <pre><code>$ ls -lah\n    total 3.9M \n    drwxrwxr-x 3 vsc40000 vsc40000 512 Apr 12 13:11 .\n    drwx------ 188 vsc40000 vsc40000 128K Apr 12 12:41 .. \n    -rw-rw-r-- 1 vsc40000 vsc40000 1.8M Apr 12 13:12 afile.txt \n    -rw-rw-r-- 1 vsc40000 vsc40000 0 Apr 12 13:11 .hidden_file.txt \n    drwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory\n</code></pre> </li> <li> <p>ordering files by the most recent change using <code>-rt</code>:</p> <pre><code>$ ls -lrth\n    total 4.0M \n    drwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory \n    -rw-rw-r-- 1 vsc40000 vsc40000 2.0M Apr 12 13:15 afile.txt\n</code></pre> </li> </ul> <p>If you try to use <code>ls</code> on a file that doesn't exist, you will get a clear error message: </p> <pre><code>$ ls nosuchfile \nls: cannot access nosuchfile: No such file or directory\n</code></pre>"}, {"location": "linux-tutorial/navigating/#changing-directory-cd", "title": "Changing directory: \"cd\"", "text": "<p>To change to a different directory, you can use the <code>cd</code> command:  <pre><code>$ cd some_directory\n</code></pre></p> <p>To change back to the previous directory you were in, there's a shortcut: <code>cd -</code></p> <p>Using <code>cd</code> without an argument results in returning back to your home directory:  <pre><code>$ cd \n$ pwd\n/user/home/gent/vsc400/vsc40000 \n</code></pre></p>"}, {"location": "linux-tutorial/navigating/#inspecting-file-type-file", "title": "Inspecting file type: \"file\"", "text": "<p>The <code>file</code> command can be used to inspect what type of file you're dealing with: </p> <pre><code>$ file afile.txt\nafile.txt: ASCII text\n\n$ file some_directory \nsome_directory: directory\n</code></pre>"}, {"location": "linux-tutorial/navigating/#absolute-vs-relative-file-paths", "title": "Absolute vs relative file paths", "text": "<p>An absolute filepath starts with <code>/</code> (or a variable which value starts with <code>/</code>), which is also called the root of the filesystem.</p> <p>Example: absolute path to your home directory: <code>/user/home/gent/vsc400/vsc40000</code>.</p> <p>A relative path starts from the current directory, and points to another location up or down the filesystem hierarchy.</p> <p>Example: <code>some_directory/one.txt</code> points to the file <code>one.txt</code> that is located in the subdirectory named <code>some_directory</code> of the current directory.</p> <p>There are two special relative paths worth mentioning:</p> <ul> <li><code>.</code> is a shorthand for the current directory</li> <li><code>..</code> is a shorthand for the parent of the current     directory</li> </ul> <p>You can also use <code>..</code> when constructing relative paths, for example: </p> <pre><code>$ cd $HOME/some_directory \n$ ls ../afile.txt \n../afile.txt \n</code></pre>"}, {"location": "linux-tutorial/navigating/#permissions", "title": "Permissions", "text": "<p>Each file and directory has particular permissions set on it, which can be queried using <code>ls -l</code>.</p> <p>For example:  <pre><code>$ ls -l afile.txt \n-rw-rw-r-- 1 vsc40000 agroup 2929176 Apr 12 13:29 afile.txt \n</code></pre></p> <p>The <code>-rwxrw-r--</code> specifies both the type of file (<code>-</code> for files, <code>d</code> for directories (see first character)), and the permissions for user/group/others:</p> <ol> <li>each triple of characters indicates whether the read     (<code>r</code>), write (<code>w</code>), execute     (<code>x</code>) permission bits are set or not</li> <li>the 1st part <code>rwx</code> indicates that the owner     \"vsc40000\" of the file has all the rights</li> <li>the 2nd part <code>rw-</code> indicates the members of the group     \"agroup\" only have read/write permissions (not execute)</li> <li>the 3rd part <code>r--</code> indicates that other users only     have read permissions</li> </ol> <p>The default permission settings for new files/directories are determined by the so-called umask setting, and are by default:</p> <ol> <li>read-write permission on files for user/group (no execute),     read-only for others (no write/execute)</li> <li>read-write-execute permission for directories on user/group,     read/execute-only for others (no write)</li> </ol> <p>See also the chmod command later in this manual.</p>"}, {"location": "linux-tutorial/navigating/#finding-filesdirectories-find", "title": "Finding files/directories: \"find\"", "text": "<p><code>find</code> will crawl a series of directories and lists files matching given criteria.</p> <p>For example, to look for the file named <code>one.txt</code>:  <pre><code>$ cd $HOME \n$ find . -name one.txt\n./some_directory/one.txt \n</code></pre></p> <p>To look for files using incomplete names, you can use a wildcard <code>*</code>; note that you need to escape the <code>*</code> to avoid that Bash expands it into <code>afile.txt</code> by adding double quotes:  <pre><code>$ find . -name \"*.txt\"\n./.hidden_file.txt \n./afile.txt \n./some_directory/one.txt\n./some_directory/two.txt \n</code></pre></p> <p>A more advanced use of the <code>find</code> command is to use the <code>-exec</code> flag to perform actions on the found file(s), rather than just printing their paths (see <code>man find</code>).</p>"}, {"location": "linux-tutorial/navigating/#exercises", "title": "Exercises", "text": "<ul> <li>Go to <code>/tmp</code>, then back to your home directory. How many     different ways to do this can you come up with?</li> <li>When was your home directory created or last changed?</li> <li>Determine the name of the last changed file in <code>/tmp</code>.</li> <li>See how home directories are organised. Can you access the home     directory of other users?</li> </ul> <p>The next chapter will teach you how to interact with files and directories.</p>"}, {"location": "linux-tutorial/uploading_files/", "title": "Uploading/downloading/editing files", "text": ""}, {"location": "linux-tutorial/uploading_files/#uploadingdownloading-files", "title": "Uploading/downloading files", "text": "<p>To transfer files from and to the HPC, see  the section about transferring files of the HPC manual</p>"}, {"location": "linux-tutorial/uploading_files/#dos2unix", "title": "<code>dos2unix</code>", "text": "<p>After uploading files from Windows, you may experience some problems due to the difference in line endings between Windows (carriage return + line feed) and Linux (line feed only), see also https://kuantingchen04.github.io/line-endings/.</p> <p>For example, you may see an error when submitting a job script that was edited on Windows:</p> <pre><code>sbatch: error: Batch script contains DOS line breaks (\\r\\n)\nsbatch: error: instead of expected UNIX line breaks (\\n).\n</code></pre> <p>To fix this problem, you should run the <code>dos2unix</code> command on the file:</p> <pre><code>$ dos2unix filename\n</code></pre>"}, {"location": "linux-tutorial/uploading_files/#symlinks-for-datascratch", "title": "Symlinks for data/scratch", "text": "<p>As we end up in the home directory when connecting, it would be convenient if we could access our data and VO storage. To facilitate this we will create symlinks to them in our home directory.  This will create 4 symbolic links  (they're like \"shortcuts\" on your desktop)  pointing to the respective storages:</p> <pre><code>$ cd $HOME\n$ ln -s $VSC_SCRATCH scratch\n$ ln -s $VSC_DATA data\n$ ls -l scratch data\nlrwxrwxrwx 1 vsc40000 vsc40000 31 Mar 27 2009 data -&gt;\n    /user/data/gent/vsc400/vsc40000\nlrwxrwxrwx 1 vsc40000 vsc40000 34 Jun 5 2012 scratch -&gt;\n    /user/scratch/gent/vsc400/vsc40000\n</code></pre>"}, {"location": "linux-tutorial/uploading_files/#editing-with-nano", "title": "Editing with <code>nano</code>", "text": "<p>Nano is the simplest editor available on Linux. To open Nano, just type <code>nano</code>. To edit a file, you use <code>nano the_file_to_edit.txt</code>. You will be presented with the contents of the file and a menu at the bottom with commands like <code>^O Write Out</code> The <code>^</code> is the Control key. So <code>^O</code> means <code>Ctrl-O</code>. The main commands are:</p> <ol> <li> <p>Open (\"Read\"): <code>^R</code></p> </li> <li> <p>Save (\"Write Out\"): <code>^O</code></p> </li> <li> <p>Exit: <code>^X</code></p> </li> </ol> <p>More advanced editors (beyond the scope of this page) are <code>vim</code> and <code>emacs</code>. A simple tutorial on how to get started with <code>vim</code> can be found at http://www.openvim.com/.</p>"}, {"location": "linux-tutorial/uploading_files/#copying-faster-with-rsync", "title": "Copying faster with <code>rsync</code>", "text": "<p><code>rsync</code> is a fast and versatile copying tool. It can be much faster than <code>scp</code> when copying large datasets. It's famous for its \"delta-transfer algorithm\", which reduces the amount of data sent over the network by only sending the differences between files.</p> <p>You will need to run <code>rsync</code> from a computer where it is installed. Installing <code>rsync</code> is the easiest on Linux: it comes pre-installed with a lot of distributions.</p> <p>For example, to copy a folder with lots of CSV files: <pre><code>$ rsync -rzv testfolder vsc40000@login.hpc.ugent.be:data/\n</code></pre></p> <p>will copy the folder <code>testfolder</code> and its contents to <code>$VSC_DATA</code> on the , assuming the <code>data</code> symlink is present in your home directory, see  symlinks section.</p> <p>The <code>-r</code> flag means \"recursively\", the <code>-z</code> flag means that compression is enabled (this is especially handy when dealing with CSV files because they compress well) and the <code>-v</code> enables more verbosity (more details about what's going on).</p> <p>To copy large files using <code>rsync</code>, you can use the <code>-P</code> flag: it enables both showing of progress and resuming partially downloaded files.</p> <p>To copy files to your local computer, you can also use <code>rsync</code>: <pre><code>$ rsync -rzv vsc40000@login.hpc.ugent.be:data/bioset local_folder\n</code></pre> This will copy the folder <code>bioset</code> and its contents on <code>$VSC_DATA</code> to a local folder named <code>local_folder</code>.</p> <p>See <code>man rsync</code> or https://linux.die.net/man/1/rsync for more information about rsync.</p>"}, {"location": "linux-tutorial/uploading_files/#exercises", "title": "Exercises", "text": "<ol> <li> <p>Download the file <code>/etc/hostname</code> to your local computer.</p> </li> <li> <p>Upload a file to a subdirectory of your personal <code>$VSC_DATA</code> space.</p> </li> <li> <p>Create a file named <code>hello.txt</code> and edit it using <code>nano</code>.</p> </li> </ol> <p>Now you have a basic understanding, see next chapter for some more in depth concepts.</p>"}, {"location": "sites/available_modules/", "title": "Available modules", "text": "<pre><code>$ module av 2&gt;&amp;1 | more\n------------- /apps/antwerpen/modules/hopper/2015a/all ------------\nABINIT/7.10.2-intel-2015a\nADF/2014.05\nAdvisor/2015_update1\nBison/3.0.4-intel-2015a\nBoost/1.57.0-foss-2015a-Python-2.7.9\nBoost/1.57.0-intel-2015a-Python-2.7.9\nbzip2/1.0.6-foss-2015a\nbzip2/1.0.6-intel-2015a\n...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., LAMMPS) is installed on the UAntwerpen-HPC.</p> <pre><code>$ module av 2&gt;&amp;1 | grep -i -e \"LAMMPS\"\nLAMMPS/9Dec14-intel-2015a\nLAMMPS/30Oct14-intel-2014a\nLAMMPS/5Sep14-intel-2014a\n</code></pre> <p>As you are not aware of the capitals letters in the module name, we looked for a case-insensitive name with the \"-i\" option.</p>"}, {"location": "sites/hpc_policies/", "title": "HPC Policies", "text": ""}, {"location": "sites/antwerpen/available-modules/", "title": "Available modules", "text": "<pre><code>$ module av 2&gt;&amp;1 | more\n------------- /apps/antwerpen/modules/hopper/2015a/all ------------\nABINIT/7.10.2-intel-2015a\nADF/2014.05\nAdvisor/2015_update1\nBison/3.0.4-intel-2015a\nBoost/1.57.0-foss-2015a-Python-2.7.9\nBoost/1.57.0-intel-2015a-Python-2.7.9\nbzip2/1.0.6-foss-2015a\nbzip2/1.0.6-intel-2015a\n...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., LAMMPS) is installed on the UAntwerpen-HPC.</p> <pre><code>$ module av 2&gt;&amp;1 | grep -i -e \"LAMMPS\"\nLAMMPS/9Dec14-intel-2015a\nLAMMPS/30Oct14-intel-2014a\nLAMMPS/5Sep14-intel-2014a\n</code></pre> <p>As you are not aware of the capitals letters in the module name, we looked for a case-insensitive name with the \"-i\" option.</p>"}, {"location": "sites/gent/available-modules/", "title": "Available modules", "text": "<pre><code>module avail\n--- /apps/gent/RHEL8/zen2-ib/modules/all ---\n   ABAQUS/2021-hotfix-2132\n   ABAQUS/2022-hotfix-2214\n   ABAQUS/2022\n   ABAQUS/2023\n   ABAQUS/2024-hotfix-2405                                                (D)\n   ...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., MATLAB) is installed on the UAntwerpen-HPC.</p> <pre><code>module avail matlab\n--- /apps/gent/RHEL8/zen2-ib/modules/all ---\n   LIBSVM-MATLAB/3.30-GCCcore-11.3.0-MATLAB-2022b-r5\n   MATLAB/2019b\n   MATLAB/2021b\n   MATLAB/2022b-r5                                   (D)\n   SPM/12.5_r7771-MATLAB-2021b\n</code></pre>"}, {"location": "web_portal_custom_apps/abaqus_cae/", "title": "Custom web portal app for ABAQUS (CAE course)", "text": "<p>(more info soon)</p>"}]}