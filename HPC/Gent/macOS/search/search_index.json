{"config": {"lang": ["en"], "separator": "[\\_\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Welcome", "text": "<p>Welcome to the HPC-UGent infrastructure documentation!</p> <p>Use the menu on the left to navigate, or use the search box on the top right.</p> <p>If you still have any questions, you can contact the HPC-UGent team.</p> <p>This is the documentation from the point of view of a macOS user. To switch to the documentation for another operating system, click here.</p>"}, {"location": "FAQ/", "title": "Frequently Asked Questions (FAQ)", "text": "<p>New users should consult the Introduction to HPC and the HPC user manual to get started. This web page is a great resource for troubleshooting and looking up specifics.</p> <p>If you want to use software that's not yet installed on the HPC, send us a software installation request.</p> <p>Overview of HPC-UGent Tier-2 infrastructure</p>"}, {"location": "FAQ/#composing-a-job", "title": "Composing a job", "text": ""}, {"location": "FAQ/#how-many-coresnodes-should-i-request", "title": "How many cores/nodes should I request?", "text": "<p>An important factor in this question is how well your task is being parallellized: does it actually run faster with more resources? You can test this yourself: start with 4 cores, then 8, then 16... The execution time should each time be reduced to around half of what it was before. You can also try this with full nodes: 1 node, 2 nodes. A rule of thumb is that you're around the limit when you double the resources but the execution time is still ~60-70% of what it was before. That's a signal to stop increasing the core count.</p> <p>See also: Running batch jobs.</p>"}, {"location": "FAQ/#which-packages-are-available", "title": "Which packages are available?", "text": "<p>When connected to the HPC, use the commands <code>module avail [search_text]</code> and <code>module spider [module]</code> to find installed modules and get information on them.</p> <p>Among others, many packages for both Python and R are readily available on the HPC. These aren't always easy to find, though, as we've bundled them together.</p> <p>Specifically, the module <code>SciPy-bundle</code> includes numpy, pandas, scipy and a few others. For R, the normal R module has many libraries included. The bundle <code>R-bundle-Bioconductor</code> contains more libraries. Use the command <code>module spider [module]</code> to find the specifics on these bundles.</p> <p>If the package or library you want is not available, send us a software installation request.</p>"}, {"location": "FAQ/#how-do-i-choose-the-job-modules", "title": "How do I choose the job modules?", "text": "<p>Modules each come with a suffix that describes the toolchain used to install them.</p> <p>Examples:</p> <ul> <li> <p>AlphaFold/2.2.2-foss-2021a</p> </li> <li> <p>tqdm/4.61.2-GCCcore-10.3.0</p> </li> <li> <p>Python/3.9.5-GCCcore-10.3.0</p> </li> <li> <p>matplotlib/3.4.2-foss-2021a</p> </li> </ul> <p>Modules from the same toolchain always work together, and modules from a *different version of the same toolchain* never work together.</p> <p>The above set of modules works together: an overview of compatible toolchains can be found here: https://docs.easybuild.io/en/latest/Common-toolchains.html#overview-of-common-toolchains.</p> <p>You can use <code>module avail [search_text]</code> to see which versions on which toolchains are available to use.</p> <p>If you need something that's not available yet, you can request it through a software installation request.</p> <p>It is possible to use the modules without specifying a version or toolchain. However, this will probably cause incompatible modules to be loaded. Don't do it if you use multiple modules. Even if it works now, as more modules get installed on the HPC, your job can suddenly break.</p>"}, {"location": "FAQ/#troubleshooting-jobs", "title": "Troubleshooting jobs", "text": ""}, {"location": "FAQ/#my-modules-dont-work-together", "title": "My modules don't work together", "text": "<p>When incompatible modules are loaded, you might encounter an error like this:</p> <pre><code>Lmod has detected the following error: A different version of the 'GCC' module\nis already loaded (see output of 'ml').\n</code></pre> <p>You should load another <code>foss</code> module for that is compatible with the currently loaded version of <code>GCC</code>. Use <code>ml spider foss</code> to get an overview of the available versions.</p> <p>Modules from the same toolchain always work together, and modules from a different version of the same toolchain never work together.</p> <p>An overview of compatible toolchains can be found here: https://docs.easybuild.io/en/latest/Common-toolchains.html#overview-of-common-toolchains.</p> <p>See also: How do I choose the job modules?</p>"}, {"location": "FAQ/#my-job-takes-longer-than-72-hours", "title": "My job takes longer than 72 hours", "text": "<p>The 72 hour walltime limit will not be extended. However, you can work around this barrier:</p> <ul> <li>Check that all available resources are being used. See also:<ul> <li>How many cores/nodes should I request?.</li> <li>My job is slow.</li> <li>My job isn't using any GPUs.</li> </ul> </li> <li>Use a faster cluster.</li> <li>Divide the job into more parallel processes.</li> <li>Divide the job into shorter processes, which you can submit as separate jobs.</li> <li>Use the built-in checkpointing of your software.</li> </ul>"}, {"location": "FAQ/#job-failed-segv-segmentation-fault", "title": "Job failed: SEGV Segmentation fault", "text": "<p>Any error mentioning <code>SEGV</code> or <code>Segmentation fault/violation</code> has something to do with a memory error. If you weren't messing around with memory-unsafe applications or programming, your job probably hit its memory limit.</p> <p>When there's no memory amount specified in a job script, your job will get access to a proportional share of the total memory on the node: If you request a full node, all memory will be available. If you request <code>8</code> cores on a cluster where nodes have <code>2x18</code> cores, you will get <code>8/36 = 2/9</code> of the total memory on the node.</p> <p>Try requesting a bit more memory than your proportional share, and see if that solves the issue.</p> <p>See also: Specifying memory requirements.</p>"}, {"location": "FAQ/#my-compilationcommand-fails-on-login-node", "title": "My compilation/command fails on login node", "text": "<p>When logging in, you are using a connection to the login nodes. There are somewhat strict limitations on what you can do in those sessions: check out the output of <code>ulimit -a</code>. Specifically, the memory and the amount of processes you can use may present an issue. This is common with MATLAB compilation and Nextflow. An error caused by the login session limitations can look like this: <code>Aborted (core dumped)</code>.</p> <p>It's easy to get around these limitations: start an interactive session on one of the clusters. Then, you are acting as a node on that cluster instead of a login node. Notably, the debug/interactive cluster will grant such a session immediately, while other clusters might make you wait a bit. Example command: <code>ml swap cluster/donphan &amp;&amp; qsub -I -l nodes=1:ppn=8</code></p> <p>See also: Running interactive jobs.</p>"}, {"location": "FAQ/#my-job-isnt-using-any-gpus", "title": "My job isn't using any GPUs", "text": "<p>Only two clusters have GPUs. Check out the infrastructure overview, to see which one suits your needs. Make sure that you manually switch to the GPU cluster before you submit the job. Inside the job script, you need to explicitly request the GPUs: <code>#PBS -l nodes=1:ppn=24:gpus=2</code></p> <p>Some software modules don't have GPU support, even when running on the GPU cluster. For example, when running <code>module avail alphafold</code> on the joltik cluster, you will find versions on both the foss toolchain and the fossCUDA toolchain. Of these, only the CUDA versions will use GPU power. When in doubt, CUDA means GPU support.</p> <p>See also: HPC-UGent GPU clusters.</p>"}, {"location": "FAQ/#my-job-runs-slower-than-i-expected", "title": "My job runs slower than I expected", "text": "<p>There are a few possible causes why a job can perform worse than expected.</p> <p>Is your job using all the available cores you've requested? You can test this by increasing and decreasing the core amount: If the execution time stays the same, the job was not using all cores. Some workloads just don't scale well with more cores. If you expect the job to be very parallelizable and you encounter this problem, maybe you missed some settings that enable multicore execution. See also: How many cores/nodes should i request?</p> <p>Does your job have access to the GPUs you requested? See also: My job isn't using any GPUs</p> <p>Not all file locations perform the same. In particular, the <code>$VSC_HOME</code> and <code>$VSC_DATA</code> directories are, relatively, very slow to access. Your jobs should rather use the <code>$VSC_SCRATCH</code> directory, or other fast locations (depending on your needs), described in Where to store your data on the HPC. As an example how do this: The job can copy the input to the scratch directory, then execute the computations, and lastly copy the output back to the data directory. Using the home and data directories is especially a problem when UGent isn't your home institution: your files may be stored, for example, in Leuven while you're running a job in Ghent.</p>"}, {"location": "FAQ/#my-mpi-job-fails", "title": "My MPI job fails", "text": "<p>Use <code>mympirun</code> in your job script instead of <code>mpirun</code>. It is a tool that makes sure everything gets set up correctly for the HPC infrastructure. You need to load it as a module in your job script: <code>module load vsc-mympirun</code>.</p> <p>To submit the job, use the <code>qsub</code> command rather than <code>sbatch</code>. Although both will submit a job, <code>qsub</code> will correctly interpret the <code>#PBS</code> parameters inside the job script. <code>sbatch</code> might not set the job environment up correctly for mympirun/OpenMPI.</p> <p>See also: Multi core jobs/Parallel Computing and Mympirun.</p>"}, {"location": "FAQ/#mympirun-seems-to-ignore-its-arguments", "title": "<code>mympirun</code> seems to ignore its arguments", "text": "<p>For example, we have a simple script (<code>./hello.sh</code>):</p> <pre><code>#!/bin/bash \necho \"hello world\"\n</code></pre> <p>And we run it like <code>mympirun ./hello.sh --output output.txt</code>.</p> <p>To our surprise, this doesn't output to the file <code>output.txt</code>, but to standard out! This is because <code>mympirun</code> expects the program name and the arguments of the program to be its last arguments. Here, the <code>--output output.txt</code> arguments are passed to <code>./hello.sh</code> instead of to <code>mympirun</code>. The correct way to run it is:</p> <pre><code>mympirun --output output.txt ./hello.sh\n</code></pre>"}, {"location": "FAQ/#when-will-my-job-start", "title": "When will my job start?", "text": "<p>See the explanation about how jobs get prioritized in When will my job start. </p>"}, {"location": "FAQ/#other", "title": "Other", "text": ""}, {"location": "FAQ/#can-i-share-my-account-with-someone-else", "title": "Can I share my account with someone else?", "text": "<p>NO. You are not allowed to share your VSC account with anyone else, it is strictly personal. </p> <p>See https://helpdesk.ugent.be/account/en/regels.php. </p> <p>If you want to share data, there are alternatives (like a shared directories in VO space, see Virtual organisations).</p>"}, {"location": "FAQ/#can-i-share-my-data-with-other-hpc-users", "title": "Can I share my data with other HPC users?", "text": "<p>Yes, you can use the <code>chmod</code> or <code>setfacl</code> commands to change permissions of files so other users can access the data. For example, the following command will enable a user named \"otheruser\" to read the file named <code>dataset.txt</code>. See</p> <pre><code>$ setfacl -m u:otheruser:r dataset.txt\n$ ls -l dataset.txt\n-rwxr-x---+ 2 vsc40000 mygroup      40 Apr 12 15:00 dataset.txt\n</code></pre> <p>For more information about <code>chmod</code> or <code>setfacl</code>, see Linux tutorial.</p>"}, {"location": "FAQ/#can-i-use-multiple-different-ssh-key-pairs-to-connect-to-my-vsc-account", "title": "Can I use multiple different SSH key pairs to connect to my VSC account?", "text": "<p>Yes, and this is recommended when working from different computers. Please see Adding multiple SSH public keys on how to do this.</p>"}, {"location": "FAQ/#i-want-to-use-software-that-is-not-available-on-the-clusters-yet", "title": "I want to use software that is not available on the clusters yet", "text": "<p>Please fill out the details about the software and why you need it in this form: https://www.ugent.be/hpc/en/support/software-installation-request. When submitting the form, a mail will be sent to hpc@ugent.be containing all the provided information. The HPC team will look into your request as soon as possible you and contact you when the installation is done or if further information is required. </p>"}, {"location": "FAQ/#is-my-connection-compromised-remote-host-identification-has-changed", "title": "Is my connection compromised? Remote host identification has changed", "text": "<p>On Monday 25 April 2022, the login nodes received an update to RHEL8. This means that the host keys of those servers also changed. As a result, you could encounter the following warnings.</p> <p>MacOS &amp; Linux (on Windows, only the second part is shown):</p> <pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nxx:xx:xx.\nPlease contact your system administrator.\nAdd correct host key in /home/hostname/.ssh/known_hosts to get rid of this message.\nOffending RSA key in /var/lib/sss/pubconf/known_hosts:1\nRSA host key for user has changed and you have requested strict checking.\nHost key verification failed.\n</code></pre> <p>Please follow the instructions at migration to RHEL8 to ensure it really is not a hacking attempt - you will find the correct host key to compare. You will also find how to hide the warning.</p>"}, {"location": "FAQ/#vo-how-does-it-work", "title": "VO: how does it work?", "text": "<p>A Virtual Organisation consists of a number of members and moderators. A moderator can:</p> <ul> <li> <p>Manage the VO members (but can't access/remove their data on the system).</p> </li> <li> <p>See how much storage each member has used, and set limits per member.</p> </li> <li> <p>Request additional storage for the VO.</p> </li> </ul> <p>One person can only be part of one VO, be it as a member or moderator. It's possible to leave a VO and join another one. However, it's not recommended to keep switching between VO's (to supervise groups, for example).</p> <p>See also: Virtual Organisations.</p>"}, {"location": "FAQ/#my-ugent-shared-drives-dont-show-up", "title": "My UGent shared drives don't show up", "text": "<p>After mounting the UGent shared drives with <code>kinit your_email@ugent.be</code>, you might not see an entry with your username when listing <code>ls /UGent</code>. This is normal: try <code>ls /UGent/your_username</code> or <code>cd /UGent/your_username</code>, and you should be able to access the drives. Be sure to use your UGent username and not your VSC username here.</p> <p>See also: Your UGent home drive and shares.</p>"}, {"location": "FAQ/#i-have-another-questionproblem", "title": "I have another question/problem", "text": "<p>Who can I contact?</p> <ul> <li> <p>General questions regarding HPC-UGent and VSC: hpc@ugent.be</p> </li> <li> <p>HPC-UGent Tier-2: hpc@ugent.be</p> </li> <li> <p>VSC Tier-1 compute: compute@vscentrum.be</p> </li> <li> <p>VSC Tier-1 cloud: cloud@vscentrum.be</p> </li> </ul>"}, {"location": "HOD/", "title": "Hanythingondemand (HOD)", "text": "<p>Hanythingondemand (or HOD for short) is a tool to run a Hadoop (Yarn) cluster on a traditional HPC system.</p>"}, {"location": "HOD/#documentation", "title": "Documentation", "text": "<p>The official documentation for HOD version 3.0.0 and newer is available at https://hod.readthedocs.org/en/latest/. The slides of the 2016 HOD training session are available at http://users.ugent.be/~kehoste/hod_20161024.pdf.</p>"}, {"location": "HOD/#using-hod", "title": "Using HOD", "text": "<p>Before using HOD, you first need to load the <code>hod</code> module. We don't specify a version here (this is an exception, for most other modules you should, see Using explicit version numbers) because newer versions might include important bug fixes.</p> <pre><code>$ module load hod\n</code></pre>"}, {"location": "HOD/#compatibility-with-login-nodes", "title": "Compatibility with login nodes", "text": "<p>The <code>hod</code> modules are constructed such that they can be used on the HPC-UGent infrastructure login nodes, regardless of which <code>cluster</code> module is loaded (this is not the case for software installed via modules in general, see Running software that is incompatible with host).</p> <p>As such, you should experience no problems if you swap to a different cluster module before loading the <code>hod</code> module and subsequently running |hod|.</p> <p>For example, this will work as expected:</p> <pre><code>$ module swap cluster/skitty\n$ module load hod\n$ hod\nhanythingondemand - Run services within an HPC cluster\nusage: hod  [subcommand options]\nAvailable subcommands (one of these must be specified!):\n    batch           Submit a job to spawn a cluster on a PBS job controller, run a job script, and tear down the cluster when it's done\n    clean           Remove stale cluster info.\n...\n\n\n<p>Note that also modules named <code>hanythingondemand/*</code> are available. These\nshould however not be used directly, since they may not be compatible\nwith the login nodes (depending on which cluster they were installed\nfor).</p>"}, {"location": "HOD/#standard-hod-configuration", "title": "Standard HOD configuration", "text": "<p>The <code>hod</code> module will also put a basic configuration in place for HOD,\nby defining a couple of <code>$HOD_*</code> environment variables:</p>\n<pre><code>$ module load hod\n$ env | grep HOD | sort\nHOD_BATCH_HOD_MODULE=hanythingondemand/3.2.2-intel-2016b-Python-2.7.12\nHOD_BATCH_WORKDIR=$VSC_SCRATCH/hod\nHOD_CREATE_HOD_MODULE=hanythingondemand/3.2.2-intel-2016b-Python-2.7.12\nHOD_CREATE_WORKDIR=$VSC_SCRATCH/hod\n</code></pre>\n\n<p>By defining these environment variables, we avoid that you have to\nspecify <code>--hod-module</code> and <code>--workdir</code> when using <code>hod batch</code> or\n<code>hod create</code>, since they are strictly required.</p>\n<p>If you want to use a different parent working directory for HOD, it\nsuffices to either redefine <code>$HOD_BATCH_WORKDIR</code> and\n<code>$HOD_CREATE_WORKDIR</code>, or to specify <code>--workdir</code> (which will override\nthe corresponding environment variable).</p>\n<p>Changing the HOD module that is used by the HOD backend (i.e., using\n<code>--hod-module</code> or redefining <code>$HOD_*_HOD_MODULE</code>) is strongly\ndiscouraged.</p>"}, {"location": "HOD/#cleaning-up", "title": "Cleaning up", "text": "<p>After HOD clusters terminate, their local working directory and cluster\ninformation is typically not cleaned up automatically (for example,\nbecause the job hosting an interactive HOD cluster submitted via\n<code>hod create</code> runs out of walltime).</p>\n<p>These HOD clusters will still show up in the output of <code>hod list</code>, and\nwill be marked as <code>&lt;job-not-found&gt;</code>.</p>\n<p>You should occasionally clean this up using <code>hod clean</code>:</p>\n<pre><code>$ module list\nCurrently Loaded Modulefiles:\n  1) cluster/victini(default)   2) pbs_python/4.6.0            3) vsc-base/2.4.2              4) hod/3.0.0-cli\n\n$ hod list\nCluster label   Job ID         State                Hosts\nexample1        123456         &lt;job-not-found&gt;     &lt;none&gt;\n\n$ hod clean\nRemoved cluster localworkdir directory /user/scratch/gent/vsc400/vsc40000/hod/hod/123456 for cluster labeled example1\nRemoved cluster info directory /user/home/gent/vsc400/vsc40000/.config/hod.d/wordcount for cluster labeled example1\n\n$ module swap cluster/skitty\nCluster label   Job ID                          State               Hosts\nexample2        98765.master19.skitty.gent.vsc  &lt;job-not-found&gt;     &lt;none&gt;\n\n$ hod clean\nRemoved cluster localworkdir directory /user/scratch/gent/vsc400/vsc40000/hod/hod/98765.master19.skitty.gent.vsc for cluster labeled example2\nRemoved cluster info directory /user/home/gent/vsc400/vsc40000/.config/hod.d/wordcount for cluster labeled example2\n</code></pre>\n<p>Note that only HOD clusters that were submitted to the currently loaded <code>cluster</code> module will be cleaned up.</p>"}, {"location": "HOD/#getting-help", "title": "Getting help", "text": "<p>If you have any questions, or are experiencing problems using HOD, you\nhave a couple of options:</p>\n<ul>\n<li>\n<p>Subscribe to the HOD mailing list via\n    https://lists.ugent.be/wws/info/hod, and contact the HOD users and\n    developers at hod@lists.ugent.be.</p>\n</li>\n<li>\n<p>Contact the HPC-UGent team via hpc@ugent.be</p>\n</li>\n<li>\n<p>Open an issue in the <code>hanythingondemand</code> GitHub repository, via\n    https://github.com/hpcugent/hanythingondemand/issues.</p>\n</li>\n</ul>"}, {"location": "MATLAB/", "title": "MATLABs", "text": ""}, {"location": "MATLAB/#why-is-the-matlab-compiler-required", "title": "Why is the MATLAB compiler required?", "text": "<p>The main reason behind this alternative way of using MATLAB is licensing: only a limited number of MATLAB sessions can be active at the same time. However, once the MATLAB program is compiled using the MATLAB compiler, the resulting stand-alone executable can be run without needing to contact the license server.</p> <p>Note that a license is required for the MATLAB Compiler, see https://nl.mathworks.com/help/compiler/index.html. If the <code>mcc</code> command is provided by the MATLAB installation you are using, the MATLAB compiler can be used as explained below.</p> <p>Only a limited amount of MATLAB sessions can be active at the same time because there are only a limited amount of MATLAB research licenses available on the UGent MATLAB license server. If each job would need a license, licenses would quickly run out.</p>"}, {"location": "MATLAB/#how-to-compile-matlab-code", "title": "How to compile MATLAB code", "text": "<p>Compiling MATLAB code can only be done from the login nodes, because only login nodes can access the MATLAB license server, workernodes on clusters can not.</p> <p>To access the MATLAB compiler, the <code>MATLAB</code> module should be loaded first. Make sure you are using the same <code>MATLAB</code> version to compile and to run the compiled MATLAB program.</p> <pre><code>$ module avail MATLAB\n----------------------/apps/gent/victini/modules/all----------------------\n   MATLAB/2016b    MATLAB/2017b    MATLAB/2018a (D)\n$ module load MATLAB/2018a\n</code></pre> <p>After loading the <code>MATLAB</code> module, the <code>mcc</code> command can be used. To get help on <code>mcc</code>, you can run <code>mcc -?</code>.</p> <p>To compile a standalone application, the <code>-m</code> flag is used (the <code>-v</code> flag means verbose output). To show how <code>mcc</code> can be used, we use the <code>magicsquare</code> example that comes with MATLAB.</p> <p>First, we copy the <code>magicsquare.m</code> example that comes with MATLAB to <code>example.m</code>:</p> <pre><code>$ cp $EBROOTMATLAB/extern/examples/compiler/magicsquare.m example.m\n</code></pre> <p>To compile a MATLAB program, use <code>mcc -mv</code>:</p> <pre><code>mcc -mv example.m\nOpening log file:  /user/home/gent/vsc400/vsc40000/java.log.34090\nCompiler version: 6.6 (R2018a)\nDependency analysis by REQUIREMENTS.\nParsing file \"/user/home/gent/vsc400/vsc40000/example.m\"\n    (Referenced from: \"Compiler Command Line\").\nDeleting 0 temporary MEX authorization files.\nGenerating file \"/user/home/gent/vsc400/vsc40000/readme.txt\".\nGenerating file \"run\\_example.sh\".\n</code></pre>"}, {"location": "MATLAB/#libraries", "title": "Libraries", "text": "<p>To compile a MATLAB program that needs a library, you can use the <code>-I library_path</code> flag. This will tell the compiler to also look for files in <code>library_path</code>.</p> <p>It's also possible to use the <code>-a path</code> flag. That will result in all files under the <code>path</code> getting added to the final executable.</p> <p>For example, the command <code>mcc -mv example.m -I examplelib -a datafiles</code> will compile <code>example.m</code> with the MATLAB files in <code>examplelib</code>, and will include all files in the <code>datafiles</code> directory in the binary it produces.</p>"}, {"location": "MATLAB/#memory-issues-during-compilation", "title": "Memory issues during compilation", "text": "<p>If you are seeing Java memory issues during the compilation of your MATLAB program on the login nodes, consider tweaking the default maximum heap size (128M) of Java using the <code>_JAVA_OPTIONS</code> environment variable with:</p> <pre><code>$ export _JAVA_OPTIONS=\"-Xmx64M\"\n</code></pre> <p>The MATLAB compiler spawns multiple Java processes, and because of the default memory limits that are in effect on the login nodes, this might lead to a crash of the compiler if it's trying to create to many Java processes. If we lower the heap size, more Java processes will be able to fit in memory.</p> <p>Another possible issue is that the heap size is too small. This could result in errors like:</p> <pre><code>Error: Out of memory\n</code></pre> <p>A possible solution to this is by setting the maximum heap size to be bigger:</p> <pre><code>$ export _JAVA_OPTIONS=\"-Xmx512M\"\n</code></pre>"}, {"location": "MATLAB/#multithreading", "title": "Multithreading", "text": "<p>MATLAB can only use the cores in a single workernode (unless the Distributed Computing toolbox is used, see https://nl.mathworks.com/products/distriben.html).</p> <p>The amount of workers used by MATLAB for the parallel toolbox can be controlled via the <code>parpool</code> function: <code>parpool(16)</code> will use 16 workers. It's best to specify the amount of workers, because otherwise you might not harness the full compute power available (if you have too few workers), or you might negatively impact performance (if you have too much workers). By default, MATLAB uses a fixed number of workers (12).</p> <p>You should use a number of workers that is equal to the number of cores you requested when submitting your job script (the <code>ppn</code> value, see Generic resource requirements). You can determine the right number of workers to use via the following code snippet in your MATLAB program:</p> -- parpool.m -- <pre><code>% specify the right number of workers (as many as there are cores available in the job) when creating the parpool\nc = parcluster('local')\npool = parpool(c.NumWorkers)\n</code></pre> <p>See also the parpool documentation.</p>"}, {"location": "MATLAB/#java-output-logs", "title": "Java output logs", "text": "<p>Each time MATLAB is executed, it generates a Java log file in the users home directory. The output log directory can be changed using:</p> <pre><code>$ MATLAB_LOG_DIR=&lt;OUTPUT_DIR&gt;\n</code></pre> <p>where <code>&lt;OUTPUT_DIR&gt;</code> is the name of the desired output directory. To create and use a temporary directory for these logs:</p> <pre><code># create unique temporary directory in $TMPDIR (or /tmp/$USER if\n$TMPDIR is not defined)\n# instruct MATLAB to use this directory for log files by setting $MATLAB_LOG_DIR\n$  export MATLAB_LOG_DIR=$ (mktemp -d -p $TMPDIR:-/tmp/$USER)\n</code></pre> <p>You should remove the directory at the end of your job script:</p> <pre><code>$  rm -rf $MATLAB_LOG_DIR\n</code></pre>"}, {"location": "MATLAB/#cache-location", "title": "Cache location", "text": "<p>When running, MATLAB will use a cache for performance reasons. This location and size of this cache can be changed trough the <code>MCR_CACHE_ROOT</code> and <code>MCR_CACHE_SIZE</code> environment variables.</p> <p>The snippet below would set the maximum cache size to 1024MB and the location to <code>/tmp/testdirectory</code>.</p> <pre><code>$ export MATLAB_CACHE_ROOT=/tmp/testdirectory \n$ export MATLAB_CACHE_SIZE=1024M \n</code></pre> <p>So when MATLAB is running, it can fill up to 1024MB of cache in <code>/tmp/testdirectory</code>.</p>"}, {"location": "MATLAB/#matlab-job-script", "title": "MATLAB job script", "text": "<p>All of the tweaks needed to get MATLAB working have been implemented in an example job script. This job script is also available on the HPC.</p> -- jobscript.sh -- <pre><code>#!/bin/bash\n#PBS -l nodes=1:ppn=1\n#PBS -l walltime=1:0:0\n#\n# Example (single-core) MATLAB job script\n# see http://hpcugent.github.io/vsc_user_docs/\n#\n\n# make sure the MATLAB version matches with the one used to compile the MATLAB program!\nmodule load MATLAB/2018a\n\n# use temporary directory (not $HOME) for (mostly useless) MATLAB log files\n# subdir in $TMPDIR (if defined, or /tmp otherwise)\nexport MATLAB_LOG_DIR=$(mktemp -d -p  ${TMPDIR:-/tmp})\n\n# configure MATLAB Compiler Runtime cache location &amp; size (1GB)\n# use a temporary directory in /dev/shm (i.e. in memory) for performance reasons\nexport MCR_CACHE_ROOT=$(mktemp -d -p /dev/shm)\nexport MCR_CACHE_SIZE=1024MB\n\n# change to directory where job script was submitted from\ncd $PBS_O_WORKDIR\n\n# run compiled example MATLAB program 'example', provide '5' as input argument to the program\n# $EBROOTMATLAB points to MATLAB installation directory\n./run_example.sh $EBROOTMATLAB 5\n</code></pre>"}, {"location": "VNC/", "title": "Graphical applications with VNC", "text": "<p>VNC is still available at UGent site but we encourage our users to replace VNC by X2Go client. Please see Graphical applications with X2Go for more information.</p> <p>Virtual Network Computing is a graphical desktop sharing system that enables you to interact with graphical software running on the HPC infrastructure from your own computer.</p> <p>Please carefully follow the instructions below, since the procedure to connect to a VNC server running on the HPC infrastructure is not trivial, due to security constraints.</p>"}, {"location": "VNC/#starting-a-vnc-server", "title": "Starting a VNC server", "text": "<p>First login on the login node (see First time connection to the HPC infrastructure, then start <code>vncserver</code> with:</p> <pre><code>$ vncserver -geometry 1920x1080 -localhost\nYou will require a password to access your desktops.\n\nPassword:&lt;enter a secure password&gt;\nVerify:&lt;enter the same password&gt;\nWould you like to enter a view-only password (y/n)? n\nA view-only password is not used\n\nNew 'gligar07.gastly.os:6 (vsc40000)' desktop is gligar07.gastly.os:6\n\nCreating default startup script /user/home/gent/vsc400/vsc40000.vnc/xstartup\nCreating default config /user/home/gent/vsc400/vsc40000.vnc/config\nStarting applications specified in /user/home/gent/vsc400/vsc40000.vnc/xstartup\nLog file is /user/home/gent/vsc400/vsc40000.vnc/gligar07.gastly.os:6.log\n</code></pre> <p>When prompted for a password, make sure to enter a secure password: if someone can guess your password, they will be able to do anything with your account you can!</p> <p>Note down the details in bold: the hostname (in the example: <code>gligar07.gastly.os</code>) and the (partial) port number (in the example: <code>6</code>).</p> <p>It's important to remember that VNC sessions are permanent. They survive network problems and (unintended) connection loss. This means you can logout and go home without a problem (like the terminal equivalent <code>screen</code> or <code>tmux</code>). This also means you don't have to start <code>vncserver</code> each time you want to connect.</p>"}, {"location": "VNC/#list-running-vnc-servers", "title": "List running VNC servers", "text": "<p>You can get a list of running VNC servers on a node with</p> <pre><code>$ vncserver -list\nTigerVNC server sessions:\n\nX DISPLAY # PROCESS ID\n:6          30713\n</code></pre> <p>This only displays the running VNC servers on the login node you run the command on.</p> <p>To see what login nodes you are running a VNC server on, you can run the <code>ls .vnc/*.pid</code> command in your home directory: the files shown have the hostname of the login node in the filename:</p> <pre><code>$ cd $HOME\n$ ls .vnc/*.pid\n.vnc/gligar07.gastly.os:6.pid\n.vnc/gligar08.gastly.os:8.pid\n</code></pre> <p>This shows that there is a VNC server running on <code>gligar07.gastly.os</code> on port 5906 and another one running <code>gligar08.gastly.os</code> on port 5908 (see also Determining the source/destination port).</p>"}, {"location": "VNC/#connecting-to-a-vnc-server", "title": "Connecting to a VNC server", "text": "<p>The VNC server runs on a (in the example above, on <code>gligar07.gastly.os</code>).</p> <p>In order to access your VNC server, you will need to set up an SSH tunnel from your workstation to this login node (see Setting up the SSH tunnel(s)).</p> <p>Login nodes are rebooted from time to time. You can check that the VNC server is still running in the same node by executing <code>vncserver -list</code> (see also  List running VNC servers). If you get an empty list, it means that there is no VNC server running on the login node.</p> <p>To set up the SSH tunnel required to connect to your VNC server, you will need to port forward the VNC port to your workstation.</p> <p>The host is <code>localhost</code>, which means \"your own computer\": we set up an SSH tunnel that connects the VNC port on the login node to the same port on your local computer.</p>"}, {"location": "VNC/#determining-the-sourcedestination-port", "title": "Determining the source/destination port", "text": "<p>The destination port is the port on which the VNC server is running (on the login node), which is the sum of <code>5900</code> and the partial port number we noted down earlier (<code>6</code>); in the running example, that is <code>5906</code>.</p> <p>The source port is the port you will be connecting to with your VNC client on your workstation. Although you can use any (free) port for this, we strongly recommend to use the same value as the destination port.</p> <p>So, in our running example, both the source and destination ports are <code>5906</code>.</p>"}, {"location": "VNC/#picking-an-intermediate-port-to-connect-to-the-right-login-node", "title": "Picking an intermediate port to connect to the right login node", "text": "<p>In general, you have no control over which login node you will be on when setting up the SSH tunnel from your workstation to <code>login.hpc.ugent.be</code> (see Setting up the SSH tunnel(s)).</p> <p>If the login node you end up on is a different one than the one where your VNC server is running (i.e., <code>gligar08.gastly.os</code> rather than <code>gligar07.gastly.os</code> in our running example), you need to create a second SSH tunnel on the login node you are connected to, in order to \"patch through\" to the correct port on the login node where your VNC server is running.</p> <p>In the remainder of these instructions, we will assume that we are indeed connected to a different login node. Following these instructions should always work, even if you happen to be connected to the correct login node.</p> <p>To set up the second SSH tunnel, you need to pick an (unused) port on the login node you are connected to, which will be used as an intermediate port.</p> <p>Now we have a chicken-egg situation: you need to pick a port before setting up the SSH tunnel from your workstation to <code>gligar07.gastly.os</code>, but only after starting the SSH tunnel will you be able to determine whether the port you picked is actually free or not...</p> <p>In practice, if you pick a random number between $10000$ and $30000$, you have a good chance that the port will not be used yet.</p> <p>We will proceed with $12345$ as intermediate port, but you should pick another value that other people are not likely to pick. If you need some inspiration, run the following command on a Linux server (for example on a login node): <code>echo $RANDOM</code> (but do not use a value lower than $1025$).</p>"}, {"location": "VNC/#setting-up-the-ssh-tunnels", "title": "Setting up the SSH tunnel(s)", "text": ""}, {"location": "VNC/#setting-up-the-first-ssh-tunnel-from-your-workstation-to-loginhpcugentbe", "title": "Setting up the first SSH tunnel from your workstation to login.hpc.ugent.be", "text": "<p>First, we will set up the SSH tunnel from our workstation to .</p> <p>Use the settings specified in the sections above:</p> <ul> <li> <p>source port: the port on which the VNC server is running (see Determining the source/destination port);</p> </li> <li> <p>destination host: <code>localhost</code>;</p> </li> <li> <p>destination port: use the intermediate port you picked (see Picking an intermediate port to connect to the right login node)</p> </li> </ul> <p>Execute the following command to set up the SSH tunnel.</p> <pre><code>$ ssh -L 5906:localhost:12345  vsc40000@login.hpc.ugent.be\n</code></pre> <p>Replace the source port <code>5906</code>, destination port <code>12345</code> and user ID vsc40000 with your own!</p> <p>With this, we have forwarded port <code>5906</code> on our workstation to port <code>12345</code> on the login node we are connected to.</p> <p>Again, do not use <code>12345</code> as destination port, as this port will most likely be used by somebody else already; replace it with a port number you picked yourself, which is unlikely to be used already (see Picking an intermediate port to connect to the right login node).</p>"}, {"location": "VNC/#checking-whether-the-intermediate-port-is-available", "title": "Checking whether the intermediate port is available", "text": "<p>Before continuing, it's good to check whether the intermediate port that you have picked is actually still available (see Picking an intermediate port to connect to the right login node).</p> <p>You can check using the following command (**do not forget to replace <code>12345</code> the value you picked for your intermediate port):</p> <pre><code>$ netstat -an | grep -i listen | grep tcp | grep 12345\n$\n</code></pre> <p>If you see no matching lines, then the port you picked is still available, and you can continue.</p> <p>If you see one or more matching lines as shown below, you must disconnect the first SSH tunnel, pick a different intermediate port, and set up the first SSH tunnel again using the new value.</p> <pre><code>$ netstat -an | grep -i listen | grep tcp | grep 12345\ntcp        0      0 0.0.0.0:12345           0.0.0.0:*               LISTEN\ntcp6       0      0 :::12345                :::*                    LISTEN\n$\n</code></pre>"}, {"location": "VNC/#setting-up-the-second-ssh-tunnel-to-the-correct-login-node", "title": "Setting up the second SSH tunnel to the correct login node", "text": "<p>In the session on the login node you created by setting up an SSH tunnel from your workstation to <code>login.hpc.ugent.be</code>, you now need to set up the second SSH tunnel to \"patch through\" to the login node where your VNC server is running (<code>gligar07.gastly.os</code> in our running example, see Starting a VNC server).</p> <p>To do this, run the following command:</p> <pre><code>$ ssh -L 12345:localhost:5906 gligar07.gastly.os\n$ hostname\ngligar07.gastly.os\n</code></pre> <p>With this, we are forwarding port <code>12345</code> on the login node we are connected to (which is referred to as <code>localhost</code>) through to port <code>5906</code> on our target login node (<code>gligar07.gastly.os</code>).</p> <p>Combined with the first SSH tunnel, port <code>5906</code> on our workstation is now connected to port <code>5906</code> on the login node where our VNC server is running (via the intermediate port <code>12345</code> on the login node we ended up one with the first SSH tunnel).</p> <p>**Do not forget to change the intermediate port (<code>12345</code>), destination port (<code>5906</code>), and hostname of the login node (<code>gligar07.gastly.os</code>) in the command shown above!</p> <p>As shown above, you can check again using the <code>hostname</code> command whether you are indeed connected to the right login node. If so, you can go ahead and connect to your VNC server (see Connecting using a VNC client).</p>"}, {"location": "VNC/#connecting-using-a-vnc-client", "title": "Connecting using a VNC client", "text": "<p>You can download a free VNC client from https://sourceforge.net/projects/turbovnc/files/. You can download the latest version by clicking the top-most folder that has a version number in it that doesn't also have <code>beta</code> in the version. Then download a file ending in <code>TurboVNC64-2.1.2.dmg</code> (the version number can be different) and execute it. </p> <p>Now start your VNC client and connect to <code>localhost:5906</code>. **Make sure you replace the port number <code>5906</code> with your own destination port (see Determining the source/destination port).</p> <p>When prompted for a password, use the password you used to setup the VNC server.</p> <p>When prompted for default or empty panel, choose default.</p> <p>If you have an empty panel, you can reset your settings with the following commands:</p> <pre><code>$ xfce4-panel --quit ; pkill xfconfd\n$ mkdir ~/.oldxfcesettings\n$ mv ~/.config/xfce4 ~/.oldxfcesettings\n$ xfce4-panel\n</code></pre>"}, {"location": "VNC/#stopping-the-vnc-server", "title": "Stopping the VNC server", "text": "<p>The VNC server can be killed by running</p> <pre><code>vncserver -kill :6\n</code></pre> <p>where <code>6</code> is the port number we noted down earlier. If you forgot, you can get it with <code>vncserver -list</code> (see List running VNC servers).</p>"}, {"location": "VNC/#i-forgot-the-password-what-now", "title": "I forgot the password, what now?", "text": "<p>You can reset the password by first stopping the VNC server (see ), then removing the <code>.vnc/passwd</code> file (with <code>rm .vnc/passwd</code>) and then starting the VNC server again (see Starting a VNC server).</p>"}, {"location": "account/", "title": "Getting an HPC Account", "text": ""}, {"location": "account/#getting-ready-to-request-an-account", "title": "Getting ready to request an account", "text": "<p>All users of AUGent can request an account on the HPC, which is part of the Flemish Supercomputing Centre (VSC).</p> <p>See HPC policies for more information on who is entitled to an account.</p> <p>The VSC, abbreviation of Flemish Supercomputer Centre, is a virtual supercomputer centre. It is a partnership between the five Flemish associations: the Association KU\u00a0Leuven, Ghent University Association, Brussels University Association, Antwerp University Association and the University Colleges-Limburg. The VSC is funded by the Flemish Government.</p> <p>The HPC-UGent infrastructure clusters use public/private key pairs for user authentication (rather than passwords). Technically, the private key is stored on your local computer and always stays there; the public key is stored on the HPC. Access to the HPC is granted to anyone who can prove to have access to the corresponding private key on his local computer.</p>"}, {"location": "account/#how-do-ssh-keys-work", "title": "How do SSH keys work?", "text": "<ul> <li> <p>an SSH public/private key pair can be seen as a lock and a key</p> </li> <li> <p>the SSH public key is equivalent with a lock: you give it to the     VSC and they put it on the door that gives access to your account.</p> </li> <li> <p>the SSH private key is like a physical key: you don't hand it out     to other people.</p> </li> <li> <p>anyone who has the key (and the optional password) can unlock the     door and log in to the account.</p> </li> <li> <p>the door to your VSC account is special: it can have multiple     locks (SSH public keys) attached to it, and you only need to open     one lock with the corresponding key (SSH private key) to open     the door (log in to the account).</p> </li> </ul> <p>Since all VSC clusters use Linux as their main operating system, you will need to get acquainted with using the command-line interface and using the terminal. To open a Terminal window in macOS, open the Finder and choose</p> <p>&gt;&gt; Applications &gt; Utilities &gt; Terminal</p> <p>Before requesting an account, you need to generate a pair of ssh keys. One popular way to do this on macOS is using the OpenSSH client included with macOS, which you can then also use to log on to the clusters.</p>"}, {"location": "account/#test-openssh", "title": "Test OpenSSH", "text": "<p>Secure Shell (ssh) is a cryptographic network protocol for secure data communication, remote command-line login, remote command execution, and other secure network services between two networked computers. In short, ssh provides a secure connection between 2 computers via insecure channels (Network, Internet, telephone lines, ...).</p> <p>\"Secure\" means that:</p> <ol> <li> <p>the User is authenticated to the System; and</p> </li> <li> <p>the System is authenticated to the User; and</p> </li> <li> <p>all data is encrypted during transfer.</p> </li> </ol> <p>OpenSSH is a FREE implementation of the SSH connectivity protocol. macOS comes with its own implementation of OpenSSH, so you don't need to install any third-party software to use it. Just open a terminal window and jump in!</p> <p>On all popular Linux distributions, the OpenSSH software is readily available, and most often installed by default. You can check whether the OpenSSH software is installed by opening a terminal and typing:</p> <pre><code>$ ssh -V\nOpenSSH_7.4p1, OpenSSL 1.0.2k-fips 26 Jan 2017\n</code></pre> <p>To access the clusters and transfer your files, you will use the following commands:</p> <ol> <li> <p>ssh-keygen: to generate the ssh keysgenerate a public</p> </li> <li> <p>ssh: to open a shell on a remote machine;</p> </li> <li> <p>sftp: a secure equivalent of ftp;</p> </li> <li> <p>scp: a secure equivalent of the remote copy command rcp.</p> </li> </ol>"}, {"location": "account/#generate-a-publicprivate-key-pair-with-openssh", "title": "Generate a public/private key pair with OpenSSH", "text": "<p>A key pair might already be present in the default location inside your home directory. Therefore, we first check if a key is available with the \"list short\" (\"ls\") command:</p> <pre><code>$ ls ~/.ssh\n</code></pre> <p>If a key-pair is already available, you would normally get:</p> <pre><code>authorized_keys     id_rsa      id_rsa.pub      known_hosts\n</code></pre> <p>Otherwise, the command will show:</p> <pre><code>ls: .ssh: No such file or directory\n</code></pre> <p>You can recognise a public/private key pair when a pair of files has the same name except for the extension \".pub\" added to one of them. In this particular case, the private key is \"id_rsa\" and public key is \"id_rsa.pub\". You may have multiple keys (not necessarily in the directory \"~/.ssh\") if you or your operating system requires this. Be aware that your existing key pair might be too short, or not the right type.</p> <p>You will need to generate a new key pair, when:</p> <ol> <li> <p>you don't have a key pair yet</p> </li> <li> <p>you forgot the passphrase protecting your private key</p> </li> <li> <p>or your private key was compromised</p> </li> <li> <p>your key pair is too short or not the right type</p> </li> </ol> <p>For extra security, the private key itself can be encrypted using a \"passphrase\", to prevent anyone from using your private key even when they manage to copy it. You have to \"unlock\" the private key by typing the passphrase. Be sure to never give away your private key, it is private and should stay private. You should not even copy it to one of your other machines, instead, you should create a new public/private key pair for each machine.</p> <pre><code>$ ssh-keygen -t rsa -b 4096\nGenerating public/private rsa key pair. Enter file in which to save the\nkey (/home/user/.ssh/id_rsa): Enter passphrase (empty for no\npassphrase): Enter same passphrase again: Your identification has been\nsaved in /home/user/.ssh/id_rsa. Your public key has been saved in\n/home/user/.ssh/id_rsa.pub.\n</code></pre> <p>This will ask you for a file name to store the private and public key, and a passphrase to protect your private key. It needs to be emphasised that you really should choose the passphrase wisely! The system will ask you for it every time you want to use the private key that is every time you want to access the cluster or transfer your files.</p> <p>Without your key pair, you won't be able to apply for a personal VSC account.</p>"}, {"location": "account/#using-an-ssh-agent-optional", "title": "Using an SSH agent (optional)", "text": "<p>Most recent Unix derivatives include by default an SSH agent  to keep and manage the user SSH keys. If you use one of these derivatives you must include the new keys into the SSH manager keyring to be able to connect to the HPC cluster. If not, SSH client will display an error message (see Connecting) similar to this:</p> <pre><code>Agent admitted failure to sign using the key. \nPermission denied (publickey,gssapi-keyex,gssapi-with-mic).\n</code></pre> <p>This could be fixed using the <code>ssh-add</code> command. You can include the new private keys' identities in your keyring with:</p> <pre><code>$ ssh-add\n</code></pre> <p>Tip</p> <p>Without extra options <code>ssh-add</code> adds any key located at <code>$HOME/.ssh</code> directory, but you can specify the private key location path as argument, as example: <code>ssh-add /path/to/my/id_rsa</code>.</p> <p>Check that your key is available from the keyring with:</p> <pre><code>$ ssh-add -l\n</code></pre> <p>After these changes the key agent will keep your SSH key to connect to the clusters as usual.</p> <p>Tip</p> <p>You should execute <code>ssh-add</code> command again if you generate a new SSH key.</p>"}, {"location": "account/#applying-for-the-account", "title": "Applying for the account", "text": "<p>Visit https://account.vscentrum.be/</p> <p>You will be redirected to our WAYF (Where Are You From) service where you have to select your \"Home Organisation\".</p> <p></p> <p>Select \"UGent\" in the dropdown box and optionally select \"Save my preference\" and \"permanently\".</p> <p>Click Confirm</p> <p>You will now be taken to the authentication page of your institute.</p> <p>You will now have to log in with CAS using your UGent account.</p> <p>You either have a login name of maximum 8 characters, or a (non-UGent) email address if you are an external user. In case of problems with your UGent password, please visit: https://password.ugent.be/. After logging in, you may be requested to share your information. Click \"Yes, continue\".</p> <p></p> <p>After you log in using your UGent login and password, you will be asked to upload the file that contains your public key, i.e., the file \"id_rsa.pub\" which you have generated earlier. Make sure that your public key is actually accepted for upload, beacuse if it is in a wrong format, wrong type or too short, then it will be refused.</p> <p>This file has been stored in the directory \"~/.ssh/\".</p> <p>Tip</p> <p>As \".ssh\" is an invisible directory, the Finder will not show it by default. The easiest way to access the folder, is by pressing Cmd+Shift+G (or Cmd+Shift+.), which will allow you to enter the name of a directory, which you would like to open in Finder. Here, type \"~/.ssh\" and press enter.</p> <p>After you have uploaded your public key you will receive an e-mail with a link to confirm your e-mail address. After confirming your e-mail address the VSC staff will review and if applicable approve your account.</p>"}, {"location": "account/#welcome-e-mail", "title": "Welcome e-mail", "text": "<p>Within one day, you should receive a Welcome e-mail with your VSC account details.</p> <pre><code>Dear (Username), \nYour VSC-account has been approved by an administrator.\nYour vsc-username is vsc40000\n\nYour account should be fully active within one hour.\n\nTo check or update your account information please visit\nhttps://account.vscentrum.be/\n\nFor further info please visit https://www.vscentrum.be/user-portal\n\nKind regards,\n-- The VSC administrators\n</code></pre> <p>Now, you can start using the HPC. You can always look up your VSC id later by visiting https://account.vscentrum.be.</p>"}, {"location": "account/#adding-multiple-ssh-public-keys-optional", "title": "Adding multiple SSH public keys (optional)", "text": "<p>In case you are connecting from different computers to the login nodes, it is advised to use separate SSH public keys to do so. You should follow these steps.</p> <ol> <li> <p>Create a new public/private SSH key pair from the new computer.     Repeat the process described in     section\u00a0Generate a public/private key pair with OpenSSH.</p> </li> <li> <p>Go to https://account.vscentrum.be/django/account/edit</p> </li> <li> <p>Upload the new SSH public key using the Add public key section. Make sure that your     public key is actually saved, because a public key will be refused     if it is too short, wrong type, or in a wrong format.</p> </li> <li> <p>(optional) If you lost your key, you can delete the old key on the     same page. You should keep at least one valid public SSH key in your     account.</p> </li> <li> <p>Take into account that it will take some time before the new SSH     public key is active in your account on the system; waiting for     15-30 minutes should be sufficient.</p> </li> </ol>"}, {"location": "account/#computation-workflow-on-the-hpc", "title": "Computation Workflow on the HPC", "text": "<p>A typical Computation workflow will be:</p> <ol> <li> <p>Connect to the HPC</p> </li> <li> <p>Transfer your files to the HPC</p> </li> <li> <p>Compile your code and test it</p> </li> <li> <p>Create a job script</p> </li> <li> <p>Submit your job</p> </li> <li> <p>Wait while</p> <ol> <li> <p>your job gets into the queue</p> </li> <li> <p>your job gets executed</p> </li> <li> <p>your job finishes</p> </li> </ol> </li> <li> <p>Move your results</p> </li> </ol> <p>We'll take you through the different tasks one by one in the following chapters.</p>"}, {"location": "apptainer/", "title": "Apptainer (formally known as Singularity)", "text": ""}, {"location": "apptainer/#what-is-apptainer", "title": "What is Apptainer?", "text": "<p>Apptainer is an open-source computer program that performs operating-system-level virtualization (also known as containerisation).</p> <p>One of the main uses of Apptainer is to bring containers and reproducibility to scientific computing and the high-performance computing (HPC) world. Using Apptainer/Singularity containers, developers can work in reproducible environments of their choosing and design, and these complete environments can easily be copied and executed on other platforms.</p> <p>For more general information about the use of Apptainer, please see the official documentation at https://apptainer.org/docs/.</p> <p>This documentation only covers aspects of using Apptainer on the HPC-UGent infrastructure infrastructure.</p>"}, {"location": "apptainer/#restrictions-on-image-location", "title": "Restrictions on image location", "text": "<p>Some restrictions have been put in place on the use of Apptainer. This is mainly done for performance reasons and to avoid that the use of Apptainer impacts other users on the system.</p> <p>The Apptainer/Singularity image file must be located on either one of the scratch filesystems, the local disk of the workernode you are using or <code>/dev/shm</code>. The centrally provided <code>apptainer</code> command will refuse to run using images that are located elsewhere, in particular on the <code>$VSC_HOME</code>, <code>/apps</code> or <code>$VSC_DATA</code> filesystems.</p> <p>In addition, this implies that running containers images provided via a URL (e.g., <code>shub://...</code> or <code>docker://...</code>) will not work.</p> <p>If these limitations are a problem for you, please let us know via hpc@ugent.be.</p>"}, {"location": "apptainer/#available-filesystems", "title": "Available filesystems", "text": "<p>All HPC-UGent shared filesystems will be readily available in an Apptainer/Singularity container, including the home, data and scratch filesystems, and they will be accessible via the familiar <code>$VSC_HOME</code>, <code>$VSC_DATA*</code> and <code>$VSC_SCRATCH*</code> environment variables.</p>"}, {"location": "apptainer/#apptainersingularity-images", "title": "Apptainer/Singularity Images", "text": ""}, {"location": "apptainer/#creating-apptainersingularity-images", "title": "Creating Apptainer/Singularity images", "text": "<p>Creating new Apptainer/Singularity images or converting Docker images, by default, requires admin privileges, which is obviously not available on the HPC-UGent infrastructure infrastructure. However, if you use the <code>--fakeroot</code> option, you can make new Apptainer/Singularity images or convert Docker images.</p> <p>Due to the nature of <code>--fakeroot</code> option, we recommend to write your Apptainer/Singularity image to a globally writable location, like <code>/tmp</code>, or <code>/local</code> directories. Once the image is created, you should move it to your desired destination. An example to make an Apptainer/Singularity container:</p> <pre><code>$ APPTAINER_CACHEDIR=/tmp/ \\\nAPPTAINER_TMPDIR=/tmp/ \\\napptainer build --fakeroot /tmp/tensorflow-21.10-tf1-py3.sif \\\ndocker://nvcr.io/nvidia/tensorflow:21.10-tf1-py3\n</code></pre>"}, {"location": "apptainer/#converting-docker-images", "title": "Converting Docker images", "text": "<p>For more information on converting existing Docker images to Apptainer/Singularity images, see https://apptainer.org/docs/user/main/docker_and_oci.html.</p> <p>We strongly recommend the use of Docker Hub, see https://hub.docker.com/ for more information.</p>"}, {"location": "apptainer/#execute-our-own-script-within-our-container", "title": "Execute our own script within our container", "text": "<p>Copy testing image from <code>/apps/gent/tutorials/Singularity</code> to <code>$VSC_SCRATCH</code>:</p> <pre><code>$ cp /apps/gent/tutorials/Singularity/CentOS7_EasyBuild.img $VSC_SCRATCH/\n</code></pre> <p>Create a job script like:</p> <pre><code>#!/bin/sh\n\n#PBS -o apptainer.output\n#PBS -e apptainer.error\n#PBS -l nodes=1:ppn=1\n#PBS -l walltime=12:00:00\n\n\napptainer exec $VSC_SCRATCH/CentOS7_EasyBuild.img ~/my_script.sh\n</code></pre> <p>Create an example <code>myscript.sh</code>:</p> <pre><code>#!/bin/bash\n\n# prime factors\nfactor 1234567\n</code></pre>"}, {"location": "apptainer/#tensorflow-example", "title": "Tensorflow example", "text": "<p>We already have a Tensorflow example image, but you can also convert the Docker image (see https://hub.docker.com/r/tensorflow/tensorflow) to a Apptainer/Singularity image yourself</p> <p>Copy testing image from <code>/apps/gent/tutorials</code> to <code>$VSC_SCRATCH</code>:</p> <pre><code>$ cp /apps/gent/tutorials/Singularity/Ubuntu14.04_tensorflow.img $VSC_SCRATCH/\n</code></pre> <pre><code>#!/bin/sh\n#\n#\n#PBS -o tensorflow.output\n#PBS -e tensorflow.error\n#PBS -l nodes=1:ppn=4\n#PBS -l walltime=12:00:00\n#\n\napptainer exec $VSC_SCRATCH/Ubuntu14.04_tensorflow.img python ~/linear_regression.py\n</code></pre> <p>You can download <code>linear_regression.py</code> from the official Tensorflow repository.</p>"}, {"location": "apptainer/#mpi-example", "title": "MPI example", "text": "<p>It is also possible to execute MPI jobs within a container, but the following requirements apply:</p> <ul> <li> <p>Mellanox IB libraries must be available from the container (install     the <code>infiniband-diags</code>, <code>libmlx5-1</code> and <code>libmlx4-1</code> OS packages)</p> </li> <li> <p>Use modules within the container (install the <code>environment-modules</code>     or <code>lmod</code> package in your container)</p> </li> <li> <p>Load the required module(s) before <code>apptainer</code> execution.</p> </li> <li> <p>Set <code>C_INCLUDE_PATH</code> variable in your container if it is required     during compilation time     (<code>export C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu/:$C_INCLUDE_PATH</code>     for Debian flavours)</p> </li> </ul> <p>Copy the testing image from <code>/apps/gent/tutorials/Singularity</code> to <code>$VSC_SCRATCH</code></p> <pre><code>$ cp /apps/gent/tutorials/Singularity/Debian8_UGentMPI.img $VSC_SCRATCH/\n</code></pre> <p>For example to compile an MPI example:</p> <pre><code>$ module load intel\n$ apptainer shell $VSC_SCRATCH/Debian8_UGentMPI.img\n$ export LANG=C\n$ export C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu/:$C_INCLUDE_PATH\n$ mpiicc ompi/examples/ring_c.c -o ring_debian\n$ exit\n</code></pre> <p>Example MPI job script:</p> <pre><code>#!/bin/sh\n\n#PBS -N mpi\n#PBS -o apptainermpi.output\n#PBS -e apptainermpi.error\n#PBS -l nodes=2:ppn=15\n#PBS -l walltime=12:00:00\n\nmodule load intel vsc-mympirun\nmympirun --impi-fallback apptainer exec $VSC_SCRATCH/Debian8_UGentMPI.img ~/ring_debian\n</code></pre>"}, {"location": "best_practices/", "title": "Best Practices", "text": ""}, {"location": "best_practices/#sec:general-best-practices", "title": "General Best Practices", "text": "<ol> <li> <p>Before starting, you should always check:</p> <ul> <li> <p>Are there any errors in the script?</p> </li> <li> <p>Are the required modules loaded?</p> </li> <li> <p>Is the correct executable used?</p> </li> </ul> </li> <li> <p>Check your computer requirements upfront, and request the correct     resources in your batch job script.</p> <ul> <li> <p>Number of requested cores</p> </li> <li> <p>Amount of requested memory</p> </li> <li> <p>Requested network type</p> </li> </ul> </li> <li> <p>Check your jobs at runtime. You could login to the node and check     the proper execution of your jobs with, e.g., <code>top</code> or <code>vmstat</code>.     Alternatively you could run an interactive job (<code>qsub -I</code>).</p> </li> <li> <p>Try to benchmark the software for scaling issues when using MPI or     for I/O issues.</p> </li> <li> <p>Use the scratch file system (<code>$VSC_SCRATCH_NODE</code>, which is mapped to     the local /tmp) whenever possible. Local disk I/O is always much     faster as it does not have to use the network.</p> </li> <li> <p>When your job starts, it will log on to the compute node(s) and     start executing the commands in the job script. It will start in     your home directory <code>$VSC_HOME</code>, so going to the current directory     with <code>cd $PBS_O_WORKDIR</code> is the first thing which needs to be done.     You will have your default environment, so don't forget to load the     software with <code>module load</code>.</p> </li> <li> <p>Submit your job and wait (be patient) ...</p> </li> <li> <p>Submit small jobs by grouping them together. See chapter Multi-job submission for      how this is done.</p> </li> <li> <p>The runtime is limited by the maximum walltime of the queues. For     longer walltimes, use checkpointing.</p> </li> <li> <p>Requesting many processors could imply long queue times. It's     advised to only request the resources you'll be able to use.</p> </li> <li> <p>For all multi-node jobs, please use a cluster that has an     \"InfiniBand\" interconnect network.</p> </li> <li> <p>And above all, do not hesitate to contact the HPC staff at hpc@ugent.be. We're here     to help you.</p> </li> </ol>"}, {"location": "checkpointing/", "title": "Checkpointing", "text": ""}, {"location": "checkpointing/#why-checkpointing", "title": "Why checkpointing?", "text": "<p>If you want to run jobs that require wall time than the maximum wall time per job and/or want to avoid you lose work because of power outages or system crashes, you need to resort to checkpointing.</p>"}, {"location": "checkpointing/#what-is-checkpointing", "title": "What is checkpointing?", "text": "<p>Checkpointing allows for running jobs that run for weeks or months, by splitting the job into smaller parts (called subjobs) which are executed consecutively. Each time a subjob is running out of requested wall time, a snapshot of the application memory (and much more) is taken and stored, after which a subsequent subjob will pick up the checkpoint and continue.</p>"}, {"location": "checkpointing/#how-to-use-checkpointing", "title": "How to use checkpointing?", "text": "<p>Using checkpointing is very simple: just use <code>csub</code> instead of <code>qsub</code> to submit a job.</p> <p>The <code>csub</code> command creates a wrapper around your job script, to take care of all the checkpointing stuff.</p> <p>In practice, you (usually) don't need to adjust anything, except for the command used to submit your job.</p> <p>Checkpointing does not require any changes to the application you are running, and should support most software.</p>"}, {"location": "checkpointing/#usage-and-parameters", "title": "Usage and parameters", "text": "<p>An overview of the usage and various command line parameters is given here.</p>"}, {"location": "checkpointing/#submitting-a-job", "title": "Submitting a job", "text": "<p>Typically, a job script is submitted with checkpointing support enabled by running:</p> <p>::: prompt csub -s job_script.sh :::</p> <p>The <code>-s</code> flag specifies the job script to run.</p>"}, {"location": "checkpointing/#caveat-dont-create-local-directories", "title": "Caveat: don't create local directories", "text": "<p>One important caveat is that the job script (or the applications run in the script) should not create its own local temporary directories, because those will not (always) be restored when the job is restarted from checkpoint.</p>"}, {"location": "checkpointing/#pbs-directives", "title": "PBS directives", "text": "<p>Most PBS directives (<code>#PBS \u2026</code> specified in the job script will be ignored. There are a few exceptions however, i.e., <code># PBS -N &lt;name&gt;</code> (job name) and all <code>-l</code> directives (<code># PBS -l</code>), e.g., <code>nodes</code>, <code>ppn</code>, <code>vmem</code> (virtual memory limit), etc. Controlling other job parameters (like requested walltime per sub-job) should be specified on the <code>csub</code> command line.</p>"}, {"location": "checkpointing/#getting-help", "title": "Getting help", "text": "<p>Help on the various command line parameters supported by <code>csub</code> can be obtained using <code>-h</code> or <code>--help</code>.</p>"}, {"location": "checkpointing/#local-files-pre-post", "title": "Local files (<code>\u2013pre</code> / <code>\u2013post</code>)", "text": "<p>The <code>--pre</code> and <code>--post</code> parameters control whether local files are copied or not. The job submitted using <code>csub</code> is (by default) run on the local storage provided by a particular workernode. Thus, no changes will be made to the files on the shared storage.</p> <p>If the job script needs (local) access to the files of the directory where <code>csub</code> is executed, <code>--pre</code> flag should be used. This will copy all the files in the job script directory to the location where the job script will execute.</p> <p>If the output of the job (<code>stdout</code>/<code>stderr</code>) that was run, or additional output files created by the job in its working directory are required, the <code>--post</code> flag should be used. This will copy the entire job working directory to the location where <code>csub</code> was executed, in a directory named <code>result.&lt;jobname&gt;</code>. An alternative is to copy the interesting files to the shared storage at the end of the job script.</p>"}, {"location": "checkpointing/#running-on-shared-storage-shared", "title": "Running on shared storage (<code>\u2013shared</code>)", "text": "<p>If the job needs to be run on the shared storage, <code>--shared</code> should be specified. You should enable this option by default, because it makes the execution of the underlying <code>csub</code> script more robust: it doesn't have to copy from/to the local storage on the workernode. When enabled, the job will be run in a subdirectory of <code>$VSC_SCRATCH/chkpt</code>. All files produced by the job will be in <code>$VSC_SCRATCH/chkpt/&lt;jobid&gt;/</code> while the job is running.</p> <p>Note that if files in the directory where the job script is located are required to run the job, you should also use <code>--pre</code>.</p>"}, {"location": "checkpointing/#job-wall-time-job_time-chkpt_time", "title": "Job wall time (<code>\u2013job_time</code>, <code>\u2013chkpt_time</code>)", "text": "<p>To specify the requested wall time per subjob, use the <code>--job-time</code> parameter. The default setting is 10 hours per (sub)job. Lowering this will result in more frequent checkpointing, and thus more (sub)jobs.</p> <p>To specify the time that is reserved for checkpointing the job, use <code>--chkpt_time</code>. By default, this is set to 15 minutes which should be enough for most applications/jobs. Don't change this unless you really need to.</p> <p>The total requested wall time per subjob is the sum of both <code>job_time</code> and <code>chkpt_time</code>.</p> <p>If you would like to time how long the job executes, just prepend the main command in your job script with the time command <code>time</code>, e.g.:</p> <p>::: prompt time main_command :::</p> <p>The <code>real</code> time will not make sense, as it will also include the time passed between two checkpointed subjobs. However, the <code>user</code> time should give a good indication of the actual time it took to run your command, even if multiple checkpoints were performed.</p>"}, {"location": "checkpointing/#resuming-from-last-checkpoint-resume", "title": "Resuming from last checkpoint (<code>\u2013resume</code>)", "text": "<p>The <code>--resume</code> option allows you to resume a job from the last available checkpoint in case something went wrong (e.g., accidentally deleting a (sub)job using <code>qdel</code>, a power outage or other system failure, ...).</p> <p>Specify the job name as returned after submission (and as listed in <code>$VSC_SCRATCH/chkpt</code>). The full job name consists of the specified job name (or the script name if no job name was specified), a timestamp and two random characters at the end, for example <code>my_job_name._133755.Hk</code> or <code>script.sh._133755.Hk</code>.</p> <p>Note: When resuming from checkpoint, you can change the wall time resources for your job using the <code>--job_time</code> and <code>--chkpt_time</code> options. This should allow you to continue from the last checkpoint in case your job crashed due to an excessively long checkpointing time.</p> <p>In case resuming fails for you, please contact , and include the output of the <code>csub --resume</code> command in your message.</p>"}, {"location": "checkpointing/#additional-options", "title": "Additional options", "text": ""}, {"location": "checkpointing/#array-jobs-t", "title": "Array jobs (<code>-t</code>)", "text": "<p><code>csub</code> has support for checkpointing array jobs with the <code>-t &lt;spec&gt;</code> flag on the <code>csub</code> command line. This behaves the same as <code>qsub</code>, see .</p>"}, {"location": "checkpointing/#proepilogue-mimicking-no_mimic_pro_epi", "title": "Pro/epilogue mimicking (<code>\u2013no_mimic_pro_epi</code>)", "text": "<p>The option <code>--no_mimic_pro_epi</code> disables the workaround currently required to resolve a permissions problem when using actual Torque prologue/epilogue scripts. Don't use this option unless you really know what you are doing.</p>"}, {"location": "checkpointing/#cleanup-checkpoints-cleanup_after_restart", "title": "Cleanup checkpoints (<code>\u2013cleanup_after_restart</code>)", "text": "<p>Specifying this option will make the wrapper script remove the checkpoint files after a successful job restart. This may be desirable in cause you are short on storage space.</p> <p>Note that we don't recommend setting this option, because this way you won't be able to resume from the last checkpoint when something goes wrong. It may also prevent the wrapper script from reattempting to resubmit a new job in case an infrequent known failure occurs. So, don't set this unless you really need to.</p>"}, {"location": "checkpointing/#no-cleanup-after-job-completion-no_cleanup_chkpt", "title": "No cleanup after job completion (<code>\u2013no_cleanup_chkpt</code>)", "text": "<p>Specifying this option will prevent the wrapper script from cleaning up the checkpoints and related information once the job has finished. This may be useful for debugging, since this also preserves the <code>stdout</code>/<code>stderr</code> of the wrapper script.</p> <p>Don't set this unless you know what you are doing.</p>"}, {"location": "compiling_your_software/", "title": "Compiling and testing your software on the HPC", "text": "<p>All nodes in the HPC cluster are running the \"RHEL 8.6 (doduo, accelgor, joltik, skitty, victini, swalot, gallade, donphan)\"  Operating system, which is a specific version of Red Hat Enterprise Linux. This means that all the  software programs (executable) that the end-user wants to run on the HPC first must be compiled for RHEL 8.6 (doduo, accelgor, joltik, skitty, victini, swalot, gallade, donphan). It also means that you first have to install all the required external software packages on the HPC.</p> <p>Most commonly used compilers are already pre-installed on the HPC and can be used straight away. Also many popular external software packages, which are regularly used in the scientific community, are also pre-installed.</p>"}, {"location": "compiling_your_software/#check-the-pre-installed-software-on-the-hpc", "title": "Check the pre-installed software on the HPC", "text": "<p>In order to check all the available modules and their version numbers, which are pre-installed on the HPC enter:</p> <pre><code>$ module av 2&gt;&amp;1 | more\n--- /apps/gent/SL6/sandybridge/modules/all ---\nABAQUS/6.12.1-linux-x86_64\nAMOS/3.1.0-ictce-4.0.10\nant/1.9.0-Java-1.7.0_40\nASE/3.6.0.2515-ictce-4.1.13-Python-2.7.3\nASE/3.6.0.2515-ictce-5.5.0-Python-2.7.6\n...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., MATLAB) is installed on the HPC.</p> <pre><code>$ module av 2&gt;&amp;1 | grep -i -e \"matlab\"\nMATLAB/2010b\nMATLAB/2012b\nMATLAB/2013b\n</code></pre> <p>As you are not aware of the capitals letters in the module name, we looked for a case-insensitive name with the \"-i\" option.</p> <p>When your required application is not available on the HPC please contact any HPC member. Be aware of potential \"License Costs\". \"Open Source\" software is often preferred.</p>"}, {"location": "compiling_your_software/#porting-your-code", "title": "Porting your code", "text": "<p>To port a software-program is to translate it from the operating system in which it was developed (e.g., Windows 7) to another operating system (e.g., Red Hat Enterprise Linux on our HPC) so that it can be used there. Porting implies some degree of effort, but not nearly as much as redeveloping the program in the new environment. It all depends on how \"portable\" you wrote your code.</p> <p>In the simplest case the file or files may simply be copied from one machine to the other. However, in many cases the software is installed on a computer in a way, which depends upon its detailed hardware, software, and setup, with device drivers for particular devices, using installed operating system and supporting software components, and using different directories.</p> <p>In some cases software, usually described as \"portable software\" is specifically designed to run on different computers with compatible operating systems and processors without any machine-dependent installation; it is sufficient to transfer specified directories and their contents. Hardware- and software-specific information is often stored in configuration files in specified locations (e.g., the registry on machines running MS Windows).</p> <p>Software, which is not portable in this sense, will have to be transferred with modifications to support the environment on the destination machine.</p> <p>Whilst programming, it would be wise to stick to certain standards (e.g., ISO/ANSI/POSIX). This will ease the porting of your code to other platforms.</p> <p>Porting your code to the RHEL 8.6 (doduo, accelgor, joltik, skitty, victini, swalot, gallade, donphan) platform is the responsibility of the end-user.</p>"}, {"location": "compiling_your_software/#compiling-and-building-on-the-hpc", "title": "Compiling and building on the HPC", "text": "<p>Compiling refers to the process of translating code written in some programming language, e.g., Fortran, C, or C++, to machine code. Building is similar, but includes gluing together the machine code resulting from different source files into an executable (or library). The text below guides you through some basic problems typical for small software projects. For larger projects it is more appropriate to use makefiles or even an advanced build system like CMake.</p> <p>All the HPC nodes run the same version of the Operating System, i.e. RHEL 8.6 (doduo, accelgor, joltik, skitty, victini, swalot, gallade, donphan). So, it is sufficient to compile your program on any compute node. Once you have generated an executable with your compiler, this executable should be able to run on any other compute-node.</p> <p>A typical process looks like:</p> <ol> <li> <p>Copy your software to the login-node of the HPC</p> </li> <li> <p>Start an interactive session on a compute node;</p> </li> <li> <p>Compile it;</p> </li> <li> <p>Test it locally;</p> </li> <li> <p>Generate your job scripts;</p> </li> <li> <p>Test it on the HPC</p> </li> <li> <p>Run it (in parallel);</p> </li> </ol> <p>We assume you've copied your software to the HPC. The next step is to request your private compute node.</p> <pre><code>$ qsub -I\nqsub: waiting for job 123456 to start\n</code></pre>"}, {"location": "compiling_your_software/#compiling-a-sequential-program-in-c", "title": "Compiling a sequential program in C", "text": "<p>Go to the examples for chapter  Compiling and testing your software on the HPC and load the  foss module:</p> <pre><code>$ cd ~/examples/Compiling-and-testing-your-software-on-the-HPC\n$ module load foss\n</code></pre> <p>We now list the directory and explore the contents of the \"hello.c\" program:</p> <pre><code>$ ls -l\ntotal 512\n-rw-r--r-- 1 vsc40000 214 Sep 16 09:42 hello.c\n-rw-r--r-- 1 vsc40000 130 Sep 16 11:39 hello.pbs*\n-rw-r--r-- 1 vsc40000 359 Sep 16 13:55 mpihello.c\n-rw-r--r-- 1 vsc40000 304 Sep 16 13:55 mpihello.pbs\n</code></pre> <p>hello.c</p> <pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: Print 500 numbers, whilst waiting 1 second in between\n */\n#include \"stdio.h\"\nint main( int argc, char *argv[] )\n{\nint i;\nfor (i=0; i&lt;500; i++)\n{\nprintf(\"Hello #%d\\n\", i);\nfflush(stdout);\nsleep(1);\n}\n}\n</code></pre> <p>The \"hello.c\" program is a simple source file, written in C. It'll print 500 times \"Hello #&lt;num&gt;\", and waits one second between 2 printouts.</p> <p>We first need to compile this C-file into an executable with the gcc-compiler.</p> <p>First, check the command line options for \"gcc\" (GNU C-Compiler), then we compile and list the contents of the directory again:</p> <pre><code>$ gcc -help\n$ gcc -o hello hello.c\n$ ls -l\ntotal 512\n-rwxrwxr-x 1 vsc40000 7116 Sep 16 11:43 hello*\n-rw-r--r-- 1 vsc40000  214 Sep 16 09:42 hello.c\n-rwxr-xr-x 1 vsc40000  130 Sep 16 11:39 hello.pbs*\n</code></pre> <p>A new file \"hello\" has been created. Note that this file has \"execute\" rights, i.e., it is an executable. More often than not, calling gcc -- or any other compiler for that matter -- will provide you with a list of errors and warnings referring to mistakes the programmer made, such as typos, syntax errors. You will have to correct them first in order to make the code compile. Warnings pinpoint less crucial issues that may relate to performance problems, using unsafe or obsolete language features, etc. It is good practice to remove all warnings from a compilation process, even if they seem unimportant so that a code change that produces a warning does not go unnoticed.</p> <p>Let's test this program on the local compute node, which is at your disposal after the \"qsub --I\" command:</p> <pre><code>$ ./hello\nHello #0\nHello #1\nHello #2\nHello #3\nHello #4\n...\n</code></pre> <p>It seems to work, now run it on the HPC</p> <pre><code>$ qsub hello.pbs</code></pre>"}, {"location": "compiling_your_software/#compiling-a-parallel-program-in-cmpi", "title": "Compiling a parallel program in C/MPI", "text": "<pre><code>$ cd ~/examples/Compiling-and-testing-your-software-on-the-HPC</code></pre> <p>List the directory and explore the contents of the \"mpihello.c\" program:</p> <pre><code>$ ls -l\ntotal 512\ntotal 512\n-rw-r--r-- 1 vsc40000 214 Sep 16 09:42 hello.c\n-rw-r--r-- 1 vsc40000 130 Sep 16 11:39 hello.pbs*\n-rw-r--r-- 1 vsc40000 359 Sep 16 13:55 mpihello.c\n-rw-r--r-- 1 vsc40000 304 Sep 16 13:55 mpihello.pbs\n</code></pre> <p>mpihello.c</p> <pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: Example program, to compile with MPI\n */\n#include &lt;stdio.h&gt;\n#include &lt;mpi.h&gt;\n\nmain(int argc, char **argv)\n{\nint node, i, j;\nfloat f;\n\nMPI_Init(&amp;argc,&amp;argv);\nMPI_Comm_rank(MPI_COMM_WORLD, &amp;node);\n\nprintf(\"Hello World from Node %d.\\n\", node);\nfor (i=0; i&lt;=100000; i++)\nf=i*2.718281828*i+i+i*3.141592654;\n\nMPI_Finalize();\n}\n</code></pre> <p>The \"mpi_hello.c\" program is a simple source file, written in C with MPI library calls.</p> <p>Then, check the command line options for \"mpicc\" (GNU C-Compiler with MPI extensions), then we compile and list the contents of the directory again:</p> <pre><code>$ mpicc --help\n$ mpicc -o mpihello mpihello.c\n$ ls -l</code></pre> <p>A new file \"hello\" has been created. Note that this program has \"execute\" rights.</p> <p>Let's test this program on the \"login\" node first:</p> <pre><code>$ ./mpihello\nHello World from Node 0.</code></pre> <p>It seems to work, now run it on the HPC.</p> <pre><code>$ qsub mpihello.pbs</code></pre>"}, {"location": "compiling_your_software/#compiling-a-parallel-program-in-intel-parallel-studio-cluster-edition", "title": "Compiling a parallel program in Intel Parallel Studio Cluster Edition", "text": "<p>We will now compile the same program, but using the Intel Parallel Studio Cluster Edition compilers. We stay in the examples directory for this chapter:</p> <pre><code>$ cd ~/examples/Compiling-and-testing-your-software-on-the-HPC</code></pre> <p>We will compile this C/MPI -file into an executable with the Intel Parallel Studio Cluster Edition. First, clear the modules (purge) and then load the latest \"intel\" module:</p> <pre><code>$ module purge\n$ module load intel\n</code></pre> <p>Then, compile and list the contents of the directory again. The Intel equivalent of mpicc is mpiicc.</p> <pre><code>$ mpiicc -o mpihello mpihello.c\n$ ls -l</code></pre> <p>Note that the old \"mpihello\" file has been overwritten. Let's test this program on the \"login\" node first:</p> <pre><code>$ ./mpihello\nHello World from Node 0.</code></pre> <p>It seems to work, now run it on the HPC.</p> <pre><code>$ qsub mpihello.pbs</code></pre> <p>Note: The AUGent only has a license for the Intel Parallel Studio Cluster Edition for a fixed number of users. As such, it might happen that you have to wait a few minutes before a floating license becomes available for your use.</p> <p>Note: The Intel Parallel Studio Cluster Edition contains equivalent compilers for all GNU compilers. Hereafter the overview for C, C++ and Fortran compilers.</p> Sequential Program Parallel Program (with MPI) GNU Intel GNU Intel C gcc icc mpicc mpiicc C++ g++ icpc mpicxx mpiicpc Fortran gfortran ifort mpif90 mpiifort"}, {"location": "connecting/", "title": "Connecting to the HPC infrastructure", "text": "<p>Before you can really start using the HPC clusters, there are several things you need to do or know:</p> <ol> <li> <p>You need to log on to the cluster using an SSH client to one of     the login nodes. This will give you command-line access. The     software you'll need to use on your client system depends on its     operating system.</p> </li> <li> <p>Before you can do some work, you'll have to transfer the files     that you need from your desktop computer to the cluster. At the end     of a job, you might want to transfer some files back.</p> </li> <li> <p>Optionally, if you wish to use programs with a graphical user     interface, you will need an X-server on your client system and log     in to the login nodes with X-forwarding enabled.</p> </li> <li> <p>Often several versions of software packages and libraries are     installed, so you need to select the ones you need. To manage     different versions efficiently, the VSC clusters use so-called     modules, so you will need to select and load the modules that     you need.</p> </li> </ol>"}, {"location": "connecting/#connection-restrictions", "title": "Connection restrictions", "text": "<p>Since March 20th 2020, restrictions are in place that limit from where you can connect to the VSC HPC infrastructure, in response to security incidents involving several European HPC centres.</p> <p>VSC login nodes are only directly accessible from within university networks, and from (most) Belgian commercial internet providers.</p> <p>All other IP domains are blocked by default. If you are connecting from an IP address that is not allowed direct access, you have the following options to get access to VSC login nodes:</p> <ul> <li> <p>Use an VPN connection to connect to UGent the network (recommended). See https://helpdesk.ugent.be/vpn/en/ for more information. </p> </li> <li> <p>Whitelist your IP address automatically by accessing     https://firewall.vscentrum.be and log in with your UGent account.</p> <ul> <li> <p>While this web connection is active new SSH sessions can be     started.</p> </li> <li> <p>Active SSH sessions will remain active even when this web page     is closed.</p> </li> </ul> </li> <li> <p>Contact your HPC support team (via hpc@ugent.be) and ask them to whitelist your     IP range (e.g., for industry access, automated processes).</p> </li> </ul> <p>Trying to establish an SSH connection from an IP address that does not adhere to these restrictions will result in an immediate failure to connect, with an error message like:</p> <pre><code>ssh_exchange_identification: read: Connection reset by peer\n</code></pre>"}, {"location": "connecting/#first-time-connection-to-the-hpc-infrastructure", "title": "First Time connection to the HPC infrastructure", "text": "<p>If you have any issues connecting to the HPC after you've followed these steps, see Issues connecting to login node to troubleshoot.</p>"}, {"location": "connecting/#connect", "title": "Connect", "text": "<p>Open up a terminal and enter the following command to connect to the HPC. You can open a terminal by navigation to Applications and then Utilities in the finder and open Terminal.app, or enter Terminal in Spotlight Search.</p> <pre><code>$ ssh vsc40000@login.hpc.ugent.be\n</code></pre> <p>Here, user vsc40000 wants to make a connection to the \"hpcugent\" cluster at UGent via the login node \"login.hpc.ugent.be\", so replace vsc40000 with your own VSC id in the above command.</p> <p>The first time you make a connection to the login node, you will be asked to verify the authenticity of the login node. Please check Warning message when first connecting to new host-first-connecting-to-new-host) on how to do this.</p> <p>A possible error message you can get if you previously saved your private key somewhere else than the default location (<code>$HOME/.ssh/id_rsa</code>):</p> <pre><code>Permission denied (publickey,gssapi-keyex,gssapi-with-mic).\n</code></pre> <p>In this case, use the <code>-i</code> option for the <code>ssh</code> command to specify the location of your private key. For example:</p> <pre><code>$ ssh -i /home/example/my_keys\n</code></pre> <p>Congratulations, you're on the HPC infrastructure now! To find out where you have landed you can print the current working directory:</p> <pre><code>$ pwd\n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>Your new private home directory is \"/user/home/gent/vsc400/vsc40000\". Here you can create your own subdirectory structure, copy and prepare your applications, compile and test them and submit your jobs on the HPC.</p> <pre><code>$ cd /apps/gent/tutorials\n$ ls\nIntro-HPC/\n</code></pre> <p>This directory currently contains all training material for the Introduction to the HPC. More relevant training material to work with the HPC can always be added later in this directory.</p> <p>You can now explore the content of this directory with the \"ls --l\" (lists long) and the \"cd\" (change irectory) commands:</p> <p>As we are interested in the use of the HPC, move further to Intro-HPC and explore the contents up to 2 levels deep:</p> <pre><code>$ cd Intro-HPC\n$ tree -L 2\n.\n'-- examples \n    |-- Compiling-and-testing-your-software-on-the-HPC \n    |-- Fine-tuning-Job-Specifications \n    |-- Multi-core-jobs-Parallel-Computing\n    |-- Multi-job-submission \n    |-- Program-examples \n    |-- Running-batch-jobs\n    |-- Running-jobs-with-input \n    |-- Running-jobs-with-input-output-data\n    |-- example.pbs \n    '-- example.sh \n9 directories, 5 files\n</code></pre> <p>This directory contains:</p> <ol> <li> <p>This HPC Tutorial (in either a Mac, Linux or      Windows version).</p> </li> <li> <p>An examples subdirectory, containing all the examples that you need in this     Tutorial, as well as examples that might be useful for your specific applications.</p> </li> </ol> <pre><code>$ cd examples\n</code></pre> <p>Tip</p> <p>Typing <code>cd ex</code> followed by Tab (the Tab-key) will generate the <code>cd examples</code> command. Command-line completion (also tab completion) is a common feature of the bash command line interpreter, in which the program automatically fills in partially typed commands.</p> <p>Tip</p> <p>For more exhaustive tutorials about Linux usage, see Appendix Useful Linux Commands</p> <p>The first action is to copy the contents of the HPC examples directory to your home directory, so that you have your own personal copy and that you can start using the examples. The \"-r\" option of the copy command will also copy the contents of the sub-directories \"recursively\".</p> <pre><code>$ cp -r /apps/gent/tutorials/Intro-HPC/examples ~/\n</code></pre> <p>Go to your home directory, check your own private examples directory, ...\u00a0and start working.</p> <pre><code>$ cd\n$ ls -l\n</code></pre> <p>Upon connecting you will see a login message containing your last login time stamp and a basic overview of the current cluster utilisation.</p> <pre><code>Last login: Thu Mar 18 13:15:09 2021 from gligarha02.gastly.os\n\nSTEVIN HPC-UGent infrastructure status on Thu, 18 Mar 2021 13:30:01\n\n   cluster - full - free -  part - total - running - queued\n             nodes  nodes   free   nodes    jobs      jobs\n-------------------------------------------------------------------\n    swalot     9      0    104     126     N/A       N/A\n    skitty    53      0     16      72     N/A       N/A\n   victini    40      0     54      96     N/A       N/A\n    joltik     8      0      2      10     N/A       N/A\n     doduo   115      0     13     128     N/A       N/A\n  accelgor     8      1      0       9     N/A       N/A\n\nFor a full view of the current loads and queues see:\nhttps://hpc.ugent.be/clusterstate/ \nUpdates on current system status and planned maintenance can be found on https://www.ugent.be/hpc/en/infrastructure/status\n</code></pre> <p>You can exit the connection at anytime by entering:</p> <pre><code>$ exit\nlogout\nConnection to login.hpc.ugent.be closed.\n</code></pre> <p>tip: Setting your Language right</p> <p>You may encounter a warning message similar to the following one during connecting:</p> <p><pre><code>perl: warning: Setting locale failed.\nperl: warning: Please check that your locale settings:\nLANGUAGE = (unset),\nLC_ALL = (unset),\nLC_CTYPE = \"UTF-8\",\nLANG = (unset)\n    are supported and installed on your system.\nperl: warning: Falling back to the standard locale (\"C\").\n</code></pre> or any other error message complaining about the locale.</p> <p>This means that the correct \"locale\" has not yet been properly specified on your local machine. Try: <pre><code>LANG=\nLC_COLLATE=\"C\"\nLC_CTYPE=\"UTF-8\"\nLC_MESSAGES=\"C\"\nLC_MONETARY=\"C\"\nLC_NUMERIC=\"C\"\nLC_TIME=\"C\"\nLC_ALL=\n</code></pre></p> <p>A locale is a set of parameters that defines the user's language, country and any special variant preferences that the user wants to see in their user interface. Usually a locale identifier consists of at least a language identifier and a region identifier.</p> <p>Note</p> <p>If you try to set a non-supported locale, then it will be automatically set to the default. Currently the default is <code>en_US.UFT-8</code> or <code>en_US</code>, depending on whether your originally (non-supported) locale was <code>UTF-8</code> or not.</p> <p>Open the <code>.bashrc</code> on your local machine with your favourite editor and add the following lines:</p> <pre><code>$ nano ~/.bashrc\n...\nexport LANGUAGE=\"en_US.UTF-8\"\nexport LC_ALL=\"en_US.UTF-8\"\nexport LC_CTYPE=\"en_US.UTF-8\"\nexport LANG=\"en_US.UTF-8\"\n...\n</code></pre> <p>tip: vi</p> <p>To start entering text in vi: move to the place you want to start entering text with the arrow keys and type \"i\" to switch to insert mode. You can easily exit vi by entering: \"ESC :wq\"  To exit vi without saving your changes, enter \"ESC:q!\"</p> <p>or alternatively (if you are not comfortable with the Linux editors), again on your local machine:</p> <pre><code>$ echo \"export LANGUAGE=\\\"en_US.UTF-8\\\"\" &gt;&gt; ~/.profile\n$ echo \"export LC_ALL=\\\"en_US.UTF-8\\\"\" &gt;&gt; ~/.profile\n$ echo \"export LC_CTYPE=\\\"en_US.UTF-8\\\"\" &gt;&gt; ~/.profile\n$ echo \"export LANG=\\\"en_US.UTF-8\\\"\" &gt;&gt; ~/.profile\n</code></pre> <p>You can now log out, open a new terminal/shell on your local machine and reconnect to the , and you should not get these warnings anymore.</p>"}, {"location": "connecting/#transfer-files-tofrom-the-hpc", "title": "Transfer Files to/from the HPC", "text": "<p>Before you can do some work, you'll have to transfer the files you need from your desktop or department to the cluster. At the end of a job, you might want to transfer some files back. The preferred way to transfer files is by using an scp or sftp via the secure OpenSSH protocol. macOS ships with an implementation of OpenSSH, so you don't need to install any third-party software to use it. Just open a terminal window and jump in!</p>"}, {"location": "connecting/#using-scp", "title": "Using scp", "text": "<p>Secure copy or SCP is a tool (command) for securely transferring files between a local host (= your computer) and a remote host (the HPC). It is based on the Secure Shell (SSH) protocol. The scp command is the equivalent of the cp (i.e., copy) command, but can copy files to or from remote machines.</p> <p>It's easier to copy files directly to <code>$VSC_DATA</code> and <code>$VSC_SCRATCH</code> if you have symlinks to them in your home directory. See the chapter titled \"Uploading/downloading/editing files\", section \"Symlinks for data/scratch\" in the intro to Linux  for how to do this.</p> <p>Open an additional terminal window and check that you're working on your local machine.</p> <pre><code>$ hostname\n<p>If you're still using the terminal that is connected to the HPC, close the\nconnection by typing \"exit\" in the terminal window.</p>\n<p>For example, we will copy the (local) file \"localfile.txt\" to your\nhome directory on the HPC cluster. We first generate a small dummy\n\"localfile.txt\", which contains the word \"Hello\". Use your own VSC\naccount, which is something like \"vsc40000\". Don't forget the colon (<code>:</code>) at the\nend: if you forget it, it will just create a file named vsc40000@login.hpc.ugent.be on your\nlocal filesystem. You can even specify where to save the file on the\nremote filesystem by putting a path after the colon.</p>\n<pre><code>$ echo \"Hello\" &gt; localfile.txt\n$ ls -l \n...\n-rw-r--r-- 1 user  staff   6 Sep 18 09:37 localfile.txt\n$ scp localfile.txt vsc40000@login.hpc.ugent.be\nlocalfile.txt     100%   6     0.0KB/s     00:00\n</code></pre>\n\n<p>Connect to the HPC via another terminal, print the working directory (to\nmake sure you're in the home directory) and check whether the file has\narrived:</p>\n<pre><code>$ pwd\n/user/home/gent/vsc400/vsc40000\n$ ls -l \ntotal 1536 \ndrwxrwxr-x 2 \ndrwxrwxr-x 2 \ndrwxrwxr-x 10 \n-rw-r--r-- 1 \n$ cat localfile.txt\nHello\n</code></pre>\n\n<p>The scp command can also be used to copy files from the cluster to your\nlocal machine. Let us copy the remote file \"intro-HPC-macOS-Gent.pdf\" from your \"docs\" \nsubdirectory on the cluster to your local computer.</p>\n<p>First, we will confirm that the file is indeed in the \"docs\"\nsubdirectory. On the terminal on the , enter:</p>\n<pre><code>$ cd ~/docs\n$ ls -l\ntotal 1536 \n-rw-r--r-- 1 vsc40000 Sep 11 09:53 intro-HPC-macOS-Gent.pdf\n</code></pre>\n\n<p>Now we will copy the file to the local machine. On the terminal on your\nown local computer, enter:</p>\n<pre><code>$ scp vsc40000@login.hpc.ugent.be:./docs/intro-HPC-macOS-Gent.pdf .\nintro-HPC-macOS-Gent.pdf 100% 725KB 724.6KB/s 00:01\n$ ls -l\ntotal 899 \n-rw-r--r-- 1 user staff 741995 Sep 18 09:53 \n-rw-r--r-- 1 user staff      6 Sep 18 09:37 localfile.txt\n</code></pre>\n\n<p>The file has been copied from the HPC to your local computer.</p>\n<p>It's also possible to copy entire directories (and their contents) with\nthe <code>-r</code> flag. For example, if we want to copy the local directory\n<code>dataset</code> to <code>$VSC_SCRATCH</code>, we can use the following command (assuming\nyou've created the <code>scratch</code> symlink):</p>\n<pre><code>$ scp -r dataset vsc40000@login.hpc.ugent.be:scratch\n</code></pre>\n\n<p>If you don't use the <code>-r</code> option to copy a directory, you will run into\nthe following error:</p>\n<pre><code>$ scp -r dataset vsc40000@login.hpc.ugent.be:scratch\ndataset: not a regular file\n</code></pre>"}, {"location": "connecting/#using-sftp", "title": "Using sftp", "text": "<p>The SSH File Transfer Protocol (also Secure File Transfer Protocol, or SFTP) is a network protocol that provides file access, file\ntransfer and file management functionalities over any reliable data\nstream. It was designed as an extension of the Secure Shell protocol\n(SSH) version 2.0. This protocol assumes that it is run over a secure\nchannel, such as SSH, that the server has already authenticated the\nclient, and that the identity of the client user is available to the\nprotocol.</p>\n<p>The sftp is an equivalent of the ftp command, with the difference that\nit uses the secure ssh protocol to connect to the clusters.</p>\n<p>One easy way of starting a sftp session is</p>\n<pre><code>$ sftp vsc40000@login.hpc.ugent.be\n</code></pre>\n\n<p>Typical and popular commands inside an sftp session are:</p>\ncd ~/exmples/fibo\nMove to the examples/fibo subdirectory on the (i.e., the HPC remote machine)\nls\nGet a list of the files in the current directory on the HPC.\nget fibo.py\nCopy the file \"fibo.py\" from the HPC\nget tutorial/HPC.pdf\nCopy the file \"HPC.pdf\" from the HPC, which is in the \"tutorial\" subdirectory.\nlcd test\nMove to the \"test\" subdirectory on your local machine.\nlcd ..\nMove up one level in the local directory.\nlls\nGet local directory listing.\nput test.py\nCopy the local file test.py to the HPC.\nput test1.py test2.py\nCopy the local file test1.py to the and rename it to test2.py.\nbye\nQuit the sftp session\nmget *.cc\nCopy all the remote files with extension \".cc\" to the local directory.\nmput *.h\nCopy all the local files with extension \".h\" to the HPC."}, {"location": "connecting/#using-a-gui-cyberduck", "title": "Using a GUI (Cyberduck)", "text": "<p>Cyberduck is a graphical alternative to the <code>scp</code> command. It can be\ninstalled from https://cyberduck.io.</p>\n<p>This is the one-time setup you will need to do before connecting:</p>\n<ol>\n<li>\n<p>After starting Cyberduck, the Bookmark tab will show up. To add a\n    new bookmark, click on the \"+\" sign on the bottom left of the\n    window. A new window will open.</p>\n</li>\n<li>\n<p>In the drop-down menu on top, select \"SFTP (SSH File Transfer Protocol)\".</p>\n</li>\n<li>\n<p>In the \"Server\" field, type in <code>login.hpc.ugent.be</code>. In the \"Username\" field, type in\n    your VSC account id (this looks like <code>vsc40000</code>).</p>\n</li>\n<li>\n<p>Select the location of your SSH private key in the \"SSH Private Key\" field.</p>\n</li>\n<li>\n<p>Finally, type in a name for the bookmark in the \"Nickname\" field and\n    close the window by pressing on the red circle in the top left\n    corner of the window.</p>\n</li>\n</ol>\n<p>To open the connection, click on the \"Bookmarks\" icon (which\nresembles an open book) and double-click on the bookmark you just\ncreated.</p>"}, {"location": "connecting/#fast-file-transfer-for-large-datasets", "title": "Fast file transfer for large datasets", "text": "<p>See the section on <code>rsync</code> in chapter 5 of the Linux intro manual.</p>"}, {"location": "crontab/", "title": "Cron scripts", "text": ""}, {"location": "crontab/#cron-scripts-configuration", "title": "Cron scripts configuration", "text": "<p>It is possible to run automated cron scripts as regular user on the Ugent login nodes. Due to the high availability setup users should add their cron scripts on the same login node to avoid any cron job script duplication.</p> <p>In order to create a new cron script first login to HPC-UGent login node as usual with your vsc user's account (see section Connecting).</p> <p>Check if any cron script is already set in the current login node with:</p> <pre><code>$ crontab -l\n</code></pre> <p>At this point you can add/edit (with <code>vi</code> editor) any cron script running the command:</p> <pre><code>$ crontab -e\n</code></pre>"}, {"location": "crontab/#example-cron-job-script", "title": "Example cron job script", "text": "<pre><code> 15 5 * * * ~/runscript.sh &gt;&amp; ~/job.out\n</code></pre> <p>where <code>runscript.sh</code> has these lines in this example:</p> <p>-- runscript.sh -- <pre><code>#!/bin/bash\n\nmodule swap cluster/donphan\nexport SLURM_CLUSTERS=\"donphan\"\n/usr/libexec/jobcli/qsub ~/job_scripts/test.sh &gt;&amp; ~/job.out\n</code></pre></p> <p>In the previous example a cron script was set to be executed every day at 5:15 am. More information about crontab and cron scheduling format at https://www.redhat.com/sysadmin/automate-linux-tasks-cron.</p> <p>Please note that you should login into the same login node to edit your previously generated crontab tasks. If that is not the case you can always jump from one login node to another with:</p> <pre><code>$ ssh gligar&lt;id&gt;\n</code></pre>"}, {"location": "easybuild/", "title": "Easybuild", "text": ""}, {"location": "easybuild/#what-is-easybuild", "title": "What is Easybuild?", "text": "<p>You can use EasyBuild to build and install supported software in your own VSC account, rather than requesting a central installation by the HPC support team.</p> <p>EasyBuild (https://easybuilders.github.io/easybuild) is the software build and installation framework that was created by the HPC-UGent team, and has recently been picked up by HPC sites around the world. It allows you to manage (scientific) software on High Performance Computing (HPC) systems in an efficient way.</p>"}, {"location": "easybuild/#when-should-i-use-easybuild", "title": "When should I use Easybuild?", "text": "<p>For general software installation requests, please see I want to use software that is not available on the clusters yet. However, there might be reasons to install the software yourself:</p> <ul> <li> <p>applying custom patches to the software that only you or your group     are using</p> </li> <li> <p>evaluating new software versions prior to requesting a central     software installation</p> </li> <li> <p>installing (very) old software versions that are no longer eligible     for central installation (on new clusters)</p> </li> </ul>"}, {"location": "easybuild/#configuring-easybuild", "title": "Configuring EasyBuild", "text": "<p>Before you use EasyBuild, you need to configure it:</p>"}, {"location": "easybuild/#path-to-sources", "title": "Path to sources", "text": "<p>This is where EasyBuild can find software sources:</p> <pre><code>$ EASYBUILD_SOURCEPATH=$VSC_DATA/easybuild/sources:/apps/gent/source \n</code></pre> <ul> <li> <p>the first directory <code>$VSC_DATA/easybuild/sources</code> is where EasyBuild     will (try to) automatically download sources if they're not     available yet</p> </li> <li> <p><code>/apps/gent/source</code> is the central \"cache\" for already downloaded     sources, and will be considered by EasyBuild before downloading     anything</p> </li> </ul>"}, {"location": "easybuild/#build-directory", "title": "Build directory", "text": "<p>This directory is where EasyBuild will build software in. To have good performance, this needs to be on a fast filesystem.</p> <pre><code>$ export EASYBUILD_BUILDPATH=${TMPDIR:-/tmp/$USER}\n</code></pre> <p>On cluster nodes, you can use the fast, in-memory <code>/dev/shm/$USER</code> location as a build directory.</p>"}, {"location": "easybuild/#software-install-location", "title": "Software install location", "text": "<p>This is where EasyBuild will install the software (and accompanying modules) to.</p> <p>For example, to let it use <code>$VSC_DATA/easybuild</code>, use:</p> <pre><code>$ export EASYBUILD_INSTALLPATH=$VSC_DATA/easybuild/$VSC_OS_LOCAL/$VSC_ARCH_LOCAL$VSC_ARCH_SUFFIX\n</code></pre> <p>Using the <code>$VSC_OS_LOCAL</code>, <code>$VSC_ARCH</code> and <code>$VSC_ARCH_SUFFIX</code> environment variables ensures that your install software to a location that is specific to the cluster you are building for.</p> <p>Make sure you do not build software on the login nodes, since the loaded <code>cluster</code> module determines the location of the installed software. Software built on the login nodes may not work on the cluster you want to use the software on (see also Running software that is incompatible with host).</p> <p>To share custom software installations with members of your VO, replace <code>$VSC_DATA</code> with <code>$VSC_DATA_VO</code> in the example above.</p>"}, {"location": "easybuild/#using-easybuild", "title": "Using EasyBuild", "text": "<p>Before using EasyBuild, you first need to load the <code>EasyBuild</code> module. We don't specify a version here (this is an exception, for most other modules you should, see Using explicit version numbers) because newer versions might include important bug fixes.</p> <pre><code>module load EasyBuild\n</code></pre>"}, {"location": "easybuild/#installing-supported-software", "title": "Installing supported software", "text": "<p>EasyBuild provides a large collection of readily available software versions, combined with a particular toolchain version. Use the <code>--search</code> (or <code>-S</code>) functionality to see which different 'easyconfigs' (build recipes, see http://easybuild.readthedocs.org/en/latest/Concepts_and_Terminology.html#easyconfig-files) are available:</p> <pre><code>$ eb -S example-1.2\nCFGS1=/apps/gent/CO7/sandybridge/software/EasyBuild/3.6.2/lib/python2.7/site-packages/easybuild_easyconfigs-3.6.2-py2.7.egg/easybuild/easyconfigs\n * $CFGS1/e/example/example-1.2.1-foss-{{ current_year }}a.eb\n * $CFGS1/e/example/example-1.2.3-foss-{{ current_year }}b.eb\n * $CFGS1/e/example/example-1.2.5-intel-{{ current_year }}a.eb\n</code></pre> <p>For readily available easyconfigs, just specify the name of the easyconfig file to build and install the corresponding software package:</p> <pre><code>$ eb example-1.2.1-foss-{{ current_year }}a.eb --robot\n</code></pre>"}, {"location": "easybuild/#installing-variants-on-supported-software", "title": "Installing variants on supported software", "text": "<p>To install small variants on supported software, e.g., a different software version, or using a different compiler toolchain, use the corresponding <code>--try-X</code> options:</p> <p>To try to install <code>example v1.2.6</code>, based on the easyconfig file for <code>example v1.2.5</code>:</p> <pre><code>$ eb example-1.2.5-intel-{{ current_year }}a.eb --try-software-version=1.2.6\n</code></pre> <p>To try to install example v1.2.5 with a different compiler toolchain:</p> <pre><code>$ eb example-1.2.5-intel-{{ current_year }}a.eb --robot --try-toolchain=intel,{{ current_year }}b\n</code></pre>"}, {"location": "easybuild/#install-other-software", "title": "Install other software", "text": "<p>To install other, not yet supported, software, you will need to provide the required easyconfig files yourself. See https://easybuild.readthedocs.org/en/latest/Writing_easyconfig_files.html for more information.</p>"}, {"location": "easybuild/#using-the-installed-modules", "title": "Using the installed modules", "text": "<p>To use the modules you installed with EasyBuild, extend <code>$MODULEPATH</code> to make them accessible for loading:</p> <pre><code>$ module use $EASYBUILD_INSTALLPATH/modules/all\n</code></pre> <p>It makes sense to put this <code>module use</code> command and all <code>export</code> commands in your <code>.bashrc</code> login script. That way you don't have to type these commands every time you want to use EasyBuild or you want to load modules generated with EasyBuild. See also the section on <code>.bashrc</code> in the \"Beyond the basics\" chapter of the intro to Linux.</p>"}, {"location": "fine_tuning_job_specifications/", "title": "Fine-tuning Job Specifications", "text": "<p>As HPC system administrators, we often observe that the HPC resources are not optimally (or wisely) used. For example, we regularly notice that several cores on a computing node are not utilised, due to the fact that one sequential program uses only one core on the node. Or users run I/O intensive applications on nodes with \"slow\" network connections.</p> <p>Users often tend to run their jobs without specifying specific PBS Job parameters. As such, their job will automatically use the default parameters, which are not necessarily (or rarely) the optimal ones. This can slow down the run time of your application, but also block HPC resources for other users.</p> <p>Specifying the \"optimal\" Job Parameters requires some knowledge of your application (e.g., how many parallel threads does my application uses, is there a lot of inter-process communication, how much memory does my application need) and also some knowledge about the HPC infrastructure (e.g., what kind of multi-core processors are available, which nodes have InfiniBand).</p> <p>There are plenty of monitoring tools on Linux available to the user, which are useful to analyse your individual application. The HPC environment as a whole often requires different techniques, metrics and time goals, which are not discussed here. We will focus on tools that can help to optimise your Job Specifications.</p> <p>Determining the optimal computer resource specifications can be broken down into different parts. The first is actually determining which metrics are needed and then collecting that data from the hosts. Some of the most commonly tracked metrics are CPU usage, memory consumption, network bandwidth, and disk I/O stats. These provide different indications of how well a system is performing, and may indicate where there are potential problems or performance bottlenecks. Once the data have actually been acquired, the second task is analysing the data and adapting your PBS Job Specifications.</p> <p>Another different task is to monitor the behaviour of an application at run time and detect anomalies or unexpected behaviour. Linux provides a large number of utilities to monitor the performance of its components.</p> <p>This chapter shows you how to measure:</p> <ol> <li>Walltime</li> <li>Memory usage</li> <li>CPU usage</li> <li>Disk (storage) needs</li> <li>Network bottlenecks</li> </ol> <p>First, we allocate a compute node and move to our relevant directory:</p> <pre><code>$ qsub -I\n$ cd ~/examples/Fine-tuning-Job-Specifications</code></pre>"}, {"location": "fine_tuning_job_specifications/#specifying-walltime", "title": "Specifying Walltime", "text": "<p>One of the most important and also easiest parameters to measure is the duration of your program. This information is needed to specify the walltime.</p> <p>The time utility executes and times your application. You can just add the time command in front of your normal command line, including your command line options. After your executable has finished, time writes the total time elapsed, the time consumed by system overhead, and the time used to execute your executable to the standard error stream. The calculated times are reported in seconds.</p> <p>Test the time command:</p> <pre><code>$ time sleep 75\nreal 1m15.005s\nuser 0m0.001s\nsys 0m0.002s</code></pre> <p>It is a good practice to correctly estimate and specify the run time (duration) of an application. Of course, a margin of 10% to 20% can be taken to be on the safe side.</p> <p>It is also wise to check the walltime on different compute nodes or to select the \"slowest\" compute node for your walltime tests. Your estimate should appropriate in case your application will run on the \"slowest\" (oldest) compute nodes.</p> <p>The walltime can be specified in a job scripts as:</p> <pre><code>#PBS -l walltime=3:00:00:00</code></pre> <p>or on the command line</p> <pre><code>$ qsub -l walltime=3:00:00:00</code></pre> <p>It is recommended to always specify the walltime for a job.</p>"}, {"location": "fine_tuning_job_specifications/#specifying-memory-requirements", "title": "Specifying memory requirements", "text": "<p>In many situations, it is useful to monitor the amount of memory an application is using. You need this information to determine the characteristics of the required compute node, where that application should run on. Estimating the amount of memory an application will use during execution is often non-trivial, especially when one uses third-party software.</p>"}, {"location": "fine_tuning_job_specifications/#available-memory-on-the-machine", "title": "Available Memory on the machine", "text": "<p>The first point is to be aware of the available free memory in your computer. The \"free\" command displays the total amount of free and used physical and swap memory in the system, as well as the buffers used by the kernel. We also use the options \"-m\" to see the results expressed in Mega-Bytes and the \"-t\" option to get totals.</p> <pre><code>$ free -m -t\n                total   used   free  shared  buffers  cached\nMem:            16049   4772  11277       0      107     161\n-/+ buffers/cache:      4503  11546\nSwap:           16002   4185  11816\nTotal:          32052   8957  23094</code></pre> <p>Important is to note the total amount of memory available in the machine (i.e., 16 GB in this example) and the amount of used and free memory (i.e., 4.7 GB is used and another 11.2 GB is free here).</p> <p>It is not a good practice to use swap-space for your computational applications. A lot of \"swapping\" can increase the execution time of your application tremendously.</p> <p>On the UGent clusters, there is no swap space available for jobs, you can only use physical memory, even though \"free\" will show swap.</p>"}, {"location": "fine_tuning_job_specifications/#checking-the-memory-consumption", "title": "Checking the memory consumption", "text": "<p>To monitor the memory consumption of a running application, you can use the \"top\" or the \"htop\" command.</p> top <p>provides an ongoing look at processor activity in real time. It displays a listing of the most CPU-intensive tasks on the system, and can provide an interactive interface for manipulating processes. It can sort the tasks by memory usage, CPU usage and run time.</p> htop <p>is similar to top, but shows the CPU-utilisation for all the CPUs in the machine and allows to scroll the list vertically and horizontally to see all processes and their full command lines.</p> <pre><code>$ top\n$ htot</code></pre>"}, {"location": "fine_tuning_job_specifications/#pbs_mem", "title": "Setting the memory parameter", "text": "<p>Once you gathered a good idea of the overall memory consumption of your application, you can define it in your job script. It is wise to foresee a margin of about 10%.</p> <p>The maximum amount of physical memory used by the job per node can be specified in a job script as:</p> <pre><code>#PBS -l mem=4gb</code></pre> <p>or on the command line</p> <pre><code>$ qsub -l mem=4gb</code></pre>"}, {"location": "fine_tuning_job_specifications/#specifying-processors-requirements", "title": "Specifying processors requirements", "text": "<p>Users are encouraged to fully utilise all the available cores on a certain compute node. Once the required numbers of cores and nodes are decently specified, it is also good practice to monitor the CPU utilisation on these cores and to make sure that all the assigned nodes are working at full load.</p>"}, {"location": "fine_tuning_job_specifications/#number-of-processors", "title": "Number of processors", "text": "<p>The number of core and nodes that a user shall request fully depends on the architecture of the application. Developers design their applications with a strategy for parallelisation in mind. The application can be designed for a certain fixed number or for a configurable number of nodes and cores. It is wise to target a specific set of compute nodes (e.g., Westmere, Harpertown) for your computing work and then to configure your software to nicely fill up all processors on these compute nodes.</p> <p>The /proc/cpuinfo stores info about your CPU architecture like number of CPUs, threads, cores, information about CPU caches, CPU family, model and much more. So, if you want to detect how many cores are available on a specific machine:</p> <pre><code>$ less /proc/cpuinfo\nprocessor       : 0\nvendor_id       : GenuineIntel\ncpu family      : 6\nmodel           : 23\nmodel name      : Intel(R) Xeon(R) CPU  E5420  @ 2.50GHz\nstepping        : 10\ncpu MHz         : 2500.088\ncache size      : 6144 KB\n...</code></pre> <p>Or if you want to see it in a more readable format, execute:</p> <pre><code>$ grep processor /proc/cpuinfo\nprocessor : 0\nprocessor : 1\nprocessor : 2\nprocessor : 3\nprocessor : 4\nprocessor : 5\nprocessor : 6\nprocessor : 7</code></pre> <p>Remark: Unless you want information of the login nodes, you'll have to issue these commands on one of the workernodes. This is most easily achieved in an interactive job, see the chapter on Running interactive jobs.</p> <p>In order to specify the number of nodes and the number of processors per node in your job script, use:</p> <pre><code>#PBS -l nodes=N:ppn=M</code></pre> <p>or with equivalent parameters on the command line</p> <pre><code>$ qsub -l nodes=N:ppn=M</code></pre> <p>This specifies the number of nodes (nodes=N) and the number of processors per node (ppn=M) that the job should use. PBS treats a processor core as a processor, so a system with eight cores per compute node can have ppn=8 as its maximum ppn request.</p> <p>You can also use this statement in your job script:</p> <pre><code>#PBS -l nodes=N:ppn=all</code></pre> <p>to request all cores of a node, or</p> <pre><code>#PBS -l nodes=N:ppn=half</code></pre> <p>to request half of them.</p> <p>Note that unless a job has some inherent parallelism of its own through something like MPI or OpenMP, requesting more than a single processor on a single node is usually wasteful and can impact the job start time.</p>"}, {"location": "fine_tuning_job_specifications/#monitoring-the-cpu-utilisation", "title": "Monitoring the CPU-utilisation", "text": "<p>This could also be monitored with the htop command:</p> <pre><code>$ htop</code></pre> <pre><code>  1  [|||   11.0%]   5  [||     3.0%]     9  [||     3.0%]   13 [       0.0%]\n  2  [|||||100.0%]   6  [       0.0%]     10 [       0.0%]   14 [       0.0%]\n  3  [||     4.9%]   7  [||     9.1%]     11 [       0.0%]   15 [       0.0%]\n  4  [||     1.8%]   8  [       0.0%]     12 [       0.0%]   16 [       0.0%]\n  Mem[|||||||||||||||||59211/64512MB]     Tasks: 323, 932 thr; 2 running\n  Swp[||||||||||||      7943/20479MB]     Load average: 1.48 1.46 1.27\n                                          Uptime: 211 days(!), 22:12:58\n\n  PID USER      PRI  NI  VIRT   RES   SHR S CPU% MEM%   TIME+  Command\n22350 vsc00000   20   0 1729M 1071M   704 R 98.0  1.7 27:15.59 bwa index\n 7703 root        0 -20 10.1G 1289M 70156 S 11.0  2.0 36h10:11 /usr/lpp/mmfs/bin\n27905 vsc00000   20   0  123M  2800  1556 R  7.0  0.0  0:17.51 htop\n</code></pre> <p>The advantage of htop is that it shows you the cpu utilisation for all processors as well as the details per application. A nice exercise is to start 4 instances of the \"cpu_eat\" program in 4 different terminals, and inspect the cpu utilisation per processor with monitor and htop.</p> <p>If htop reports that your program is taking 75% CPU on a certain processor, it means that 75% of the samples taken by top found your process active on the CPU. The rest of the time your application was in a wait. (It is important to remember that a CPU is a discrete state machine. It really can be at only 100%, executing an instruction, or at 0%, waiting for something to do. There is no such thing as using 45% of a CPU. The CPU percentage is a function of time.) However, it is likely that your application's rest periods include waiting to be dispatched on a CPU and not on external devices. That part of the wait percentage is then very relevant to understanding your overall CPU usage pattern.</p>"}, {"location": "fine_tuning_job_specifications/#fine-tuning-your-executable-andor-job-script", "title": "Fine-tuning your executable and/or job script", "text": "<p>It is good practice to perform a number of run time stress tests, and to check the CPU utilisation of your nodes. We (and all other users of the HPC) would appreciate that you use the maximum of the CPU resources that are assigned to you and make sure that there are no CPUs in your node who are not utilised without reasons.</p> <p>But how can you maximise?</p> <ol> <li>Configure your software. (e.g., to exactly use the available amount     of processors in a node)</li> <li>Develop your parallel program in a smart way.</li> <li>Demand a specific type of compute node (e.g., Harpertown, Westmere),     which have a specific number of cores.</li> <li>Correct your request for CPUs in your job script.</li> </ol>"}, {"location": "fine_tuning_job_specifications/#the-system-load", "title": "The system load", "text": "<p>On top of the CPU utilisation, it is also important to check the system load. The system load is a measure of the amount of computational work that a computer system performs.</p> <p>The system load is the number of applications running or waiting to run on the compute node. In a system with for example four CPUs, a load average of 3.61 would indicate that there were, on average, 3.61 processes ready to run, and each one could be scheduled into a CPU.</p> <p>The load averages differ from CPU percentage in two significant ways:</p> <ol> <li>\"load averages\" measure the trend of processes waiting to be run     (and not only an instantaneous snapshot, as does CPU percentage);     and</li> <li>\"load averages\" include all demand for all resources, e.g., CPU     and also I/O and network (and not only how much was active at the     time of measurement).</li> </ol>"}, {"location": "fine_tuning_job_specifications/#optimal-load", "title": "Optimal load", "text": "<p>What is the \"optimal load\" rule of thumb?</p> <p>The load averages tell us whether our physical CPUs are over- or under-utilised. The point of perfect utilisation, meaning that the CPUs are always busy and, yet, no process ever waits for one, is the average matching the number of CPUs. Your load should not exceed the number of cores available. E.g., if there are four CPUs on a machine and the reported one-minute load average is 4.00, the machine has been utilising its processors perfectly for the last 60 seconds. The \"100% utilisation\" mark is 1.0 on a single-core system, 2.0 on a dual-core, 4.0 on a quad-core, etc. The optimal load shall be between 0.7 and 1.0 per processor.</p> <p>In general, the intuitive idea of load averages is the higher they rise above the number of processors, the more processes are waiting and doing nothing, and the lower they fall below the number of processors, the more untapped CPU capacity there is.</p> <p>Load averages do include any processes or threads waiting on I/O, networking, databases or anything else not demanding the CPU. This means that the optimal number of applications running on a system at the same time, might be more than one per processor.</p> <p>The \"optimal number of applications\" running on one machine at the same time depends on the type of the applications that you are running.</p> <ol> <li>When you are running computational intensive applications, one application per processor will generate     the optimal load.</li> <li>For I/O intensive applications (e.g., applications which perform a lot of disk-I/O), a higher     number of applications can generate the optimal load. While some     applications are reading or writing data on disks, the processors     can serve other applications.</li> </ol> <p>The optimal number of applications on a machine could be empirically calculated by performing a number of stress tests, whilst checking the highest throughput. There is however no manner in the HPC at the moment to specify the maximum number of applications that shall run per core dynamically. The HPC scheduler will not launch more than one process per core.</p> <p>The manner how the cores are spread out over CPUs does not matter for what regards the load. Two quad-cores perform similar to four dual-cores, and again perform similar to eight single-cores. It's all eight cores for these purposes.</p>"}, {"location": "fine_tuning_job_specifications/#monitoring-the-load", "title": "Monitoring the load", "text": "<p>The load average represents the average system load over a period of time. It conventionally appears in the form of three numbers, which represent the system load during the last one-, five-, and fifteen-minute periods.</p> <p>The uptime command will show us the average load</p> <pre><code>$ uptime\n10:14:05 up 86 days, 12:01, 11 users, load average: 0.60, 0.41, 0.41\n</code></pre> <p>Now, start a few instances of the \"eat_cpu\" program in the background, and check the effect on the load again:</p> <pre><code>$ ./eat_cpu&amp;\n$ ./eat_cpu&amp;\n$ ./eat_cpu&amp;\n$ uptime\n10:14:42 up 86 days, 12:02, 11 users, load average: 2.60, 0.93, 0.58\n</code></pre> <p>You can also read it in the htop command.</p>"}, {"location": "fine_tuning_job_specifications/#fine-tuning-your-executable-andor-job-script_1", "title": "Fine-tuning your executable and/or job script", "text": "<p>It is good practice to perform a number of run time stress tests, and to check the system load of your nodes. We (and all other users of the HPC) would appreciate that you use the maximum of the CPU resources that are assigned to you and make sure that there are no CPUs in your node who are not utilised without reasons.</p> <p>But how can you maximise?</p> <ol> <li>Profile your software to improve its performance.</li> <li>Configure your software (e.g., to exactly use the available amount     of processors in a node).</li> <li>Develop your parallel program in a smart way, so that it fully     utilises the available processors.</li> <li>Demand a specific type of compute node (e.g., Harpertown, Westmere),     which have a specific number of cores.</li> <li>Correct your request for CPUs in your job script.</li> </ol> <p>And then check again.</p>"}, {"location": "fine_tuning_job_specifications/#checking-file-sizes-disk-io", "title": "Checking File sizes &amp; Disk I/O", "text": ""}, {"location": "fine_tuning_job_specifications/#monitoring-file-sizes-during-execution", "title": "Monitoring File sizes during execution", "text": "<p>Some programs generate intermediate or output files, the size of which may also be a useful metric.</p> <p>Remember that your available disk space on the HPC online storage is limited, and that you have environment variables which point to these directories available (i.e., $VSC_DATA, $VSC_SCRATCH and $VSC_DATA). On top of those, you can also access some temporary storage (i.e., the /tmp directory) on the compute node, which is defined by the $VSC_SCRATCH_NODE environment variable.</p> <p>It is important to be aware of the sizes of the file that will be generated, as the available disk space for each user is limited. We refer to section  How much disk space do I get? on Quotas to check your quota and tools to find which files consumed the \"quota\".</p> <p>Several actions can be taken, to avoid storage problems:</p> <ol> <li>Be aware of all the files that are generated by your program. Also     check out the hidden files.</li> <li>Check your quota consumption regularly.</li> <li>Clean up your files regularly.</li> <li>First work (i.e., read and write) with your big files in the local     /tmp directory. Once finished, you can move your files once to the     VSC_DATA directories.</li> <li>Make sure your programs clean up their temporary files after     execution.</li> <li>Move your output results to your own computer regularly.</li> <li>Anyone can request more disk space to the HPC staff, but you will have     to duly justify your request.</li> </ol>"}, {"location": "fine_tuning_job_specifications/#specifying-network-requirements", "title": "Specifying network requirements", "text": "<p>Users can examine their network activities with the htop command. When your processors are 100% busy, but you see a lot of red bars and only limited green bars in the htop screen, it is mostly an indication that they lose a lot of time with inter-process communication.</p> <p>Whenever your application utilises a lot of inter-process communication (as is the case in most parallel programs), we strongly recommend to request nodes with an \"InfiniBand\" network. The InfiniBand is a specialised high bandwidth, low latency network that enables large parallel jobs to run as efficiently as possible.</p> <p>The parameter to add in your job script would be:</p> <pre><code>#PBS -l ib</code></pre> <p>If for some other reasons, a user is fine with the gigabit Ethernet network, he can specify:</p> <pre><code>#PBS -l gbe</code></pre>"}, {"location": "gpu/", "title": "GPU clusters", "text": ""}, {"location": "gpu/#submitting-jobs", "title": "Submitting jobs", "text": "<p>To submit jobs to the <code>joltik</code> GPU cluster, where each node provides 4 NVIDIA V100 GPUs (each with 32GB of GPU memory), use:</p> <pre><code>$ module swap cluster/joltik\n</code></pre> <p>To submit to the <code>accelgor</code> GPU cluster, where each node provides 4 NVIDIA A100 GPUs (each with 80GB GPU memory), use:</p> <pre><code>$ module swap cluster/accelgor\n</code></pre> <p>Then use the familiar <code>qsub</code>, <code>qstat</code>, etc.\u00a0commands, taking into account the guidelines outlined in section Requesting (GPU) resources.</p>"}, {"location": "gpu/#interactive-jobs", "title": "Interactive jobs", "text": "<p>To interactively experiment with GPUs, you can submit an interactive job using <code>qsub -I</code> (and request one or more GPUs, see section\u00a0Requesting (GPU) resources).</p> <p>Note that due to a bug in Slurm you will currently not be able to be able to interactively use MPI software that requires access to the GPUs. If you need this, please contact use via hpc@ugent.be.</p>"}, {"location": "gpu/#hardware", "title": "Hardware", "text": "<p>See https://www.ugent.be/hpc/en/infrastructure.</p>"}, {"location": "gpu/#requesting-gpu-resources", "title": "Requesting (GPU) resources", "text": "<p>There are 2 main ways to ask for GPUs as part of a job:</p> <ul> <li> <p>Either as a node property (similar to the number of cores per node     specified via <code>ppn</code>) using <code>-l nodes=X:ppn=Y:gpus=Z</code> (where the     <code>ppn=Y</code> is optional), or as a separate resource request (similar to     the amount of memory) via <code>-l gpus=Z</code>. Both notations give exactly     the same result. The <code>-l gpus=Z</code> is convenient is you only need one     node and you are fine with the default number of cores per GPU. The     <code>-l nodes=...:gpus=Z</code> notation is required if you want to run with     full control or in multinode cases like MPI jobs. If you do not     specify the number of GPUs by just using <code>-l gpus</code>, you get by     default 1 GPU.</p> </li> <li> <p>As a resource of it's own, via <code>--gpus X</code>. In this case however, you     are not guaranteed that the GPUs are on the same node, so your     script or code must be able to deal with this.</p> </li> </ul> <p>Some background:</p> <ul> <li> <p>The GPUs are constrained to the jobs (like the CPU cores), but do     not run in so-called \"exclusive\" mode.</p> </li> <li> <p>The GPUs run with the so-called \"persistence daemon\", so the GPUs is     not re-initialised between jobs.</p> </li> </ul>"}, {"location": "gpu/#attention-points", "title": "Attention points", "text": "<p>Some important attention points:</p> <ul> <li> <p>For MPI jobs, we recommend the (new) wrapper <code>mypmirun</code> from the     <code>vsc-mympirun</code> module (<code>pmi</code> is the background mechanism to start     the MPI tasks, and is different from the usual <code>mpirun</code> that is used     by the <code>mympirun</code> wrapper). At some later point, we might promote     the <code>mypmirun</code> tool or rename it, to avoid the confusion in the     naming).</p> </li> <li> <p>Sharing GPUs requires MPS. The Slurm built-in MPS does not really do     want you want, so we will provide integration with <code>mypmirun</code> and     <code>wurker</code>.</p> </li> <li> <p>For parallel work, we are working on a <code>wurker</code> wrapper from the     <code>vsc-mympirun</code> module that supports GPU placement and MPS, without     any limitations wrt the requested resources (i.e. also support the     case where GPUs are spread heterogenous over nodes from using the     <code>--gpus Z</code> option).</p> </li> <li> <p>Both <code>mypmirun</code> and <code>wurker</code> will try to do the most optimised     placement of cores and tasks, and will provide 1 (optimal) GPU per     task/MPI rank, and set one so-called visible device (i.e.     <code>CUDA_VISIBLE_DEVICES</code> only has 1 ID). The actual devices are not     constrained to the ranks, so you can access all devices requested in     the job. We know that at this moment, this is not working properly, but we are working on this. We advise against trying to fix this yourself.</p> </li> </ul>"}, {"location": "gpu/#software-with-gpu-support", "title": "Software with GPU support", "text": "<p>Use <code>module avail</code> to check for centrally installed software.</p> <p>The subsections below only cover a couple of installed software packages, more are available.</p>"}, {"location": "gpu/#gromacs", "title": "GROMACS", "text": "<p>Please consult <code>module avail GROMACS</code> for a list of installed versions.</p>"}, {"location": "gpu/#horovod", "title": "Horovod", "text": "<p>Horovod can be used for (multi-node) multi-GPU TensorFlow/PyTorch calculations.</p> <p>Please consult <code>module avail Horovod</code> for a list of installed versions.</p> <p>Horovod supports TensorFlow, Keras, PyTorch and MxNet (see https://github.com/horovod/horovod#id9), but should be run as an MPI application with <code>mypmirun</code>. (Horovod also provides it's own wrapper <code>horovodrun</code>, not sure if it handles placement and others correctly).</p> <p>At least for simple TensorFlow benchmarks, it looks like Horovod is a bit faster than usual autodetect multi-GPU TensorFlow without horovod, but it comes at the cost of the code modifications to use horovod.</p>"}, {"location": "gpu/#pytorch", "title": "PyTorch", "text": "<p>Please consult <code>module avail PyTorch</code> for a list of installed versions.</p>"}, {"location": "gpu/#tensorflow", "title": "TensorFlow", "text": "<p>Please consult <code>module avail TensorFlow</code> for a list of installed versions.</p> <p>Note: for running TensorFlow calculations on multiple GPUs and/or on more than one workernode, use <code>Horovod</code>, see section Horovod.</p>"}, {"location": "gpu/#example-tensorflow-job-script", "title": "Example TensorFlow job script", "text": "<p>-- TensorFlow_GPU.sh -- <pre><code>#!/bin/bash\n#PBS -l walltime=5:0:0\n#PBS -l nodes=1:ppn=quarter:gpus=1\n\nmodule load TensorFlow/2.6.0-foss-2021a-CUDA-11.3.1\n\ncd $PBS_O_WORKDIR\npython example.py\n</code></pre></p>"}, {"location": "gpu/#alphafold", "title": "AlphaFold", "text": "<p>Please consult <code>module avail AlphaFold</code> for a list of installed versions.</p> <p>For more information on using AlphaFold, we strongly recommend the VIB-UGent course available at https://elearning.bits.vib.be/courses/alphafold.</p>"}, {"location": "gpu/#getting-help", "title": "Getting help", "text": "<p>In case of questions or problems, please contact the HPC-UGent team via hpc@ugent.be, and clearly indicate that your question relates to the <code>joltik</code> cluster by adding <code>[joltik]</code> in the email subject.</p>"}, {"location": "interactive_debug/", "title": "Interactive and debug cluster", "text": ""}, {"location": "interactive_debug/#purpose", "title": "Purpose", "text": "<p>The purpose of this cluster is to give the user an environment where there should be no waiting in the queue to get access to a limited number of resources. This environment allows a user to immediatelty start working, and is the ideal place for interactive work such as development, debugging and light production workloads (typically sufficient for training and/or courses).</p> <p>This environment should be seen as an extension or even replacement of the login nodes, instead of a dedicated compute resource. The interactive cluster is overcommitted, which means that more CPU cores can be requested for jobs than physically exist in the cluster. Obviously, the performance of this cluster heavily depends on the workloads and the actual overcommit usage. Be aware that jobs can slow down or speed up during their execution.</p> <p>Due to the restrictions and sharing of the CPU resources (see section\u00a0Restrictions and overcommit factor) jobs on this cluster should normally start more or less immediately. The tradeoff is that performance must not be an issue for the submitted jobs. This means that typical workloads for this cluster should be limited to:</p> <ul> <li> <p>Interactive jobs (see     chapter\u00a0Running interactive jobs)</p> </li> <li> <p>Cluster desktop sessions (see     chapter\u00a0Using the HPC-UGent web portal)</p> </li> <li> <p>Jobs requiring few resources</p> </li> <li> <p>Debugging programs</p> </li> <li> <p>Testing and debugging job scripts</p> </li> </ul>"}, {"location": "interactive_debug/#submitting-jobs", "title": "Submitting jobs", "text": "<p>To submit jobs to the HPC-UGent interactive and debug cluster nicknamed <code>donphan</code>, first use:</p> <pre><code>$ module swap cluster/donphan\n</code></pre> <p>Then use the familiar <code>qsub</code>, <code>qstat</code>, etc. commands (see chapter\u00a0Running batch jobs).</p>"}, {"location": "interactive_debug/#restrictions-and-overcommit-factor", "title": "Restrictions and overcommit factor", "text": "<p>Some limits are in place for this cluster:</p> <ul> <li> <p>each user may have at most 5 jobs in the queue (both running and     waiting to run);</p> </li> <li> <p>at most 3 jobs per user can be running at the same time;</p> </li> <li> <p>running jobs may allocate no more than 8 CPU cores and no more than     27200 MiB of memory in total, per user;</p> </li> </ul> <p>In addition, the cluster has an overcommit factor of 6. This means that 6 times more cores can be allocated than physically exist. Simultaneously, the default memory per core is 6 times less than what would be available on a non-overcommitted cluster.</p> <p>Please note that based on the (historical) workload of the interactive and debug cluster, the above restrictions and the overcommitment ratio might change without prior notice.</p>"}, {"location": "interactive_debug/#shared-gpus", "title": "Shared GPUs", "text": "<p>Each node in the <code>donphan</code> cluster has a relatively small GPU that is shared between all jobs. This means that you don't need to reserve it and thus possibly wait for it. But this also has a downside for performance and security: jobs might be competing for the same GPU resources (cores, memory or encoders) without any preset fairshare and there is no guarantee one job cannot access another job's memory (as opposed to having reserved GPUs in the GPU clusters).</p> <p>All software should behave the same as on the dedicated GPU clusters (e.g. using CUDA or OpenGL acceleration from a cluster desktop via the webportal).</p>"}, {"location": "introduction/", "title": "Introduction to HPC", "text": ""}, {"location": "introduction/#what-is-hpc", "title": "What is HPC?", "text": "<p>\"High Performance Computing\" (HPC) is computing on a \"Supercomputer\", a computer with at the frontline of contemporary processing capacity -- particularly speed of calculation and available memory.</p> <p>While the supercomputers in the early days (around 1970) used only a few processors, in the 1990s machines with thousands of processors began to appear and, by the end of the 20th century, massively parallel supercomputers with tens of thousands of \"off-the-shelf\" processors were the norm. A large number of dedicated processors are placed in close proximity to each other in a computer cluster.</p> <p>A computer cluster consists of a set of loosely or tightly connected computers that work together so that in many respects they can be viewed as a single system.</p> <p>The components of a cluster are usually connected to each other through fast local area networks (\"LAN\") with each node (computer used as a server) running its own instance of an operating system. Computer clusters emerged as a result of convergence of a number of computing trends including the availability of low cost microprocessors, high-speed networks, and software for high performance distributed computing.</p> <p>Compute clusters are usually deployed to improve performance and availability over that of a single computer, while typically being more cost-effective than single computers of comparable speed or availability.</p> <p>Supercomputers play an important role in the field of computational science, and are used for a wide range of computationally intensive tasks in various fields, including quantum mechanics, weather forecasting, climate research, oil and gas exploration, molecular modelling (computing the structures and properties of chemical compounds, biological macromolecules, polymers, and crystals), and physical simulations (such as simulations of the early moments of the universe, airplane and spacecraft aerodynamics, the detonation of nuclear weapons, and nuclear fusion). 1</p>"}, {"location": "introduction/#what-is-the-hpc-ugent-infrastructure", "title": "What is the HPC-UGent infrastructure?", "text": "<p>The HPC is a collection of computers with AMD and/or Intel CPUs, running a Linux operating system, shaped like pizza boxes and stored above and next to each other in racks, interconnected with copper and fiber cables. Their number crunching power is (presently) measured in hundreds of billions of floating point operations (gigaflops) and even in teraflops.</p> <p> </p> <p>The HPC-UGent infrastructure relies on parallel-processing technology to offer UGent researchers an extremely fast solution for all their data processing needs.</p> <p>The HPC currently consists of:</p> <p>a set of different compute clusters. For an up to date list of all clusters and their hardware, see https://vscdocumentation.readthedocs.io/en/latest/gent/tier2_hardware.html.</p> <p>Job management and job scheduling are performed by Slurm with a Torque frontend. We advise users to adhere to Torque commands mentioned in this document.</p>"}, {"location": "introduction/#what-the-hpc-infrastucture-is-not", "title": "What the HPC infrastucture is not", "text": "<p>The HPC infrastructure is not a magic computer that automatically:</p> <ol> <li> <p>runs your PC-applications much faster for bigger problems;</p> </li> <li> <p>develops your applications;</p> </li> <li> <p>solves your bugs;</p> </li> <li> <p>does your thinking;</p> </li> <li> <p>...</p> </li> <li> <p>allows you to play games even faster.</p> </li> </ol> <p>The HPC does not replace your desktop computer.</p>"}, {"location": "introduction/#is-the-hpc-a-solution-for-my-computational-needs", "title": "Is the HPC a solution for my computational needs?", "text": ""}, {"location": "introduction/#batch-or-interactive-mode", "title": "Batch or interactive mode?", "text": "<p>Typically, the strength of a supercomputer comes from its ability to run a huge number of programs (i.e., executables) in parallel without any user interaction in real time. This is what is called \"running in batch mode\".</p> <p>It is also possible to run programs at the HPC, which require user interaction. (pushing buttons, entering input data, etc.). Although technically possible, the use of the HPC might not always be the best and smartest option to run those interactive programs. Each time some user interaction is needed, the computer will wait for user input. The available computer resources (CPU, storage, network, etc.) might not be optimally used in those cases. A more in-depth analysis with the HPC staff can unveil whether the HPC is the desired solution to run interactive programs. Interactive mode is typically only useful for creating quick visualisations of your data without having to copy your data to your desktop and back.</p>"}, {"location": "introduction/#what-are-cores-processors-and-nodes", "title": "What are cores, processors and nodes?", "text": "<p>In this manual, the terms core, processor and node will be frequently used, so it's useful to understand what they are.</p> <p>Modern servers, also referred to as (worker)nodes in the context of HPC, include one or more sockets, each housing a multi-core processor (next to memory, disk(s), network cards, ...). A modern processor consists of multiple CPUs or cores that are used to execute computations.</p>"}, {"location": "introduction/#parallel-or-sequential-programs", "title": "Parallel or sequential programs?", "text": ""}, {"location": "introduction/#parallel-programs", "title": "Parallel programs", "text": "<p>Parallel computing is a form of computation in which many calculations are carried out simultaneously. They are based on the principle that large problems can often be divided into smaller ones, which are then solved concurrently (\"in parallel\").</p> <p>Parallel computers can be roughly classified according to the level at which the hardware supports parallelism, with multicore computers having multiple processing elements within a single machine, while clusters use multiple computers to work on the same task. Parallel computing has become the dominant computer architecture, mainly in the form of multicore processors.</p> <p>The two parallel programming paradigms most used in HPC are:</p> <ul> <li> <p>OpenMP for shared memory systems (multithreading): on multiple cores     of a single node</p> </li> <li> <p>MPI for distributed memory systems (multiprocessing): on multiple     nodes</p> </li> </ul> <p>Parallel programs are more difficult to write than sequential ones, because concurrency introduces several new classes of potential software bugs, of which race conditions are the most common. Communication and synchronisation between the different subtasks are typically some of the greatest obstacles to getting good parallel program performance.</p>"}, {"location": "introduction/#sequential-programs", "title": "Sequential programs", "text": "<p>Sequential software does not do calculations in parallel, i.e., it only uses one single core of a single workernode. It does not become faster by just throwing more cores at it: it can only use one core.</p> <p>It is perfectly possible to also run purely sequential programs on the HPC.</p> <p>Running your sequential programs on the most modern and fastest computers in the HPC can save you a lot of time. But it also might be possible to run multiple instances of your program (e.g., with different input parameters) on the HPC, in order to solve one overall problem (e.g., to perform a parameter sweep). This is another form of running your sequential programs in parallel.</p>"}, {"location": "introduction/#what-programming-languages-can-i-use", "title": "What programming languages can I use?", "text": "<p>You can use any programming language, any software package and any library provided it has a version that runs on Linux, specifically, on the version of Linux that is installed on the compute nodes, RHEL 8.6 (doduo, accelgor, joltik, skitty, victini, swalot, gallade, donphan).</p> <p>For the most common programming languages, a compiler is available on RHEL 8.6 (doduo, accelgor, joltik, skitty, victini, swalot, gallade, donphan). Supported and common programming languages on the HPC are C/C++, FORTRAN, Java, Perl, Python, MATLAB, R, etc.</p> <p>Supported and commonly used compilers are GCC and Intel.</p> <p>Additional software can be installed \"on demand\". Please contact the HPC staff to see whether the HPC can handle your specific requirements.</p>"}, {"location": "introduction/#what-operating-systems-can-i-use", "title": "What operating systems can I use?", "text": "<p>All nodes in the HPC cluster run under RHEL 8.6 (doduo, accelgor, joltik, skitty, victini, swalot, gallade, donphan), which is a specific version of Red Hat Enterprise Linux. This means that all programs (executables) should be compiled for RHEL 8.6 (doduo, accelgor, joltik, skitty, victini, swalot, gallade, donphan).</p> <p>Users can connect from any computer in the UGent network to the HPC, regardless of the Operating System that they are using on their personal computer. Users can use any of the common Operating Systems (such as Windows, macOS or any version of Linux/Unix/BSD) and run and control their programs on the HPC.</p> <p>A user does not need to have prior knowledge about Linux; all of the required knowledge is explained in this tutorial.</p>"}, {"location": "introduction/#what-does-a-typical-workflow-look-like", "title": "What does a typical workflow look like?", "text": "<p>A typical workflow looks like:</p> <ol> <li> <p>Connect to the login nodes with SSH (see First Time connection to the HPC infrastructure)</p> </li> <li> <p>Transfer your files to the cluster (see Transfer Files to/from the HPC)</p> </li> <li> <p>Optional: compile your code and test it (for compiling, see Compiling and testing your software on the HPC)</p> </li> <li> <p>Create a job script and submit your job (see Running batch jobs)</p> </li> <li> <p>Get some coffee and be patient:</p> <ol> <li> <p>Your job gets into the queue</p> </li> <li> <p>Your job gets executed</p> </li> <li> <p>Your job finishes</p> </li> </ol> </li> <li> <p>Study the results generated by your jobs, either on the cluster or     after downloading them locally.</p> </li> </ol>"}, {"location": "introduction/#what-is-the-next-step", "title": "What is the next step?", "text": "<p>When you think that the HPC is a useful tool to support your computational needs, we encourage you to acquire a VSC-account (as explained in Getting a HPC Account), read Connecting to the HPC infrastructure, \"Setting up the environment\", and explore chapters\u00a0Running interactive jobs to\u00a0Fine-tuning Job Specifications which will help you to transfer and run your programs on the HPC cluster.</p> <p>Do not hesitate to contact the HPC staff for any help.</p> <ol> <li> <p>Wikipedia: http://en.wikipedia.org/wiki/Supercomputer \u21a9</p> </li> </ol>"}, {"location": "jobscript_examples/", "title": "Job script examples", "text": ""}, {"location": "jobscript_examples/#simple-job-script-template", "title": "Simple job script template", "text": "<p>This is a template for a job script, with commonly used parameters. The basic parameters should always be used. Some notes on the situational parameters:</p> <ul> <li> <p><code>-l mem</code>: If no memory parameter is given, the job gets access to an amount of     memory proportional to the amount of cores requested.     See also: Job failed: SEGV Segmentation fault</p> </li> <li> <p><code>-m/-M</code>: the <code>-m</code> option will send emails to your email address registerd with VSC.     Only if you want emails at some other address, you should use the <code>-M</code> option.</p> </li> <li> <p>Replace the \"<code>-placeholder text-</code>\" with real entries.     This notation is used to ensure <code>qsub</code> rejects invalid options.</p> </li> <li> <p>To use a situational parameter, remove one '<code>#</code>' at the beginning of the line.</p> </li> </ul> <p>simple_jobscript.sh</p> <pre><code>#!/bin/bash\n\n# Basic parameters\n#PBS -N jobname           ## Job name\n#PBS -l nodes=1:ppn=2     ## 1 node, 2 processors per node (ppn=all to get a full node)\n#PBS -l walltime=01:00:00 ## Max time your job will run (no more than 72:00:00)\n\n# Situational parameters: remove one '#' at the front to use\n##PBS -l gpus=1            ## GPU amount (only on accelgor or joltik)\n##PBS -l mem=32gb          ## If not used, memory will be available proportional to the max amount\n##PBS -m abe               ## Email notifications (abe=aborted, begin and end)\n##PBS -M -email_address-   ## ONLY if you want to use a different email than your VSC address\n##PBS -A -project-         ## Project name when credits are required (only Tier 1)\n\n##PBS -o -filename-        ## Output log\n##PBS -e -filename-        ## Error log\n\n\nmodule load [module]\nmodule load [module]\n\ncd $PBS_O_WORKDIR         # Change working directory to the location where the job was submmitted\n\n[commands]\n</code></pre>"}, {"location": "jobscript_examples/#single-core-job", "title": "Single-core job", "text": "<p>Here's an example of a single-core job script:</p> <p>single_core.sh</p> <pre><code>#!/bin/bash\n#PBS -N count_example         ## job name\n#PBS -l nodes=1:ppn=1         ## single-node job, single core\n#PBS -l walltime=2:00:00      ## max. 2h of wall time\nmodule load Python/3.6.4-intel-2018a\n# copy input data from location where job was submitted from\ncp $PBS_O_WORKDIR/input.txt $TMPDIR\n# go to temporary working directory (on local disk) &amp; run\ncd $TMPDIR\npython -c \"print(len(open('input.txt').read()))\" &gt; output.txt\n# copy back output data, ensure unique filename using $PBS_JOBID\ncp output.txt $VSC_DATA/output_${PBS_JOBID}.txt\n</code></pre> <ol> <li> <p>Using <code>#PBS</code> header lines, we specify the resource requirements for     the job, see Apendix B for a list of these options.</p> </li> <li> <p>A module for <code>Python 3.6</code> is loaded, see also section Modules.</p> </li> <li> <p>We stage the data in: the file <code>input.txt</code> is copied into the     \"working\" directory, see chapter Running jobs with input/output data.</p> </li> <li> <p>The main part of the script runs a small Python program that counts     the number of characters in the provided input file <code>input.txt</code>.</p> </li> <li> <p>We stage the results out: the output file <code>output.txt</code> is copied     from the \"working directory\" (<code>$TMPDIR</code>|) to a unique directory in     <code>$VSC_DATA</code>. For a list of possible storage locations, see subsection  Pre-defined user directories.</p> </li> </ol>"}, {"location": "jobscript_examples/#multi-core-job", "title": "Multi-core job", "text": "<p>Here's an example of a multi-core job script that uses <code>mympirun</code>:</p> <p>multi_core.sh</p> <pre><code>#!/bin/bash\n#PBS -N mpi_hello             ## job name\n#PBS -l nodes=2:ppn=all       ## 2 nodes, all cores per node\n#PBS -l walltime=2:00:00      ## max. 2h of wall time\nmodule load intel/2017b\nmodule load vsc-mympirun      ## We don't use a version here, this is on purpose\n# go to working directory, compile and run MPI hello world\ncd $PBS_O_WORKDIR\nmpicc mpi_hello.c -o mpi_hello\nmympirun ./mpi_hello\n</code></pre> <p>An example MPI hello world program can be downloaded from https://github.com/hpcugent/vsc-mympirun/blob/master/testscripts/mpi_helloworld.c.</p>"}, {"location": "jobscript_examples/#running-a-command-with-a-maximum-time-limit", "title": "Running a command with a maximum time limit", "text": "<p>If you want to run a job, but you are not sure it will finish before the job runs out of walltime and you want to copy data back before, you have to stop the main command before the walltime runs out and copy the data back.</p> <p>This can be done with the <code>timeout</code> command. This command sets a limit of time a program can run for, and when this limit is exceeded, it kills the program. Here's an example job script using <code>timeout</code>:</p> <p>timeout.sh</p> <pre><code>#!/bin/bash\n#PBS -N timeout_example\n#PBS -l nodes=1:ppn=1        ## single-node job, single core\n#PBS -l walltime=2:00:00     ## max. 2h of wall time\n\n# go to temporary working directory (on local disk)\ncd $TMPDIR\n# This command will take too long (1400 minutes is longer than our walltime)\n# $PBS_O_WORKDIR/example_program.sh 1400 output.txt\n\n# So we put it after a timeout command\n# We have a total of 120 minutes (2 x 60) and we instruct the script to run for\n# 100 minutes, but timeout after 90 minute,\n# so we have 30 minutes left to copy files back. This should\n#  be more than enough.\ntimeout -s SIGKILL 90m $PBS_O_WORKDIR/example_program.sh 100 output.txt\n# copy back output data, ensure unique filename using $PBS_JOBID\ncp output.txt $VSC_DATA/output_${PBS_JOBID}.txt\n</code></pre> <p>The example program used in this script is a dummy script that simply sleeps a specified amount of minutes:</p> <p>example_program.sh</p> <pre><code>#!/bin/bash\n# This is an example program\n# It takes two arguments: a number of times to loop and a file to write to\n# In total, it will run for (the number of times to loop) minutes\n\nif [ $# -ne 2 ]; then\necho \"Usage: ./example_program amount filename\" &amp;&amp; exit 1\nfi\n\nfor ((i = 0; i &lt; $1; i++ )); do\necho \"${i} =&gt; $(date)\" &gt;&gt; $2\nsleep 60\ndone\n</code></pre>"}, {"location": "multi_core_jobs/", "title": "Multi core jobs/Parallel Computing", "text": ""}, {"location": "multi_core_jobs/#why-parallel-programming", "title": "Why Parallel Programming?", "text": "<p>There are two important motivations to engage in parallel programming.</p> <ol> <li> <p>Firstly, the need to decrease the time to solution: distributing     your code over C cores holds the promise of speeding up execution     times by a factor C. All modern computers (and probably even your     smartphone) are equipped with multi-core processors capable of     parallel processing.</p> </li> <li> <p>The second reason is problem size: distributing your code over N     nodes increases the available memory by a factor N, and thus holds     the promise of being able to tackle problems which are N times     bigger.</p> </li> </ol> <p>On a desktop computer, this enables a user to run multiple programs and the operating system simultaneously. For scientific computing, this means you have the ability in principle of splitting up your computations into groups and running each group on its own core.</p> <p>There are multiple different ways to achieve parallel programming. The table below gives a (non-exhaustive) overview of problem independent approaches to parallel programming. In addition there are many problem specific libraries that incorporate parallel capabilities. The next three sections explore some common approaches: (raw) threads, OpenMP and MPI.</p> Parallel programming approaches Tool Available languages binding Limitations              Raw threads pthreads, boost:: threading, ...                       Threading libraries are available for all common programming languages                       Threading libraries are available for all common programming languages &amp; Threads are limited to shared memory systems. They are more often used on single node systems rather than for HPC. Thread management is hard.                       OpenMP                       Fortran/C/C++                       Limited to shared memory systems, but large shared memory systems for HPC are not uncommon (e.g., SGI UV). Loops and task can be parallelised by simple insertion of compiler directives. Under the hood threads are used. Hybrid approaches exist which use OpenMP to parallelise the work load on each node and MPI (see below) for communication between nodes.                       Lightweight threads with clever scheduling, Intel TBB, Intel Cilk Plus                       C/C++                       Limited to shared memory systems, but may be combined with MPI. Thread management is taken care of by a very clever scheduler enabling the programmer to focus on parallelisation itself. Hybrid approaches exist which use TBB and/or Cilk Plus to parallelise the work load on each node and MPI (see below) for communication between nodes.                       MPI                       Fortran/C/C++, Python                       Applies to both distributed and shared memory systems. Cooperation between different nodes or cores is managed by explicit calls to library routines handling communication routines.                       Global Arrays library                        C/C++, Python                       Mimics a global address space on distributed memory systems, by distributing arrays over many nodes and one sided communication. This library is used a lot for chemical structure calculation codes and was used in one of the first applications that broke the PetaFlop barrier.                       scoop                       Python                       Applies to both shared and distributed memory system. Not extremely advanced, but may present a quick road to parallelisation of Python code."}, {"location": "multi_core_jobs/#parallel-computing-with-threads", "title": "Parallel Computing with threads", "text": "<p>Multi-threading is a widespread programming and execution model that allows multiple threads to exist within the context of a single process. These threads share the process' resources, but are able to execute independently. The threaded programming model provides developers with a useful abstraction of concurrent execution. Multi-threading can also be applied to a single process to enable parallel execution on a multiprocessing system.</p> <p></p> <p>This advantage of a multithreaded program allows it to operate faster on computer systems that have multiple CPUs or across a cluster of machines --- because the threads of the program naturally lend themselves to truly concurrent execution. In such a case, the programmer needs to be careful to avoid race conditions, and other non-intuitive behaviours. In order for data to be correctly manipulated, threads will often need to synchronise in time in order to process the data in the correct order. Threads may also require mutually exclusive operations (often implemented using semaphores) in order to prevent common data from being simultaneously modified, or read while in the process of being modified. Careless use of such primitives can lead to deadlocks.</p> <p>Threads are a way that a program can spawn concurrent units of processing that can then be delegated by the operating system to multiple processing cores. Clearly the advantage of a multithreaded program (one that uses multiple threads that are assigned to multiple processing cores) is that you can achieve big speedups, as all cores of your CPU (and all CPUs if you have more than one) are used at the same time.</p> <p>Here is a simple example program that spawns 5 threads, where each one runs a simple function that only prints \"Hello from thread\".</p> <p>Go to the example directory:</p> <pre><code>$ cd ~/examples/Multi_core_jobs_Parallel_Computing\n</code></pre> <p>Study the example first:</p> -- T_hello.c -- <pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: Showcase of working with threads\n */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;pthread.h&gt;\n\n#define NTHREADS 5\n\nvoid *myFun(void *x)\n{\nint tid;\ntid = *((int *) x);\nprintf(\"Hello from thread %d!\\n\", tid);\nreturn NULL;\n}\n\nint main(int argc, char *argv[])\n{\npthread_t threads[NTHREADS];\nint thread_args[NTHREADS];\nint rc, i;\n\n/* spawn the threads */\nfor (i=0; i&lt;NTHREADS; ++i)\n{\nthread_args[i] = i;\nprintf(\"spawning thread %d\\n\", i);\nrc = pthread_create(&amp;threads[i], NULL, myFun, (void *) &amp;thread_args[i]);\n}\n\n/* wait for threads to finish */\nfor (i=0; i&lt;NTHREADS; ++i) {\nrc = pthread_join(threads[i], NULL);\n}\n\nreturn 1;\n}\n</code></pre> <p>And compile it (whilst including the thread library) and run and test it on the login-node:</p> <pre><code>$ module load GCC\n$ gcc -o T_hello T_hello.c -lpthread\n$ ./T_hello\nspawning thread 0\nspawning thread 1\nspawning thread 2\nHello from thread 0!\nHello from thread 1!\nHello from thread 2!\nspawning thread 3\nspawning thread 4\nHello from thread 3!\nHello from thread 4!\n</code></pre> <p>Now, run it on the cluster and check the output:</p> <pre><code>$ qsub T_hello.pbs\n123456\n$ more T_hello.pbs.o123456\nspawning thread 0\nspawning thread 1\nspawning thread 2\nHello from thread 0!\nHello from thread 1!\nHello from thread 2!\nspawning thread 3\nspawning thread 4\nHello from thread 3!\nHello from thread 4!\n</code></pre> <p>Tip</p> <p>If you plan engaging in parallel programming using threads, this book may prove useful: Professional Multicore Programming: Design and Implementation for C++ Developers. Cameron Hughes and Tracey Hughes. Wrox 2008.</p>"}, {"location": "multi_core_jobs/#parallel-computing-with-openmp", "title": "Parallel Computing with OpenMP", "text": "<p>OpenMP is an API that implements a multi-threaded, shared memory form of parallelism. It uses a set of compiler directives (statements that you add to your code and that are recognised by your Fortran/C/C++ compiler if OpenMP is enabled or otherwise ignored) that are incorporated at compile-time to generate a multi-threaded version of your code. You can think of Pthreads (above) as doing multi-threaded programming \"by hand\", and OpenMP as a slightly more automated, higher-level API to make your program multithreaded. OpenMP takes care of many of the low-level details that you would normally have to implement yourself, if you were using Pthreads from the ground up.</p> <p>An important advantage of OpenMP is that, because it uses compiler directives, the original serial version stays intact, and minimal changes (in the form of compiler directives) are necessary to turn a working serial code into a working parallel code.</p> <p>Here is the general code structure of an OpenMP program: <pre><code>#include &lt;omp.h&gt;\nmain ()  {\nint var1, var2, var3;\n// Serial code\n// Beginning of parallel section. Fork a team of threads.\n// Specify variable scoping\n\n#pragma omp parallel private(var1, var2) shared(var3)\n{\n// Parallel section executed by all threads\n// All threads join master thread and disband\n}\n// Resume serial code\n}\n</code></pre></p>"}, {"location": "multi_core_jobs/#private-versus-shared-variables", "title": "Private versus Shared variables", "text": "<p>By using the private() and shared() clauses, you can specify variables within the parallel region as being shared, i.e., visible and accessible by all threads simultaneously, or private, i.e., private to each thread, meaning each thread will have its own local copy. In the code example below for parallelising a for loop, you can see that we specify the thread_id and nloops variables as private.</p>"}, {"location": "multi_core_jobs/#parallelising-for-loops-with-openmp", "title": "Parallelising for loops with OpenMP", "text": "<p>Parallelising for loops is really simple (see code below). By default, loop iteration counters in OpenMP loop constructs (in this case the i variable) in the for loop are set to private variables.</p> <p>-- omp1.c --</p> <pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: Showcase program for OMP loops\n */\n/* OpenMP_loop.c  */\n#include &lt;stdio.h&gt;\n#include &lt;omp.h&gt;\n\nint main(int argc, char **argv)\n{\nint i, thread_id, nloops;\n\n#pragma omp parallel private(thread_id, nloops)\n{\nnloops = 0;\n\n#pragma omp for\nfor (i=0; i&lt;1000; ++i)\n{\n++nloops;\n}\nthread_id = omp_get_thread_num();\nprintf(\"Thread %d performed %d iterations of the loop.\\n\", thread_id, nloops );\n}\n\nreturn 0;\n}\n</code></pre> <p>And compile it (whilst including the \"openmp\" library) and run and test it on the login-node:</p> <pre><code>$ module load GCC\n$ gcc -fopenmp -o omp1 omp1.c\n$ ./omp1\nThread 6 performed 125 iterations of the loop.\nThread 7 performed 125 iterations of the loop.\nThread 5 performed 125 iterations of the loop.\nThread 4 performed 125 iterations of the loop.\nThread 0 performed 125 iterations of the loop.\nThread 2 performed 125 iterations of the loop.\nThread 3 performed 125 iterations of the loop.\nThread 1 performed 125 iterations of the loop.\n</code></pre> <p>Now run it in the cluster and check the result again.</p> <pre><code>$ qsub omp1.pbs\n$ cat omp1.pbs.o*\nThread 1 performed 125 iterations of the loop.\nThread 4 performed 125 iterations of the loop.\nThread 3 performed 125 iterations of the loop.\nThread 0 performed 125 iterations of the loop.\nThread 5 performed 125 iterations of the loop.\nThread 7 performed 125 iterations of the loop.\nThread 2 performed 125 iterations of the loop.\nThread 6 performed 125 iterations of the loop.\n</code></pre>"}, {"location": "multi_core_jobs/#critical-code", "title": "Critical Code", "text": "<p>Using OpenMP you can specify something called a \"critical\" section of code. This is code that is performed by all threads, but is only performed one thread at a time (i.e., in serial). This provides a convenient way of letting you do things like updating a global variable with local results from each thread, and you don't have to worry about things like other threads writing to that global variable at the same time (a collision).</p> <p>-- omp2.c --</p> <pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: OpenMP Test Program\n */\n#include &lt;stdio.h&gt;\n#include &lt;omp.h&gt;\n\nint main(int argc, char *argv[])\n{\nint i, thread_id;\nint glob_nloops, priv_nloops;\nglob_nloops = 0;\n\n// parallelize this chunk of code\n#pragma omp parallel private(priv_nloops, thread_id)\n{\npriv_nloops = 0;\nthread_id = omp_get_thread_num();\n\n// parallelize this for loop\n#pragma omp for\nfor (i=0; i&lt;100000; ++i)\n{\n++priv_nloops;\n}\n\n// make this a \"critical\" code section\n#pragma omp critical\n{\nprintf(\"Thread %d is adding its iterations (%d) to sum (%d), \", thread_id, priv_nloops, glob_nloops);\nglob_nloops += priv_nloops;\nprintf(\"total is now %d.\\n\", glob_nloops);\n}\n}\nprintf(\"Total # loop iterations is %d\\n\", glob_nloops);\nreturn 0;\n}\n</code></pre> <p>And compile it (whilst including the \"openmp\" library) and run and test it on the login-node:</p> <pre><code>$ module load GCC\n$ gcc -fopenmp -o omp2 omp2.c\n$ ./omp2\nThread 3 is adding its iterations (12500) to sum (0), total is now 12500.\nThread 7 is adding its iterations (12500) to sum (12500), total is now 25000.\nThread 5 is adding its iterations (12500) to sum (25000), total is now 37500.\nThread 6 is adding its iterations (12500) to sum (37500), total is now 50000.\nThread 2 is adding its iterations (12500) to sum (50000), total is now 62500.\nThread 4 is adding its iterations (12500) to sum (62500), total is now 75000.\nThread 1 is adding its iterations (12500) to sum (75000), total is now 87500.\nThread 0 is adding its iterations (12500) to sum (87500), total is now 100000.\nTotal # loop iterations is 100000\n</code></pre> <p>Now run it in the cluster and check the result again.</p> <pre><code>$ qsub omp2.pbs\n$ cat omp2.pbs.o*\nThread 2 is adding its iterations (12500) to sum (0), total is now 12500.\nThread 0 is adding its iterations (12500) to sum (12500), total is now 25000.\nThread 1 is adding its iterations (12500) to sum (25000), total is now 37500.\nThread 4 is adding its iterations (12500) to sum (37500), total is now 50000.\nThread 7 is adding its iterations (12500) to sum (50000), total is now 62500.\nThread 3 is adding its iterations (12500) to sum (62500), total is now 75000.\nThread 5 is adding its iterations (12500) to sum (75000), total is now 87500.\nThread 6 is adding its iterations (12500) to sum (87500), total is now 100000.\nTotal # loop iterations is 100000\n</code></pre>"}, {"location": "multi_core_jobs/#reduction", "title": "Reduction", "text": "<p>Reduction refers to the process of combining the results of several sub-calculations into a final result. This is a very common paradigm (and indeed the so-called \"map-reduce\" framework used by Google and others is very popular). Indeed we used this paradigm in the code example above, where we used the \"critical code\" directive to accomplish this. The map-reduce paradigm is so common that OpenMP has a specific directive that allows you to more easily implement this.</p> -- omp3.c -- <pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: OpenMP Test Program\n */\n#include &lt;stdio.h&gt;\n#include &lt;omp.h&gt;\n\nint main(int argc, char *argv[])\n{\nint i, thread_id;\nint glob_nloops, priv_nloops;\nglob_nloops = 0;\n\n// parallelize this chunk of code\n#pragma omp parallel private(priv_nloops, thread_id) reduction(+:glob_nloops)\n{\npriv_nloops = 0;\nthread_id = omp_get_thread_num();\n\n// parallelize this for loop\n#pragma omp for\nfor (i=0; i&lt;100000; ++i)\n{\n++priv_nloops;\n}\nglob_nloops += priv_nloops;\n}\nprintf(\"Total # loop iterations is %d\\n\", glob_nloops);\nreturn 0;\n}\n</code></pre> <p>And compile it (whilst including the \"openmp\" library) and run and test it on the login-node:</p> <pre><code>$ module load GCC\n$ gcc -fopenmp -o omp3 omp3.c\n$ ./omp3\nTotal # loop iterations is 100000\n</code></pre> <p>Now run it in the cluster and check the result again.</p> <pre><code>$ qsub omp3.pbs\n$ cat omp3.pbs.o*\nTotal # loop iterations is 100000\n</code></pre>"}, {"location": "multi_core_jobs/#other-openmp-directives", "title": "Other OpenMP directives", "text": "<p>There are a host of other directives you can issue using OpenMP.</p> <p>Some other clauses of interest are:</p> <ol> <li> <p>barrier: each thread will wait until all threads have reached this     point in the code, before proceeding</p> </li> <li> <p>nowait: threads will not wait until everybody is finished</p> </li> <li> <p>schedule(type, chunk) allows you to specify how tasks are spawned     out to threads in a for loop. There are three types of scheduling     you can specify</p> </li> <li> <p>if: allows you to parallelise only if a certain condition is met</p> </li> <li> <p>...\u00a0and a host of others</p> </li> </ol> <p>Tip</p> <p>If you plan engaging in parallel programming using OpenMP, this book may prove useful: Using OpenMP - Portable Shared Memory Parallel Programming. By Barbara Chapman Gabriele Jost and Ruud van der Pas Scientific and Engineering Computation. 2005.</p>"}, {"location": "multi_core_jobs/#parallel-computing-with-mpi", "title": "Parallel Computing with MPI", "text": "<p>The Message Passing Interface (MPI) is a standard defining core syntax and semantics of library routines that can be used to implement parallel programming in C (and in other languages as well). There are several implementations of MPI such as Open MPI, Intel MPI, M(VA)PICH and LAM/MPI.</p> <p>In the context of this tutorial, you can think of MPI, in terms of its complexity, scope and control, as sitting in between programming with Pthreads, and using a high-level API such as OpenMP. For a Message Passing Interface (MPI) application, a parallel task usually consists of a single executable running concurrently on multiple processors, with communication between the processes. This is shown in the following diagram:</p> <p></p> <p>The process numbers 0, 1 and 2 represent the process rank and have greater or less significance depending on the processing paradigm. At the minimum, Process 0 handles the input/output and determines what other processes are running.</p> <p>The MPI interface allows you to manage allocation, communication, and synchronisation of a set of processes that are mapped onto multiple nodes, where each node can be a core within a single CPU, or CPUs within a single machine, or even across multiple machines (as long as they are networked together).</p> <p>One context where MPI shines in particular is the ability to easily take advantage not just of multiple cores on a single machine, but to run programs on clusters of several machines. Even if you don't have a dedicated cluster, you could still write a program using MPI that could run your program in parallel, across any collection of computers, as long as they are networked together.</p> <p>Here is a \"Hello World\" program in MPI written in C. In this example, we send a \"Hello\" message to each processor, manipulate it trivially, return the results to the main process, and print the messages.</p> <p>Study the MPI-programme and the PBS-file:</p> -- mpi_hello.c -- <pre><code>/*\n * VSC        : Flemish Supercomputing Centre\n * Tutorial   : Introduction to HPC\n * Description: \"Hello World\" MPI Test Program\n */\n#include &lt;stdio.h&gt;\n#include &lt;mpi.h&gt;\n\n#include &lt;mpi.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define BUFSIZE 128\n#define TAG 0\n\nint main(int argc, char *argv[])\n{\nchar idstr[32];\nchar buff[BUFSIZE];\nint numprocs;\nint myid;\nint i;\nMPI_Status stat;\n/* MPI programs start with MPI_Init; all 'N' processes exist thereafter */\nMPI_Init(&amp;argc,&amp;argv);\n/* find out how big the SPMD world is */\nMPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs);\n/* and this processes' rank is */\nMPI_Comm_rank(MPI_COMM_WORLD,&amp;myid);\n\n/* At this point, all programs are running equivalently, the rank\n      distinguishes the roles of the programs in the SPMD model, with\n      rank 0 often used specially... */\nif(myid == 0)\n{\nprintf(\"%d: We have %d processors\\n\", myid, numprocs);\nfor(i=1;i&lt;numprocs;i++)\n{\nsprintf(buff, \"Hello %d! \", i);\nMPI_Send(buff, BUFSIZE, MPI_CHAR, i, TAG, MPI_COMM_WORLD);\n}\nfor(i=1;i&lt;numprocs;i++)\n{\nMPI_Recv(buff, BUFSIZE, MPI_CHAR, i, TAG, MPI_COMM_WORLD, &amp;stat);\nprintf(\"%d: %s\\n\", myid, buff);\n}\n}\nelse\n{\n/* receive from rank 0: */\nMPI_Recv(buff, BUFSIZE, MPI_CHAR, 0, TAG, MPI_COMM_WORLD, &amp;stat);\nsprintf(idstr, \"Processor %d \", myid);\nstrncat(buff, idstr, BUFSIZE-1);\nstrncat(buff, \"reporting for duty\", BUFSIZE-1);\n/* send to rank 0: */\nMPI_Send(buff, BUFSIZE, MPI_CHAR, 0, TAG, MPI_COMM_WORLD);\n}\n\n/* MPI programs end with MPI Finalize; this is a weak synchronization point */\nMPI_Finalize();\nreturn 0;\n}\n</code></pre> -- mpi_hello.pbs -- <pre><code>#!/bin/bash\n\n#PBS -N mpihello\n#PBS -l walltime=00:05:00\n\n# assume a 40 core job\n#PBS -l nodes=2:ppn=20\n\n# make sure we are in the right directory in case writing files\ncd $PBS_O_WORKDIR\n\n# load the environment\n\nmodule load intel\n\nmpirun ./mpi_hello\n</code></pre> <p>and compile it:</p> <pre><code>$ module load intel\n$ mpiicc -o mpi_hello mpi_hello.c\n</code></pre> <p>mpiicc is a wrapper of the Intel C++ compiler icc to compile MPI programs (see the chapter on compilation for details).</p> <p>Run the parallel program:</p> <pre><code>$ qsub mpi_hello.pbs\n$ ls -l\ntotal 1024\n-rwxrwxr-x 1 vsc40000 8746 Sep 16 14:19 mpi_hello*\n-rw-r--r-- 1 vsc40000 1626 Sep 16 14:18 mpi_hello.c\n-rw------- 1 vsc40000    0 Sep 16 14:22 mpi_hello.o123456\n-rw------- 1 vsc40000  697 Sep 16 14:22 mpi_hello.o123456\n-rw-r--r-- 1 vsc40000  304 Sep 16 14:22 mpi_hello.pbs\n$ cat mpi_hello.o123456\n0: We have 16 processors\n0: Hello 1! Processor 1 reporting for duty\n0: Hello 2! Processor 2 reporting for duty\n0: Hello 3! Processor 3 reporting for duty\n0: Hello 4! Processor 4 reporting for duty\n0: Hello 5! Processor 5 reporting for duty\n0: Hello 6! Processor 6 reporting for duty\n0: Hello 7! Processor 7 reporting for duty\n0: Hello 8! Processor 8 reporting for duty\n0: Hello 9! Processor 9 reporting for duty\n0: Hello 10! Processor 10 reporting for duty\n0: Hello 11! Processor 11 reporting for duty\n0: Hello 12! Processor 12 reporting for duty\n0: Hello 13! Processor 13 reporting for duty\n0: Hello 14! Processor 14 reporting for duty\n0: Hello 15! Processor 15 reporting for duty\n</code></pre> <p>The runtime environment for the MPI implementation used (often called mpirun or mpiexec) spawns multiple copies of the program, with the total number of copies determining the number of process ranks in MPI_COMM_WORLD, which is an opaque descriptor for communication between the set of processes. A single process, multiple data (SPMD = Single Program, Multiple Data) programming model is thereby facilitated, but not required; many MPI implementations allow multiple, different, executables to be started in the same MPI job. Each process has its own rank, the total number of processes in the world, and the ability to communicate between them either with point-to-point (send/receive) communication, or by collective communication among the group. It is enough for MPI to provide an SPMD-style program with MPI_COMM_WORLD, its own rank, and the size of the world to allow algorithms to decide what to do. In more realistic situations, I/O is more carefully managed than in this example. MPI does not guarantee how POSIX I/O would actually work on a given system, but it commonly does work, at least from rank 0.</p> <p>MPI uses the notion of process rather than processor. Program copies are mapped to processors by the MPI runtime. In that sense, the parallel machine can map to 1 physical processor, or N where N is the total number of processors available, or something in between. For maximum parallel speedup, more physical processors are used. This example adjusts its behaviour to the size of the world N, so it also seeks to scale to the runtime configuration without compilation for each size variation, although runtime decisions might vary depending on that absolute amount of concurrency available.</p> <p>Tip</p> <p>mpirun does not always do the optimal core pinning and requires a few extra arguments to be the most efficient possible on a given system. At Ghent we have a wrapper around <code>mpirun</code> called <code>mympirun</code>. See for more information.</p> <p>You will generally just start an MPI program on the by using <code>mympirun</code> instead of <code>mpirun -n &lt;nr of cores&gt; &lt;--other settings&gt; &lt;--other optimisations&gt;</code></p> <p>Tip</p> <p>If you plan engaging in parallel programming using MPI, this book may prove useful: Parallel Programming with MPI. Peter Pacheo. Morgan Kaufmann. 1996.</p>"}, {"location": "multi_job_submission/", "title": "Multi-job submission", "text": "<p>A frequent occurring characteristic of scientific computation is their focus on data intensive processing. A typical example is the iterative evaluation of a program over different input parameter values, often referred to as a \"parameter sweep\". A Parameter Sweep runs a job a specified number of times, as if we sweep the parameter values through a user defined range.</p> <p>Users then often want to submit a large numbers of jobs based on the same job script but with (i) slightly different parameters settings or with (ii) different input files.</p> <p>These parameter values can have many forms, we can think about a range (e.g., from 1 to 100), or the parameters can be stored line by line in a comma-separated file. The users want to run their job once for each instance of the parameter values.</p> <p>One option could be to launch a lot of separate individual small jobs (one for each parameter) on the cluster, but this is not a good idea. The cluster scheduler isn't meant to deal with tons of small jobs. Those huge amounts of small jobs will create a lot of overhead, and can slow down the whole cluster. It would be better to bundle those jobs in larger sets. In TORQUE, an experimental feature known as \"job arrays\" existed to allow the creation of multiple jobs with one qsub command, but is was not supported by Moab, the current scheduler.</p> <p>The \"Worker framework\" has been developed to address this issue.</p> <p>It can handle many small jobs determined by:</p> parameter variations <p>i.e., many small jobs determined by a specific parameter set which is stored in a .csv (comma separated value) input file.</p> job arrays <p>i.e., each individual job got a unique numeric identifier.</p> <p>Both use cases often have a common root: the user wants to run a program with a large number of parameter settings, and the program does not allow for aggregation, i.e., it has to be run once for each instance of the parameter values.</p> <p>However, the Worker Framework's scope is wider: it can be used for any scenario that can be reduced to a MapReduce approach.1</p>"}, {"location": "multi_job_submission/#the-worker-framework-parameter-sweeps", "title": "The worker Framework: Parameter Sweeps", "text": "<p>First go to the right directory:</p> <pre><code>$ cd ~/examples/Multi-job-submission/par_sweep</code></pre> <p>Suppose the program the user wishes to run the \"weather\" program, which takes three parameters: a temperature, a pressure and a volume. A typical call of the program looks like:</p> <pre><code>$ ./weather -t 20 -p 1.05 -v 4.3\nT: 20  P: 1.05  V: 4.3</code></pre> <p>For the purpose of this exercise, the weather program is just a simple bash script, which prints the 3 variables to the standard output and waits a bit:</p> <p>par_sweep/weather</p> <pre><code>#!/bin/bash\n# Here you could do your calculations\necho \"T: $2  P: $4  V: $6\"\nsleep 100\n</code></pre> <p>A job script that would run this as a job for the first parameters (p01) would then look like:</p> <p>par_sweep/weather_p01.pbs</p> <pre><code>#!/bin/bash\n\n#PBS -l nodes=1:ppn=8\n#PBS -l walltime=01:00:00\n\ncd $PBS_O_WORKDIR\n./weather -t 20 -p 1.05 -v 4.3\n</code></pre> <p>When submitting this job, the calculation is performed or this particular instance of the parameters, i.e., temperature = 20, pressure = 1.05, and volume = 4.3.</p> <p>To submit the job, the user would use:</p> <pre><code>$ qsub weather_p01.pbs</code></pre> <p>However, the user wants to run this program for many parameter instances, e.g., he wants to run the program on 100 instances of temperature, pressure and volume. The 100 parameter instances can be stored in a comma separated value file (.csv) that can be generated using a spreadsheet program such as Microsoft Excel or RDBMS or just by hand using any text editor (do not use a word processor such as Microsoft Word). The first few lines of the file \"data.csv\" would look like:</p> <pre><code>$ more data.csv\ntemperature, pressure, volume\n293, 1.0e5, 107\n294, 1.0e5, 106\n295, 1.0e5, 105\n296, 1.0e5, 104\n297, 1.0e5, 103\n...</code></pre> <p>It has to contain the names of the variables on the first line, followed by 100 parameter instances in the current example.</p> <p>In order to make our PBS generic, the PBS file can be modified as follows:</p> <p>par_sweep/weather.pbs</p> <pre><code>#!/bin/bash\n\n#PBS -l nodes=1:ppn=8\n#PBS -l walltime=04:00:00\n\ncd $PBS_O_WORKDIR\n./weather -t $temperature -p $pressure -v $volume\n\n# # This script is submitted to the cluster with the following 2 commands:\n# module load worker/1.6.12-foss-2021b\n# wsub -data data.csv -batch weather.pbs\n</code></pre> <p>Note that:</p> <ol> <li> <p>the parameter values 20, 1.05, 4.3 have been replaced by variables     $temperature, $pressure and $volume respectively, which were     being specified on the first line of the \"data.csv\" file;</p> </li> <li> <p>the number of processors per node has been increased to 8 (i.e.,     ppn=1 is replaced by ppn=8);</p> </li> <li> <p>the walltime has been increased to 4 hours (i.e., walltime=00:15:00     is replaced by walltime=04:00:00).</p> </li> </ol> <p>The walltime is calculated as follows: one calculation takes 15 minutes, so 100 calculations take 1500 minutes on one CPU. However, this job will use 8 CPUs, so the 100 calculations will be done in 1500/8 = 187.5 minutes, i.e., 4 hours to be on the safe side.</p> <p>The job can now be submitted as follows (to check which <code>worker</code> module to use, see subsection Using explicit version numbers):</p> <pre><code>$ module load worker/1.6.12-foss-2021b\n$ wsub -batch weather.pbs -data data.csv\ntotal number of work items: 41\n123456</code></pre> <p>Note that the PBS file is the value of the -batch option. The weather program will now be run for all 100 parameter instances -- 8 concurrently -- until all computations are done. A computation for such a parameter instance is called a work item in Worker parlance.</p>"}, {"location": "multi_job_submission/#the-worker-framework-job-arrays", "title": "The Worker framework: Job arrays", "text": "<p>First go to the right directory:</p> <pre><code>$ cd ~/examples/Multi-job-submission/job_array</code></pre> <p>As a simple example, assume you have a serial program called myprog that you want to run on various input files input[1-100].</p> <p></p> <p>The following bash script would submit these jobs all one by one: <pre><code>#!/bin/bash\nfor i in `seq 1 100`; do\nqsub -o output $i -i input $i myprog.pbs\ndone\n</code></pre></p> <p>This, as said before, could be disturbing for the job scheduler.</p> <p>Alternatively, TORQUE provides a feature known as job arrays which allows the creation of multiple, similar jobs with only one qsub command. This feature introduced a new job naming convention that allows users either to reference the entire set of jobs as a unit or to reference one particular job from the set.</p> <p>Under TORQUE, the -t range option is used with qsub to specify a job array, where range is a range of numbers (e.g., 1-100 or 2,4-5,7).</p> <p>The details are</p> <ol> <li> <p>a job is submitted for each number in the range;</p> </li> <li> <p>individuals jobs are referenced as jobid-number, and the entire     array can be referenced as jobid for easy killing etc.; and</p> </li> <li> <p>each job has PBS_ARRAYID set to its number which allows the     script/program to specialise for that job</p> </li> </ol> <p>The job could have been submitted using:</p> <pre><code>$ qsub -t 1-100 my_prog.pbs</code></pre> <p>The effect was that rather than 1 job, the user would actually submit 100 jobs to the queue system. This was a popular feature of TORQUE, but as this technique puts quite a burden on the scheduler, it is not supported by Moab (the current job scheduler).</p> <p>To support those users who used the feature and since it offers a convenient workflow, the \"worker framework\" implements the idea of \"job arrays\" in its own way.</p> <p>A typical job script for use with job arrays would look like this:</p> <p>job_array/job_array.pbs</p> <pre><code>#!/bin/bash -l\n#PBS -l nodes=1:ppn=1\n#PBS -l walltime=00:15:00\ncd $PBS_O_WORKDIR\nINPUT_FILE=\"input_${PBS_ARRAYID}.dat\"\nOUTPUT_FILE=\"output_${PBS_ARRAYID}.dat\"\nmy_prog -input ${INPUT_FILE}  -output ${OUTPUT_FILE}\n</code></pre> <p>In our specific example, we have prefabricated 100 input files in the \"./input\" subdirectory. Each of those files contains a number of parameters for the \"test_set\" program, which will perform some tests with those parameters.</p> <p>Input for the program is stored in files with names such as input_1.dat, input_2.dat, ..., input_100.dat in the ./input subdirectory.</p> <pre><code>$ ls ./input\n...\n$ more ./input/input_99.dat\nThis is input file \\#99\nParameter #1 = 99\nParameter #2 = 25.67\nParameter #3 = Batch\nParameter #4 = 0x562867</code></pre> <p>For the sole purpose of this exercise, we have provided a short \"test_set\" program, which reads the \"input\" files and just copies them into a corresponding output file. We even add a few lines to each output file. The corresponding output computed by our \"test_set\" program will be written to the \"./output\" directory in output_1.dat, output_2.dat, ..., output_100.dat. files.</p> <p>job_array/test_set</p> <pre><code>#!/bin/bash\n\n# Check if the output Directory exists\nif [ ! -d \"./output\" ] ; then\nmkdir ./output\nfi\n\n#   Here you could do your calculations...\necho \"This is Job_array #\" $1\necho \"Input File : \" $3\necho \"Output File: \" $5\ncat ./input/$3 | sed -e \"s/input/output/g\" | grep -v \"Parameter\" &gt; ./output/$5\necho \"Calculations done, no results\" &gt;&gt; ./output/$5\n</code></pre> <p>Using the \"worker framework\", a feature akin to job arrays can be used with minimal modifications to the job script:</p> <p>job_array/test_set.pbs</p> <pre><code>#!/bin/bash -l\n#PBS -l nodes=1:ppn=8\n#PBS -l walltime=04:00:00\ncd $PBS_O_WORKDIR\nINPUT_FILE=\"input_${PBS_ARRAYID}.dat\"\nOUTPUT_FILE=\"output_${PBS_ARRAYID}.dat\"\n./test_set ${PBS_ARRAYID} -input ${INPUT_FILE}  -output ${OUTPUT_FILE}\n</code></pre> <p>Note that</p> <ol> <li> <p>the number of CPUs is increased to 8 (ppn=1 is replaced by ppn=8);     and</p> </li> <li> <p>the walltime has been modified (walltime=00:15:00 is replaced by     walltime=04:00:00).</p> </li> </ol> <p>The job is now submitted as follows:</p> <pre><code>$ module load worker/1.6.12-foss-2021b\n$ wsub -t 1-100 -batch test_set.pbs\ntotal number of work items: 100\n123456</code></pre> <p>The \"test_set\" program will now be run for all 100 input files -- 8 concurrently -- until all computations are done. Again, a computation for an individual input file, or, equivalently, an array id, is called a work item in Worker speak.</p> <p>Note that in contrast to TORQUE job arrays, a worker job array only submits a single job.</p> <pre><code>$ qstat\nJob id          Name          User      Time   Use S Queue\n--------------- ------------- --------- ---- ----- - -----\n123456  test_set.pbs  vsc40000          0 Q\n\nAnd you can now check the generated output files:\n$ more ./output/output_99.dat\nThis is output file #99\nCalculations done, no results\n</code></pre>"}, {"location": "multi_job_submission/#mapreduce-prologues-and-epilogue", "title": "MapReduce: prologues and epilogue", "text": "<p>Often, an embarrassingly parallel computation can be abstracted to three simple steps:</p> <ol> <li> <p>a preparation phase in which the data is split up into smaller, more     manageable chunks;</p> </li> <li> <p>on these chunks, the same algorithm is applied independently (these     are the work items); and</p> </li> <li> <p>the results of the computations on those chunks are aggregated into,     e.g., a statistical description of some sort.</p> </li> </ol> <p></p> <p>The Worker framework directly supports this scenario by using a prologue (pre-processing) and an epilogue (post-processing). The former is executed just once before work is started on the work items, the latter is executed just once after the work on all work items has finished. Technically, the master, i.e., the process that is responsible for dispatching work and logging progress, executes the prologue and epilogue.</p> <pre><code>$ cd ~/examples/Multi-job-submission/map_reduce</code></pre> <p>The script \"pre.sh\" prepares the data by creating 100 different input-files, and the script \"post.sh\" aggregates (concatenates) the data.</p> <p>First study the scripts:</p> <p>map_reduce/pre.sh</p> <pre><code>#!/bin/bash\n\n# Check if the input Directory exists\nif [ ! -d \"./input\" ] ; then\nmkdir ./input\nfi\n\n# Just generate all dummy input files\nfor i in {1..100}; do\necho \"This is input file #$i\" &gt;  ./input/input_$i.dat echo \"Parameter #1 = $i\" &gt;&gt;  ./input/input_$i.dat echo \"Parameter #2 = 25.67\" &gt;&gt;  ./input/input_$i.dat\n  echo \"Parameter #3 = Batch\" &gt;&gt;  ./input/input_$i.dat\n  echo \"Parameter #4 = 0x562867\" &gt;&gt;  ./input/input_$i.dat\ndone\n</code></pre> <p>map_reduce/post.sh</p> <pre><code>#!/bin/bash\n\n# Check if the input Directory exists\nif [ ! -d \"./output\" ] ; then\necho \"The output directory does not exist!\"\nexit\nfi\n\n# Just concatenate all output files\ntouch all_output.txt\nfor i in {1..100}; do\ncat ./output/output_$i.dat &gt;&gt; all_output.txt\ndone\n</code></pre> <p>Then one can submit a MapReduce style job as follows:</p> <pre><code>$ wsub -prolog pre.sh -batch test_set.pbs -epilog post.sh -t 1-100\ntotal number of work items: 100\n123456\n$ cat all_output.txt\n...\n$ rm -r -f ./output/</code></pre> <p>Note that the time taken for executing the prologue and the epilogue should be added to the job's total walltime.</p>"}, {"location": "multi_job_submission/#some-more-on-the-worker-framework", "title": "Some more on the Worker Framework", "text": ""}, {"location": "multi_job_submission/#using-worker-efficiently", "title": "Using Worker efficiently", "text": "<p>The \"Worker Framework\" is implemented using MPI, so it is not restricted to a single compute nodes, it scales well to multiple nodes. However, remember that jobs requesting a large number of nodes typically spend quite some time in the queue.</p> <p>The \"Worker Framework\" will be effective when</p> <ol> <li> <p>work items, i.e., individual computations, are neither too short,     nor too long (i.e., from a few minutes to a few hours); and,</p> </li> <li> <p>when the number of work items is larger than the number of CPUs     involved in the job (e.g., more than 30 for 8 CPUs).</p> </li> </ol>"}, {"location": "multi_job_submission/#monitoring-a-worker-job", "title": "Monitoring a worker job", "text": "<p>Since a Worker job will typically run for several hours, it may be reassuring to monitor its progress. Worker keeps a log of its activity in the directory where the job was submitted. The log's name is derived from the job's name and the job's ID, i.e., it has the form <code>&lt;jobname&gt;.log&lt;jobid&gt;</code>. For the running example, this could be <code>run.pbs.log123456</code>, assuming the job's ID is 123456. To keep an eye on the progress, one can use:</p> <pre><code>$ tail -f run.pbs.log123456</code></pre> <p>Alternatively, <code>wsummarize</code>, a Worker command that summarises a log file, can be used:</p> <pre><code>$ watch -n 60 wsummarize run.pbs.log123456</code></pre> <p>This will summarise the log file every 60 seconds.</p>"}, {"location": "multi_job_submission/#time-limits-for-work-items", "title": "Time limits for work items", "text": "<p>Sometimes, the execution of a work item takes long than expected, or worse, some work items get stuck in an infinite loop. This situation is unfortunate, since it implies that work items that could successfully execute are not even started. Again, the Worker framework offers a simple and yet versatile solution. If we want to limit the execution of each work item to at most 20 minutes, this can be accomplished by modifying the script of the running example. <pre><code>#!/bin/bash -l\n#PBS -l nodes=1:ppn=8\n#PBS -l walltime=04:00:00\nmodule load timedrun/1.0\ncd $PBS_O_WORKDIR\ntimedrun -t 00:20:00 weather -t $temperature  -p $pressure  -v $volume\n</code></pre></p> <p>Note that it is trivial to set individual time constraints for work items by introducing a parameter, and including the values of the latter in the CSV file, along with those for the temperature, pressure and volume.</p> <p>Also note that \"timedrun\" is in fact offered in a module of its own, so it can be used outside the Worker framework as well.</p>"}, {"location": "multi_job_submission/#resuming-a-worker-job", "title": "Resuming a Worker job", "text": "<p>Unfortunately, it is not always easy to estimate the walltime for a job, and consequently, sometimes the latter is underestimated. When using the Worker framework, this implies that not all work items will have been processed. Worker makes it very easy to resume such a job without having to figure out which work items did complete successfully, and which remain to be computed. Suppose the job that did not complete all its work items had ID \"445948\".</p> <pre><code>$ wresume -jobid 123456</code></pre> <p>This will submit a new job that will start to work on the work items that were not done yet. Note that it is possible to change almost all job parameters when resuming, specifically the requested resources such as the number of cores and the walltime.</p> <pre><code>$ wresume -l walltime=1:30:00 -jobid 123456}</code></pre> <p>Work items may fail to complete successfully for a variety of reasons, e.g., a data file that is missing, a (minor) programming error, etc. Upon resuming a job, the work items that failed are considered to be done, so resuming a job will only execute work items that did not terminate either successfully, or reporting a failure. It is also possible to retry work items that failed (preferably after the glitch why they failed was fixed).</p> <pre><code>$ wresume -jobid 123456 -retry</code></pre> <p>By default, a job's prologue is not executed when it is resumed, while its epilogue is. \"wresume\" has options to modify this default behaviour.</p>"}, {"location": "multi_job_submission/#further-information", "title": "Further information", "text": "<p>This how-to introduces only Worker's basic features. The wsub command has some usage information that is printed when the -help option is specified:</p> <pre><code>$ wsub -help\n### usage: wsub  -batch &lt;batch-file&gt;          \n#                [-data &lt;data-files&gt;]         \n#                [-prolog &lt;prolog-file&gt;]      \n#                [-epilog &lt;epilog-file&gt;]      \n#                [-log &lt;log-file&gt;]            \n#                [-mpiverbose]                \n#                [-dryrun] [-verbose]         \n#                [-quiet] [-help]             \n#                [-t &lt;array-req&gt;]             \n#                [&lt;pbs-qsub-options&gt;]\n#\n#   -batch &lt;batch-file&gt;   : batch file template, containing variables to be\n#                           replaced with data from the data file(s) or the\n#                           PBS array request option\n#   -data &lt;data-files&gt;    : comma-separated list of data files (default CSV\n#                           files) used to provide the data for the work\n#                           items\n#   -prolog &lt;prolog-file&gt; : prolog script to be executed before any of the\n#                           work items are executed\n#   -epilog &lt;epilog-file&gt; : epilog script to be executed after all the work\n#                           items are executed\n#   -mpiverbose           : pass verbose flag to the underlying MPI program\n#   -verbose              : feedback information is written to standard error\n#   -dryrun               : run without actually submitting the job, useful\n#   -quiet                : don't show information\n#   -help                 : print this help message\n#   -t &lt;array-req&gt;        : qsub's PBS array request options, e.g., 1-10\n#   &lt;pbs-qsub-options&gt;    : options passed on to the queue submission\n#                           command\n</code></pre> <ol> <li> <p>MapReduce: 'Map' refers to the map pattern in which every item in a collection is mapped onto a new value by applying a given function, while \"reduce\" refers to the reduction pattern which condenses or reduces a collection of previously computed results to a single value.\u00a0\u21a9</p> </li> </ol>"}, {"location": "mympirun/", "title": "Mympirun", "text": "<p><code>mympirun</code> is a tool to make it easier for users of HPC clusters to run MPI programs with good performance. We strongly recommend to use <code>mympirun</code> instead of <code>impirun</code>.</p> <p>In this chapter, we give a high-level overview. For a more detailed description of all options, see the vsc-mympirun README.</p>"}, {"location": "mympirun/#basic-usage", "title": "Basic usage", "text": "<p>Before using <code>mympirun</code>, we first need to load its module:</p> <pre><code>$ module load vsc-mympirun\n</code></pre> <p>As an exception, we don't specify a version here. The reason is that we want to ensure that the latest version of the <code>mympirun</code> script is always used, since it may include important bug fixes or improvements.</p> <p>The most basic form of using <code>mympirun</code> is <code>mympirun [mympirun options] your_program [your_program options]</code>.</p> <p>For example, to run a program named <code>example</code> and give it a single argument (<code>5</code>), we can run it with <code>mympirun example 5</code>.</p>"}, {"location": "mympirun/#controlling-number-of-processes", "title": "Controlling number of processes", "text": "<p>There are four options you can choose from to control the number of processes <code>mympirun</code> will start. In the following example, the program <code>mpi_hello</code> prints a single line: <code>Hello world from processor &lt;node&gt; ...</code> (the sourcecode of <code>mpi_hello</code> is available in the vsc-mympirun repository).</p> <p>By default, <code>mympirun</code> starts one process per core on every node you assigned. So if you assigned 2 nodes with 16 cores each, <code>mympirun</code> will start 2 . 16 = 32 test processes in total.</p>"}, {"location": "mympirun/#-hybrid-h", "title": "<code>--hybrid</code>/<code>-h</code>", "text": "<p>This is the most commonly used option for controlling the number of processing.</p> <p>The <code>--hybrid</code> option requires a positive number. This number specifies the number of processes started on each available physical node. It will ignore the number of available cores per node.</p> <pre><code>$ echo $PBS_NUM_NODES\n2\n$ mympirun --hybrid 2 ./mpihello\nHello world from processor node3400.doduo.os, rank 1 out of 4 processors \nHello world from processor node3401.doduo.os, rank 3 out of 4 processors \nHello world from processor node3401.doduo.os, rank 2 out of 4 processors \nHello world from processor node3400.doduo.os, rank 0 out of 4 processors\n</code></pre>"}, {"location": "mympirun/#other-options", "title": "Other options", "text": "<p>There's also <code>--universe</code>, which sets the exact amount of processes started by <code>mympirun</code>; <code>--double</code>, which uses double the amount of processes it normally would; and <code>--multi</code> that does the same as <code>--double</code>, but takes a multiplier (instead of the implied factor 2 with <code>--double</code>).</p> <p>See vsc-mympirun README for a detailed explanation of these options.</p>"}, {"location": "mympirun/#dry-run", "title": "Dry run", "text": "<p>You can do a so-called \"dry run\", which doesn't have any side-effects, but just prints the command that <code>mympirun</code> would execute. You enable this with the <code>--dry-run</code> flag:</p> <pre><code>$ mympirun --dry-run ./mpi_hello\nmpirun ... -genv I_MPI_FABRICS shm:dapl ... -np 16 ... ./mpi_hello\n</code></pre>"}, {"location": "openFOAM/", "title": "OpenFOAM", "text": "<p>In this chapter, we outline best practices for using the centrally provided OpenFOAM installations on the VSC HPC infrastructure.</p>"}, {"location": "openFOAM/#different-openfoam-releases", "title": "Different OpenFOAM releases", "text": "<p>There are currently three different sets of versions of OpenFOAM available, each with its own versioning scheme:</p> <ul> <li> <p>OpenFOAM versions released via http://openfoam.com: <code>v3.0+</code>,     <code>v1706</code></p> <ul> <li>see also http://openfoam.com/history/</li> </ul> </li> <li> <p>OpenFOAM versions released via https://openfoam.org: <code>v4.1</code>,     <code>v5.0</code></p> <ul> <li>see also https://openfoam.org/download/history/</li> </ul> </li> <li> <p>OpenFOAM versions released via     http://wikki.gridcore.se/foam-extend: <code>v3.1</code></p> </li> </ul> <p>Make sure you know which flavor of OpenFOAM you want to use, since there are important differences between the different versions w.r.t. features. If the OpenFOAM version you need is not available yet, see I want to use software that is not available on the clusters yet.</p>"}, {"location": "openFOAM/#documentation-training-material", "title": "Documentation &amp; training material", "text": "<p>The best practices outlined here focus specifically on the use of OpenFOAM on the VSC HPC infrastructure. As such, they are intended to augment the existing OpenFOAM documentation rather than replace it. For more general information on using OpenFOAM, please refer to:</p> <ul> <li> <p>OpenFOAM websites:</p> <ul> <li> <p>https://openfoam.com</p> </li> <li> <p>https://openfoam.org</p> </li> <li> <p>http://wikki.gridcore.se/foam-extend</p> </li> </ul> </li> <li> <p>OpenFOAM user guides:</p> <ul> <li> <p>https://www.openfoam.com/documentation/user-guide</p> </li> <li> <p>https://cfd.direct/openfoam/user-guide/</p> </li> </ul> </li> <li> <p>OpenFOAM C++ source code guide: https://cpp.openfoam.org</p> </li> <li> <p>tutorials: https://wiki.openfoam.com/Tutorials</p> </li> <li> <p>recordings of \"Introduction to OpenFOAM\" training session at     UGent (May 2016):     https://www.youtube.com/playlist?list=PLqxhJj6bcnY9RoIgzeF6xDh5L9bbeK3BL</p> </li> </ul> <p>Other useful OpenFOAM documentation:</p> <ul> <li> <p>https://github.com/ParticulateFlow/OSCCAR-doc/blob/master/openFoamUserManual_PFM.pdf</p> </li> <li> <p>http://www.dicat.unige.it/guerrero/openfoam.html</p> </li> </ul>"}, {"location": "openFOAM/#preparing-the-environment", "title": "Preparing the environment", "text": "<p>To prepare the environment of your shell session or job for using OpenFOAM, there are a couple of things to take into account.</p>"}, {"location": "openFOAM/#picking-and-loading-an-openfoam-module", "title": "Picking and loading an <code>OpenFOAM</code> module", "text": "<p>First of all, you need to pick and load one of the available <code>OpenFOAM</code> modules. To get an overview of the available modules, run '<code>module avail OpenFOAM</code>'. For example:</p> <pre><code>$ module avail OpenFOAM\n------------------ /apps/gent/CO7/sandybridge/modules/all ------------------\n   OpenFOAM/v1712-foss-2017b     OpenFOAM/4.1-intel-2017a\n   OpenFOAM/v1712-intel-2017b    OpenFOAM/5.0-intel-2017a\n   OpenFOAM/2.2.2-intel-2017a    OpenFOAM/5.0-intel-2017b\n   OpenFOAM/2.2.2-intel-2018a    OpenFOAM/5.0-20180108-foss-2018a\n   OpenFOAM/2.3.1-intel-2017a    OpenFOAM/5.0-20180108-intel-2017b\n   OpenFOAM/2.4.0-intel-2017a    OpenFOAM/5.0-20180108-intel-2018a\n   OpenFOAM/3.0.1-intel-2016b    OpenFOAM/6-intel-2018a            (D)\n   OpenFOAM/4.0-intel-2016b\n</code></pre> <p>To pick a module, take into account the differences between the different OpenFOAM versions w.r.t. features and API (see also Different OpenFOAM releases). If multiple modules are available that fulfill your requirements, give preference to those providing a more recent OpenFOAM version, and to the ones that were installed with a more recent compiler toolchain; for example, prefer a module that includes <code>intel-{{ current_year }}b</code> in its name over one that includes <code>intel-{{ current_year }}a</code>.</p> <p>To prepare your environment for using OpenFOAM, load the <code>OpenFOAM</code> module you have picked; for example:</p> <pre><code>$ module load OpenFOAM/4.1-intel-2017a\n</code></pre>"}, {"location": "openFOAM/#sourcing-the-foam_bash-script", "title": "Sourcing the <code>$FOAM_BASH</code> script", "text": "<p>OpenFOAM provides a script that you should <code>source</code> to further prepare the environment. This script will define some additional environment variables that are required to use OpenFOAM. The <code>OpenFOAM</code> modules define an environment variable named <code>FOAM_BASH</code> that specifies the location to this script. Assuming you are using <code>bash</code> in your shell session or job script, you should always run the following command after loading an <code>OpenFOAM</code> module:</p> <pre><code>$ source $FOAM_BASH\n</code></pre>"}, {"location": "openFOAM/#defining-utility-functions-used-in-tutorial-cases", "title": "Defining utility functions used in tutorial cases", "text": "<p>If you would like to use the <code>getApplication</code>, <code>runApplication</code>, <code>runParallel</code>, <code>cloneCase</code> and/or <code>compileApplication</code> functions that are used in OpenFOAM tutorials, you also need to <code>source</code> the <code>RunFunctions</code> script:</p> <pre><code>$  source $WM_PROJECT_DIR/bin/tools/RunFunctions\n</code></pre> <p>Note that this needs to be done after sourcing <code>$FOAM_BASH</code> to make sure <code>$WM_PROJECT_DIR</code> is defined.</p>"}, {"location": "openFOAM/#dealing-with-floating-point-errors", "title": "Dealing with floating-point errors", "text": "<p>If you are seeing <code>Floating Point Exception</code> errors, you can undefine the <code>$FOAM_SIGFPE</code> environment variable that is defined by the <code>$FOAM_BASH</code> script as follows:</p> <pre><code>$ unset $FOAM_SIGFPE\n</code></pre> <p>Note that this only prevents OpenFOAM from propagating floating point exceptions, which then results in terminating the simulation. However, it does not prevent that illegal operations (like a division by zero) are being executed; if <code>NaN</code> values appear in your results, floating point errors are occurring.</p> <p>As such, you should not use this in productions runs. Instead, you should track down the root cause of the floating point errors, and try to prevent them from occurring at all.</p>"}, {"location": "openFOAM/#openfoam-workflow", "title": "OpenFOAM workflow", "text": "<p>The general workflow for OpenFOAM consists of multiple steps. Prior to running the actual simulation, some pre-processing needs to be done:</p> <ul> <li> <p>generate the mesh;</p> </li> <li> <p>decompose the domain into subdomains using <code>decomposePar</code> (only for     parallel OpenFOAM simulations);</p> </li> </ul> <p>After running the simulation, some post-processing steps are typically performed:</p> <ul> <li> <p>reassemble the decomposed domain using <code>reconstructPar</code> (only for     parallel OpenFOAM simulations, and optional since some     postprocessing can also be done on decomposed cases);</p> </li> <li> <p>evaluate or further process the simulation results, either visually     using ParaView (for example, via the <code>paraFoam</code> tool; use     <code>paraFoam -builtin</code> for decomposed cases) or using command-line     tools like <code>postProcess</code>; see also     https://cfd.direct/openfoam/user-guide/postprocessing.</p> </li> </ul> <p>Depending on the size of the domain and the desired format of the results, these pre- and post-processing steps can be run either before/after the job running the actual simulation, either on the HPC infrastructure or elsewhere, or as a part of the job that runs the OpenFOAM simulation itself.</p> <p>Do make sure you are using the same OpenFOAM version in each of the steps. Meshing can be done sequentially (i.e., on a single core) using for example <code>blockMesh</code>, or in parallel using more advanced meshing tools like <code>snappyHexMesh</code>, which is highly recommended for large cases. For more details, see https://cfd.direct/openfoam/user-guide/mesh/.</p> <p>One important aspect to keep in mind for 'offline' pre-processing is that the domain decomposition needs to match the number of processor cores that are used for the actual simulation, see also Domain decomposition and number of processor cores.</p> <p>For post-processing you can either download the simulation results to a local workstation, or do the post-processing (interactively) on the HPC infrastructure, for example on the login nodes or using an interactive session on a workernode. This may be interesting to avoid the overhead of downloading the results locally.</p>"}, {"location": "openFOAM/#running-openfoam-in-parallel", "title": "Running OpenFOAM in parallel", "text": "<p>For general information on running OpenFOAM in parallel, see https://cfd.direct/openfoam/user-guide/running-applications-parallel/.</p>"}, {"location": "openFOAM/#the-parallel-option", "title": "The <code>-parallel</code> option", "text": "<p>When running OpenFOAM in parallel, do not forget to specify the <code>-parallel</code> option, to avoid running the same OpenFOAM simulation $N$ times, rather than running it once using $N$ processor cores.</p> <p>You can check whether OpenFOAM was run in parallel in the output of the main command: the OpenFOAM header text should only be included once in the output, and it should specify a value different than '<code>1</code>' in the <code>nProcs</code> field. Note that most pre- and post-processing utilities like <code>blockMesh</code>, <code>decomposePar</code> and <code>reconstructPar</code> can not be run in parallel.</p>"}, {"location": "openFOAM/#using-mympirun", "title": "Using <code>mympirun</code>", "text": "<p>It is highly recommended to use the <code>mympirun</code> command when running parallel OpenFOAM simulations rather than the standard <code>mpirun</code> command; see Mympiprun for more information on <code>mympirun</code>.</p> <p>See Basic usage for how to get started with <code>mympirun</code>.</p> <p>To pass down the environment variables required to run OpenFOAM (which were defined by the <code>$FOAM_BASH</code> script, see Preparing the environment) to each of the MPI processes used in a parallel OpenFOAM execution, the <code>$MYMPIRUN_VARIABLESPREFIX</code> environment variable must be defined as follows, prior to running the OpenFOAM simulation with <code>mympirun</code>:</p> <pre><code>$ export MYMPIRUN_VARIABLESPREFIX=WM_PROJECT,FOAM,MPI\n</code></pre> <p>Whenever you are instructed to use a command like <code>mpirun -np &lt;N&gt; ...</code>, use <code>mympirun ...</code> instead; <code>mympirun</code> will automatically detect the number of processor cores that are available (see also Controlling number of processes).</p>"}, {"location": "openFOAM/#domain-decomposition-and-number-of-processor-cores", "title": "Domain decomposition and number of processor cores", "text": "<p>To run OpenFOAM in parallel, you must decompose the domain into multiple subdomains. Each subdomain will be processed by OpenFOAM on one processor core.</p> <p>Since <code>mympirun</code> will automatically use all available cores, you need to make sure that the number of subdomains matches the number of processor cores that will be used by <code>mympirun</code>. If not, you may run into an error message like:</p> <pre><code>number of processor directories = 4 is not equal to the number of processors = 16\n</code></pre> <p>In this case, the case was decomposed in 4 subdomains, while the OpenFOAM simulation was started with 16 processes through <code>mympirun</code>. To match the number of subdomains and the number of processor cores used by <code>mympirun</code>, you should either:</p> <ul> <li> <p>adjust the value for <code>numberOfSubdomains</code> in     <code>system/decomposeParDict</code> (and adjust the value for <code>n</code> accordingly     in the domain decomposition coefficients), and run <code>decomposePar</code>     again; or</p> </li> <li> <p>submit your job requesting exactly the same number of processor     cores as there are subdomains (see the number of <code>processor*</code>     directories that were created by <code>decomposePar</code>)</p> </li> </ul> <p>See Controlling number of processes to control the number of process <code>mympirun</code> will start.</p> <p>This is interesting if you require more memory per core than is available by default. Note that the decomposition method being used (which is specified in <code>system/decomposeParDict</code>) has significant impact on the performance of a parallel OpenFOAM simulation. Good decomposition methods (like <code>metis</code> or <code>scotch</code>) try to limit communication overhead by minimising the number of processor boundaries.</p> <p>To visualise the processor domains, use the following command:</p> <pre><code>$ mympirun foamToVTK -parallel -constant -time 0 -excludePatches '(\".*.\")'\n</code></pre> <p>and then load the VTK files generated in the <code>VTK</code> folder into ParaView.</p>"}, {"location": "openFOAM/#running-openfoam-on-a-shared-filesystem", "title": "Running OpenFOAM on a shared filesystem", "text": "<p>OpenFOAM is known to significantly stress shared filesystems, since a lot of (small) files are generated during an OpenFOAM simulation. Shared filesystems are typically optimised for dealing with (a small number of) large files, and are usually a poor match for workloads that involve a (very) large number of small files (see also http://www.prace-ri.eu/IMG/pdf/IO-profiling_with_Darshan-2.pdf).</p> <p>Take into account the following guidelines for your OpenFOAM jobs, which all relate to input parameters for the OpenFOAM simulation that you can specify in <code>system/controlDict</code> (see also https://cfd.direct/openfoam/user-guide/controldict).</p> <ul> <li> <p>instruct OpenFOAM to write out results at a reasonable frequency, certainly not for every single time step}; you can control this using the <code>writeControl</code>, <code>writeInterval</code>, etc.\u00a0keywords;</p> </li> <li> <p>consider only retaining results for the last couple of time steps,     see the <code>purgeWrite</code> keyword;</p> </li> <li> <p>consider writing results for only part of the domain (e.g., a line     of plane) rather than the entire domain;</p> </li> <li> <p>if you do not plan to change the parameters of the OpenFOAM     simulation while it is running, set runTimeModifiable to false to avoid that OpenFOAM re-reads each     of the <code>system/*Dict</code> files at every time step;</p> </li> <li> <p>if the results per individual time step are large, consider setting     <code>writeCompression</code> to <code>true</code>;</p> </li> </ul> <p>For modest OpenFOAM simulations where a single workernode suffices, consider using the local disk of the workernode as working directory (accessible via <code>$VSC_SCRATCH_NODE</code>), rather than the shared <code>$VSC_SCRATCH</code> filesystem. **Certainly do not use a subdirectory in <code>$VSC_HOME</code> or <code>$VSC_DATA</code>, since these shared filesystems are too slow for these type of workloads.</p> <p>For large parallel OpenFOAM simulations on the UGent Tier-2 clusters, consider using the alternative shared scratch filesystem <code>$VSC_SCRATCH_ARCANINE</code> (see Pre-defined user directories).</p> <p>These guidelines are especially important for large-scale OpenFOAM simulations that involve more than a couple of dozen of processor cores.</p>"}, {"location": "openFOAM/#using-own-solvers-with-openfoam", "title": "Using own solvers with OpenFOAM", "text": "<p>See https://cfd.direct/openfoam/user-guide/compiling-applications/.</p>"}, {"location": "openFOAM/#example-openfoam-job-script", "title": "Example OpenFOAM job script", "text": "<p>Example job script for <code>damBreak</code> OpenFOAM tutorial (see also https://cfd.direct/openfoam/user-guide/dambreak):</p> <p>-- OpenFOAM_damBreak.sh -- <pre><code>#!/bin/bash\n#PBS -l walltime=1:0:0\n#PBS -l nodes=1:ppn=4\n# check for more recent OpenFOAM modules with 'module avail OpenFOAM'\nmodule load OpenFOAM/6-intel-2018a\nsource $FOAM_BASH\n# purposely not specifying a particular version to use most recent mympirun\nmodule load vsc-mympirun\n# let mympirun pass down relevant environment variables to MPI processes\nexport MYMPIRUN_VARIABLESPREFIX=WM_PROJECT,FOAM,MPI\n# set up working directory\n# (uncomment one line defining $WORKDIR below)\n#export WORKDIR=$VSC_SCRATCH/$PBS_JOBID  # for small multi-node jobs\n#export WORKDIR=$VSC_SCRATCH_ARCANINE/$PBS_JOBID  # for large multi-node jobs (not on available victini)\nexport WORKDIR=$VSC_SCRATCH_NODE/$PBS_JOBID  # for single-node jobs\nmkdir -p $WORKDIR\n# damBreak tutorial, see also https://cfd.direct/openfoam/user-guide/dambreak\ncp -r $FOAM_TUTORIALS/multiphase/interFoam/laminar/damBreak/damBreak $WORKDIR\ncd $WORKDIR/damBreak\necho \"working directory: $PWD\"\n# pre-processing: generate mesh\necho \"start blockMesh: $(date)\"\nblockMesh &amp;&gt; blockMesh.out\n# pre-processing: decompose domain for parallel processing\necho \"start decomposePar: $(date)\"\ndecomposePar &amp;&gt; decomposePar.out\n# run OpenFOAM simulation in parallel\n# note:\n#  * the -parallel option is strictly required to actually run in parallel!\n#    without it, the simulation is run N times on a single core...\n#  * mympirun will use all available cores in the job by default,\n#    you need to make sure this matches the number of subdomains!\necho \"start interFoam: $(date)\"\nmympirun --output=interFoam.out interFoam -parallel\n# post-processing: reassemble decomposed domain\necho \"start reconstructPar: $(date)\"\nreconstructPar &amp;&gt; reconstructPar.out\n# copy back results, i.e. all time step directories: 0, 0.05, ..., 1.0 and inputs\nexport RESULTS_DIR=$VSC_DATA/results/$PBS_JOBID\nmkdir -p $RESULTS_DIR\ncp -a *.out [0-9.]* constant system $RESULTS_DIR\necho \"results copied to $RESULTS_DIR at $(date)\"\n# clean up working directory\ncd $HOME\nrm -rf $WORKDIR\n</code></pre></p>"}, {"location": "program_examples/", "title": "Program examples", "text": "<p>Go to our examples:</p> <pre><code>$ cd ~/examples/Program-examples</code></pre> <p>Here, we just have put together a number of examples for your convenience. We did an effort to put comments inside the source files, so the source code files are (should be) self-explanatory.</p> <ol> <li> <p>01_Python</p> </li> <li> <p>02_C_C++</p> </li> <li> <p>03_Matlab</p> </li> <li> <p>04_MPI_C</p> </li> <li> <p>05a_OMP_C</p> </li> <li> <p>05b_OMP_FORTRAN</p> </li> <li> <p>06_NWChem</p> </li> <li> <p>07_Wien2k</p> </li> <li> <p>08_Gaussian</p> </li> <li> <p>09_Fortran</p> </li> <li> <p>10_PQS</p> </li> </ol> <p>The above 2 OMP directories contain the following examples:</p> C Files Fortran Files Description omp_hello.c omp_hello.f Hello world omp_workshare1.c omp_workshare1.f Loop work-sharing omp_workshare2.c omp_workshare2.f Sections work-sharing omp_reduction.c omp_reduction.f Combined parallel loop reduction omp_orphan.c omp_orphan.f Orphaned parallel loop reduction omp_mm.c omp_mm.f Matrix multiply omp_getEnvInfo.c omp_getEnvInfo.f Get and print environment information omp_bug1.comp_bug1fix.c omp_bug2.c  omp_bug3.c  omp_bug4.c  omp_bug4fix  omp_bug5.c  omp_bug5fix.c omp_bug6.c omp_bug1.f  omp_bug1fix.f  omp_bug2.f  omp_bug3.f  omp_bug4.f  omp_bug4fix  omp_bug5.f  omp_bug5fix.f  omp_bug6.f Programs with bugs and their solution <p>Compile by any of the following commands:</p> C: icc -openmp omp_hello.c -o hello\\newline pgcc -mp omp_hello.c -o hello\\newline gcc -fopenmp omp_hello.c -o hello Fortran: ifort -openmp omp_hello.f -o hello\\newline pgf90 -mp omp_hello.f -o hello\\newline gfortran -fopenmp omp_hello.f -o hello <p>Be invited to explore the examples.</p>"}, {"location": "quick_reference_guide/", "title": "HPC Quick Reference Guide", "text": "<p>Remember to substitute the usernames, login nodes, file names, ...for your own.</p> Login            Login          ssh vsc40000@login.hpc.ugent.be          Where am I?        hostname          Copy to HPC        scp foo.txt vsc40000@login.hpc.ugent.be:          Copy from HPC        scp vsc40000@login.hpc.ugent.be:foo.txt          Setup ftp session        sftp vsc40000@login.hpc.ugent.be Modules            List all available modules                    Module avail                   List loaded modules                 module list                 Load module                 module load example                 Unload module                  module unload example                 Unload all modules                 module purge                 Help on use of module                 module help        Jobs            Submit job with job script script.pbs qsub script.pbs          Status of job with ID 12345        qstat 12345          Show compute node of job with ID 12345        qstat -n 12345          Delete job with ID 12345        qdel 12345          Status of all your jobs        qstat          Detailed status of your jobs + a list nodes they are running on        qstat -na          Submit Interactive job        qsub -I Disk quota            Check your disk quota                     see https://account.vscentrum.be          Disk usage in current directory (.)        du -h Worker Framework            Load worker module           module load worker/1.6.12-foss-2021b  Don't forget to specify a version. To list available versions, use module avail worker/          Submit parameter sweep        wsub -batch weather.pbs -data data.csv          Submit job array        wsub -t 1-100 -batch test_set.pbs          Submit job array with prolog and epilog        wsub -prolog pre.sh -batch test_set.pbs -epilog post.sh -t 1-100"}, {"location": "running_batch_jobs/", "title": "Running batch jobs", "text": "<p>In order to have access to the compute nodes of a cluster, you have to use the job system. The system software that handles your batch jobs consists of two pieces: the queue- and resource manager TORQUE and the scheduler Moab. Together, TORQUE and Moab provide a suite of commands for submitting jobs, altering some of the properties of waiting jobs (such as reordering or deleting them), monitoring their progress and killing ones that are having problems or are no longer needed. Only the most commonly used commands are mentioned here.</p> <p></p> <p>When you connect to the HPC, you have access to (one of) the login nodes of the cluster. There you can prepare the work you want to get done on the cluster by, e.g., installing or compiling programs, setting up data sets, etc. The computations however, should not be performed on this login node. The actual work is done on the cluster's compute nodes. Each compute node contains a number of CPU cores. The compute nodes are managed by the job scheduling software (Moab) and a Resource Manager (TORQUE), which decides when and on which compute nodes the jobs can run. It is usually not necessary to log on to the compute nodes directly  and is only allowed on the nodes where you have a job running  . Users can (and should) monitor their jobs periodically as they run, but do not have to remain connected to the HPC the entire time.</p> <p>The documentation in this \"Running batch jobs\" section includes a description of the general features of job scripts, how to submit them for execution and how to monitor their progress.</p>"}, {"location": "running_batch_jobs/#modules", "title": "Modules", "text": "<p>Software installation and maintenance on a HPC cluster such as the VSC clusters poses a number of challenges not encountered on a workstation or a departmental cluster. We therefore need a system on the HPC, which is able to easily activate or deactivate the software packages that you require for your program execution.</p>"}, {"location": "running_batch_jobs/#environment-variables", "title": "Environment Variables", "text": "<p>The program environment on the HPC is controlled by pre-defined settings, which are stored in environment (or shell) variables. For more information about environment variables, see the chapter \"Getting started\", section \"Variables\" in the intro to Linux.</p> <p>All the software packages that are installed on the HPC cluster require different settings. These packages include compilers, interpreters, mathematical software such as MATLAB and SAS, as well as other applications and libraries.</p>"}, {"location": "running_batch_jobs/#the-module-command", "title": "The module command", "text": "<p>In order to administer the active software and their environment variables, the module system has been developed, which:</p> <ol> <li> <p>Activates or deactivates software packages and their dependencies.</p> </li> <li> <p>Allows setting and unsetting of environment variables, including     adding and deleting entries from list-like environment variables.</p> </li> <li> <p>Does this in a shell-independent fashion (necessary information is     stored in the accompanying module file).</p> </li> <li> <p>Takes care of versioning aspects: For many libraries, multiple     versions are installed and maintained. The module system also takes     care of the versioning of software packages. For instance, it does     not allow multiple versions to be loaded at same time.</p> </li> <li> <p>Takes care of dependencies: Another issue arises when one     considers library versions and the dependencies they require. Some     software requires an older version of a particular library to run     correctly (or at all). Hence a variety of version numbers is     available for important libraries. Modules typically load the     required dependencies automatically.</p> </li> </ol> <p>This is all managed with the <code>module</code> command, which is explained in the next sections.</p> <p>There is also a shorter <code>ml</code> command that does exactly the same as the <code>module</code> command and is easier to type. Whenever you see a <code>module</code> command, you can replace <code>module</code> with <code>ml</code>.</p>"}, {"location": "running_batch_jobs/#available-modules", "title": "Available modules", "text": "<p>A large number of software packages are installed on the HPC clusters. A list of all currently available software can be obtained by typing:</p> <pre><code>$ module available\n</code></pre> <p>It's also possible to execute <code>module av</code> or <code>module avail</code>, these are shorter to type and will do the same thing.</p> <p>This will give some output such as:</p> <pre><code>$ module av 2&gt;&amp;1 | more\n--- /apps/gent/SL6/sandybridge/modules/all ---\nABAQUS/6.12.1-linux-x86_64\nAMOS/3.1.0-ictce-4.0.10\nant/1.9.0-Java-1.7.0_40\nASE/3.6.0.2515-ictce-4.1.13-Python-2.7.3\nASE/3.6.0.2515-ictce-5.5.0-Python-2.7.6\n...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., MATLAB) is installed on the HPC.</p> <pre><code>$ module av 2&gt;&amp;1 | grep -i -e \"matlab\"\nMATLAB/2010b\nMATLAB/2012b\nMATLAB/2013b\n</code></pre> <p>As you are not aware of the capitals letters in the module name, we looked for a case-insensitive name with the \"-i\" option.</p> <p>This gives a full list of software packages that can be loaded.</p> <p>The casing of module names is important: lowercase and uppercase letters matter in module names.</p>"}, {"location": "running_batch_jobs/#organisation-of-modules-in-toolchains", "title": "Organisation of modules in toolchains", "text": "<p>The amount of modules on the VSC systems can be overwhelming, and it is not always immediately clear which modules can be loaded safely together if you need to combine multiple programs in a single job to get your work done.</p> <p>Therefore the VSC has defined so-called toolchains. A toolchain contains a C/C++ and Fortran compiler, a MPI library and some basic math libraries for (dense matrix) linear algebra and FFT. Two toolchains are defined on most VSC systems. One, the <code>intel</code> toolchain, consists of the Intel compilers, MPI library and math libraries. The other one, the <code>foss</code> toolchain, consists of Open Source components: the GNU compilers, OpenMPI, OpenBLAS and the standard LAPACK and ScaLAPACK libraries for the linear algebra operations and the FFTW library for FFT. The toolchains are refreshed twice a year, which is reflected in their name.</p> <p>E.g., <code>foss/{{ current_year }}a</code> is the first version of the <code>foss</code> toolchain in {{ current_year }}.</p> <p>The toolchains are then used to compile a lot of the software installed on the VSC clusters. You can recognise those packages easily as they all contain the name of the toolchain after the version number in their name (e.g., <code>Python/2.7.12-intel-2016b</code>). Only packages compiled with the same toolchain name and version can work together without conflicts.</p>"}, {"location": "running_batch_jobs/#loading-and-unloading-modules", "title": "Loading and unloading modules", "text": ""}, {"location": "running_batch_jobs/#module-load", "title": "module load", "text": "<p>To \"activate\" a software package, you load the corresponding module file using the <code>module load</code> command:</p> <pre><code>$ module load example\n</code></pre> <p>This will load the most recent version of example.</p> <p>For some packages, multiple versions are installed; the load command will automatically choose the default version (if it was set by the system administrators) or the most recent version otherwise (i.e., the lexicographical last after the <code>/</code>).</p> <p>**However, you should specify a particular version to avoid surprises when newer versions are installed:</p> <pre><code>$ module load secondexample/2.7-intel-2016b\n</code></pre> <p>The <code>ml</code> command is a shorthand for <code>module load</code>: <code>ml example/1.2.3</code> is equivalent to <code>module load example/1.2.3</code>.</p> <p>Modules need not be loaded one by one; the two <code>module load</code> commands can be combined as follows:</p> <pre><code>$ module load example/1.2.3 secondexample/2.7-intel-2016b\n</code></pre> <p>This will load the two modules as well as their dependencies (unless there are conflicts between both modules).</p>"}, {"location": "running_batch_jobs/#module-list", "title": "module list", "text": "<p>Obviously, you need to be able to keep track of the modules that are currently loaded. Assuming you have run the <code>module load</code> commands stated above, you will get the following:</p> <pre><code>$ module list\nCurrently Loaded Modulefiles: \n1) example/1.2.3                                        6) imkl/11.3.3.210-iimpi-2016b \n2) GCCcore/5.4.0                                        7) intel/2016b \n3) icc/2016.3.210-GCC-5.4.0-2.26                        8) examplelib/1.2-intel-2016b \n4) ifort/2016.3.210-GCC-5.4.0-2.26                      9) secondexample/2.7-intel-2016b \n5) impi/5.1.3.181-iccifort-2016.3.210-GCC-5.4.0-2.26\n</code></pre> <p>You can also just use the <code>ml</code> command without arguments to list loaded modules.</p> <p>It is important to note at this point that other modules (e.g., <code>intel/2016b</code>) are also listed, although the user did not explicitly load them. This is because <code>secondexample/2.7-intel-2016b</code> depends on it (as indicated in its name), and the system administrator specified that the <code>intel/2016b</code> module should be loaded whenever this <code>secondexample</code> module is loaded. There are advantages and disadvantages to this, so be aware of automatically loaded modules whenever things go wrong: they may have something to do with it!</p>"}, {"location": "running_batch_jobs/#module-unload", "title": "module unload", "text": "<p>To unload a module, one can use the <code>module unload</code> command. It works consistently with the <code>load</code> command, and reverses the latter's effect. However, the dependencies of the package are NOT automatically unloaded; you will have to unload the packages one by one. When the <code>secondexample</code> module is unloaded, only the following modules remain:</p> <pre><code>$ module unload secondexample\n$ module list\nCurrently Loaded Modulefiles: \nCurrently Loaded Modulefiles: \n1) example/1.2.3                        5) impi/5.1.3.181-iccifort-2016.3.210-GCC-5.4.0-2.26 \n2) GCCcore/5.4.0                        6) imkl/11.3.3.210-iimpi-2016b \n3) icc/2016.3.210-GCC-5.4.0-2.26        7) intel/2016b \n4) ifort/2016.3.210-GCC-5.4.0-2.26      8) examplelib/1.2-intel-2016b\n</code></pre> <p>To unload the <code>secondexample</code> module, you can also use <code>ml -secondexample</code>.</p> <p>Notice that the version was not specified: there can only be one version of a module loaded at a time, so unloading modules by name is not ambiguous. However, checking the list of currently loaded modules is always a good idea, since unloading a module that is currently not loaded will not result in an error.</p>"}, {"location": "running_batch_jobs/#purging-all-modules", "title": "Purging all modules", "text": "<p>In order to unload all modules at once, and hence be sure to start in a clean state, you can use:</p> <pre><code>$ module purge\n</code></pre> <p>This is always safe: the <code>cluster</code> module (the module that specifies which cluster jobs will get submitted to) will not be unloaded (because it's a so-called \"sticky\" module). </p>"}, {"location": "running_batch_jobs/#using-explicit-version-numbers", "title": "Using explicit version numbers", "text": "<p>Once a module has been installed on the cluster, the executables or libraries it comprises are never modified. This policy ensures that the user's programs will run consistently, at least if the user specifies a specific version. Failing to specify a version may result in unexpected behviour.</p> <p>Consider the following example: the user decides to use the <code>example</code> module and at that point in time, just a single version 1.2.3 is installed on the cluster. The user loads the module using:</p> <pre><code>$ module load example\n</code></pre> <p>rather than</p> <pre><code>$ module load example/1.2.3\n</code></pre> <p>Everything works fine, up to the point where a new version of <code>example</code> is installed, 4.5.6. From then on, the user's <code>load</code> command will load the latter version, rather than the intended one, which may lead to unexpected problems. See for example the following section on Module Conflicts.</p> <p>Consider the following <code>example</code> modules:</p> <pre><code>$ module avail example/\nexample/1.2.3 \nexample/4.5.6\n</code></pre> <p>Let's now generate a version conflict with the <code>example</code> module, and see what happens.</p> <pre><code>$ module av example/\nexample/1.2.3       example/4.5.6\n$ module load example/1.2.3  example/4.5.6\nLmod has detected the following error: A different version of the 'example' module is already loaded (see output of 'ml').\n$ module swap example/4.5.6\n</code></pre> <p>Note: A <code>module swap</code> command combines the appropriate <code>module unload</code> and <code>module load</code> commands.</p>"}, {"location": "running_batch_jobs/#search-for-modules", "title": "Search for modules", "text": "<p>With the <code>module spider</code> command, you can search for modules:</p> <pre><code>$ module spider example\n--------------------------------------------------------------------------------\n  example:\n--------------------------------------------------------------------------------\n    Description: \n        This is just an example\n\n    Versions: \n        example/1.2.3 \n        example/4.5.6\n--------------------------------------------------------------------------------\n  For detailed information about a specific \"example\" module (including how to load the modules) use the module's full name. \n  For example:\n\n    module spider example/1.2.3\n--------------------------------------------------------------------------------\n</code></pre> <p>It's also possible to get detailed information about a specific module:</p> <pre><code>$ module spider example/1.2.3\n------------------------------------------------------------------------------------------\n  example: example/1.2.3\n------------------------------------------------------------------------------------------\n  Description: \n    This is just an example \n\n    You will need to load all module(s) on any one of the lines below before the \"example/1.2.3\" module is available to load.\n\n        cluster/doduo \n        cluster/joltik \n        cluster/kirlia \n        cluster/skitty\n        cluster/swalot \n        cluster/victini\nHelp:\n\n        Description \n        =========== \n        This is just an example\n\n        More information \n        ================ \n         - Homepage: https://example.com\n</code></pre>"}, {"location": "running_batch_jobs/#get-detailed-info", "title": "Get detailed info", "text": "<p>To get a list of all possible commands, type:</p> <pre><code>$ module help\n</code></pre> <p>Or to get more information about one specific module package:</p> <pre><code>$ module help example/1.2.3\n----------- Module Specific Help for 'example/1.2.3' --------------------------- \n  This is just an example - Homepage: https://example.com/\n</code></pre>"}, {"location": "running_batch_jobs/#save-and-load-collections-of-modules", "title": "Save and load collections of modules", "text": "<p>If you have a set of modules that you need to load often, you can save these in a collection. This will enable you to load all the modules you need with a single command.</p> <p>In each <code>module</code> command shown below, you can replace <code>module</code> with <code>ml</code>.</p> <p>First, load all modules you want to include in the collections:</p> <pre><code>$ module load example/1.2.3 secondexample/2.7-intel-2016b\n</code></pre> <p>Now store it in a collection using <code>module save</code>. In this example, the collection is named <code>my-collection</code>.</p> <pre><code>$ module save my-collection\n</code></pre> <p>Later, for example in a jobscript or a new session, you can load all these modules with <code>module restore</code>:</p> <pre><code>$ module restore my-collection\n</code></pre> <p>You can get a list of all your saved collections with the <code>module savelist</code> command:</p> <pre><code>$ module savelistr\nNamed collection list (For LMOD_SYSTEM_NAME = \"CO7-sandybridge\"):\n  1) my-collection\n</code></pre> <p>To get a list of all modules a collection will load, you can use the <code>module describe</code> command:</p> <pre><code>$ module describe my-collection\n1) example/1.2.3                                        6) imkl/11.3.3.210-iimpi-2016b \n2) GCCcore/5.4.0                                        7) intel/2016b \n3) icc/2016.3.210-GCC-5.4.0-2.26                        8) examplelib/1.2-intel-2016b \n4) ifort/2016.3.210-GCC-5.4.0-2.26                      9) secondexample/2.7-intel-2016b \n5) impi/5.1.3.181-iccifort-2016.3.210-GCC-5.4.0-2.26\n</code></pre> <p>To remove a collection, remove the corresponding file in <code>$HOME/.lmod.d</code>:</p> <pre><code>$ rm $HOME/.lmod.d/my-collection\n</code></pre>"}, {"location": "running_batch_jobs/#getting-module-details", "title": "Getting module details", "text": "<p>To see how a module would change the environment, you can use the <code>module show</code> command:</p> <pre><code>$ module show Python/2.7.12-intel-2016b\nwhatis(\"Description: Python is a programming language that lets youwork more quickly and integrate your systems more effectively. - Homepage: http://python.org/ \") \nconflict(\"Python\")\nload(\"intel/2016b\") \nload(\"bzip2/1.0.6-intel-2016b\") \n...\nprepend_path(...)\nsetenv(\"EBEXTSLISTPYTHON\",\"setuptools-23.1.0,pip-8.1.2,nose-1.3.7,numpy-1.11.1,scipy-0.17.1,ytz-2016.4\", ...)\n</code></pre> <p>It's also possible to use the <code>ml show</code> command instead: they are equivalent.</p> <p>Here you can see that the <code>Python/2.7.12-intel-2016b</code> comes with a whole bunch of extensions: <code>numpy</code>, <code>scipy</code>, ...</p> <p>You can also see the modules the <code>Python/2.7.12-intel-2016b</code> module loads: <code>intel/2016b</code>, <code>bzip2/1.0.6-intel-2016b</code>, ...</p> <p>If you're not sure what all of this means: don't worry, you don't have to know; just load the module and try to use the software.</p>"}, {"location": "running_batch_jobs/#getting-system-information-about-the-hpc-infrastructure", "title": "Getting system information about the HPC infrastructure", "text": ""}, {"location": "running_batch_jobs/#checking-the-general-status-of-the-hpc-infrastructure", "title": "Checking the general status of the HPC infrastructure", "text": "<p>To check the general system state, check https://www.ugent.be/hpc/en/infrastructure/status. This has information about scheduled downtime, status of the system, ...</p>"}, {"location": "running_batch_jobs/#getting-cluster-state", "title": "Getting cluster state", "text": "<p>You can check http://hpc.ugent.be/clusterstate to see information about the clusters: you can see the nodes that are down, free, partially filled with jobs, completely filled with jobs, ....</p> <p>You can also get this information in text form (per cluster separately) with the <code>pbsmon</code> command:</p> <pre><code>$ module swap cluster /kirlia\n$ pbsmon\n 3401 3402 3403 3404 3405 3406 3407\n    J    j    j    J    J    j    J\n\n 3408 3409 3410 3411 3412 3413 3414\n    J    J    J    J    J    J    J\n\n 3415 3416\n    J    J\n\n   _ free                 : 0   |   X down                 : 0   |\n   j partial              : 3   |   x down_on_error        : 0   |\n   J full                 : 13  |   m maintenance          : 0   |\n                                |   . offline              : 0   |\n                                |   o other (R, *, ...)    : 0   |\n\nNode type:\n ppn=36, mem=751GB\n</code></pre> <p><code>pbsmon</code> only outputs details of the cluster corresponding to the currently loaded <code>cluster</code> module see the section on Specifying the cluster on which to run. It also shows details about the nodes in a cluster. In the example, all nodes have 36 cores and 751 GB of memory.</p>"}, {"location": "running_batch_jobs/#defining-and-submitting-your-job", "title": "Defining and submitting your job", "text": "<p>Usually, you will want to have your program running in batch mode, as opposed to interactively as you may be accustomed to. The point is that the program must be able to start and run without user intervention, i.e., without you having to enter any information or to press any buttons during program execution. All the necessary input or required options have to be specified on the command line, or needs to be put in input or configuration files.</p> <p>As an example, we will run a Perl script, which you will find in the examples subdirectory on the HPC. When you received an account to the HPC a subdirectory with examples was automatically generated for you.</p> <p>Remember that you have copied the contents of the HPC examples directory to your home directory, so that you have your own personal copy (editable and over-writable) and that you can start using the examples. If you haven't done so already, run these commands now:</p> <pre><code>$ cd\n$ cp -r /apps/gent/tutorials/Intro-HPC/examples ~/\n</code></pre> <p>First go to the directory with the first examples by entering the command:</p> <pre><code>$ cd ~/examples/Running-batch-jobs\n</code></pre> <p>Each time you want to execute a program on the HPC you'll need 2 things:</p> <p>The executable  The program to execute from the end-user, together with its     peripheral input files, databases and/or command options.</p> <p>A batch job script , which will define the computer resource requirements of the     program, the required additional software packages and which will     start the actual executable. The HPC needs to know:</p> <pre><code>1.  the type of compute nodes;\n\n2.  the number of CPUs;\n\n3.  the amount of memory;\n\n4.  the expected duration of the execution time (wall time: Time as\n    measured by a clock on the wall);\n\n5.  the name of the files which will contain the output (i.e.,\n    stdout) and error (i.e., stderr) messages;\n\n6.  what executable to start, and its arguments.\n</code></pre> <p>Later on, the HPC user shall have to define (or to adapt) his/her own job scripts. For now, all required job scripts for the exercises are provided for you in the examples subdirectories.</p> <p>List and check the contents with:</p> <pre><code>$ ls -l\ntotal 512\n-rw-r--r-- 1 vsc40000 193 Sep 11 10:34 fibo.pbs\n-rw-r--r-- 1 vsc40000 609 Sep 11 10:25 fibo.pl\n</code></pre> <p>In this directory you find a Perl script (named \"fibo.pl\") and a job script (named \"fibo.pbs\").</p> <ol> <li> <p>The Perl script calculates the first 30 Fibonacci numbers.</p> </li> <li> <p>The job script is actually a standard Unix/Linux shell script that     contains a few extra comments at the beginning that specify     directives to PBS. These comments all begin with #PBS.</p> </li> </ol> <p>We will first execute the program locally (i.e., on your current login-node), so that you can see what the program does.</p> <p>On the command line, you would run this using:</p> <pre><code>$ ./fibo.pl\n[0] -&gt; 0\n[1] -&gt; 1\n[2] -&gt; 1\n[3] -&gt; 2\n[4] -&gt; 3\n[5] -&gt; 5\n[6] -&gt; 8\n[7] -&gt; 13\n[8] -&gt; 21\n[9] -&gt; 34\n[10] -&gt; 55\n[11] -&gt; 89\n[12] -&gt; 144\n[13] -&gt; 233\n[14] -&gt; 377\n[15] -&gt; 610\n[16] -&gt; 987\n[17] -&gt; 1597\n[18] -&gt; 2584\n[19] -&gt; 4181\n[20] -&gt; 6765\n[21] -&gt; 10946\n[22] -&gt; 17711\n[23] -&gt; 28657\n[24] -&gt; 46368\n[25] -&gt; 75025\n[26] -&gt; 121393\n[27] -&gt; 196418\n[28] -&gt; 317811\n[29] -&gt; 514229\n</code></pre> <p>Remark: Recall that you have now executed the Perl script locally on one of the login-nodes of the HPC cluster. Of course, this is not our final intention; we want to run the script on any of the compute nodes. Also, it is not considered as good practice, if you \"abuse\" the login-nodes for testing your scripts and executables. It will be explained later on how you can reserve your own compute-node (by opening an interactive session) to test your software. But for the sake of acquiring a good understanding of what is happening, you are pardoned for this example since these jobs require very little computing power.</p> <p>The job script contains a description of the job by specifying the command that need to be executed on the compute node:</p> <p>-- fibo.pbs --</p> <pre><code>#!/bin/bash -l\ncd $PBS_O_WORKDIR\n./fibo.pl\n</code></pre> <p>So, jobs are submitted as scripts (bash, Perl, Python, etc.), which specify the parameters related to the jobs such as expected runtime (walltime), e-mail notification, etc. These parameters can also be specified on the command line.</p> <p>This job script that can now be submitted to the cluster's job system for execution, using the qsub (Queue SUBmit) command:</p> <pre><code>$ qsub fibo.pbs\n123456\n</code></pre> <p>The qsub command returns a job identifier on the HPC cluster. The important part is the number (e.g., \"123456 \"); this is a unique identifier for the job and can be used to monitor and manage your job.</p> <p>Remark: the modules that were loaded when you submitted the job will not be loaded when the job is started. You should always specify the <code>module load</code> statements that are required for your job in the job script itself.</p> <p>To faciliate this, you can use a pre-defined module collection which you can restore using <code>module restore</code>, see the section on Save and load collections of modules for more information.</p> <p>Your job is now waiting in the queue for a free workernode to start on.</p> <p>Go and drink some coffee ...\u00a0but not too long. If you get impatient you can start reading the next section for more information on how to monitor jobs in the queue.</p> <p>After your job was started, and ended, check the contents of the directory:</p> <pre><code>$ ls -l\ntotal 768\n-rw-r--r-- 1 vsc40000 vsc40000   44 Feb 28 13:33 fibo.pbs\n-rw------- 1 vsc40000 vsc40000    0 Feb 28 13:33 fibo.pbs.e123456\n-rw------- 1 vsc40000 vsc40000 1010 Feb 28 13:33 fibo.pbs.o123456\n-rwxrwxr-x 1 vsc40000 vsc40000  302 Feb 28 13:32 fibo.pl\n</code></pre> <p>Explore the contents of the 2 new files:</p> <pre><code>$ more fibo.pbs.o123456\n$ more fibo.pbs.e123456\n</code></pre> <p>These files are used to store the standard output and error that would otherwise be shown in the terminal window. By default, they have the same name as that of the PBS script, i.e., \"fibo.pbs\" as base name, followed by the extension \".o\" (output) and \".e\" (error), respectively, and the job number ('123456' for this example). The error file will be empty, at least if all went well. If not, it may contain valuable information to determine and remedy the problem that prevented a successful run. The standard output file will contain the results of your calculation (here, the output of the Perl script)</p>"}, {"location": "running_batch_jobs/#when-will-my-job-start", "title": "When will my job start?", "text": "<p>In practice it's impossible to predict when your job(s) will start, since most currently running jobs will finish before their requested walltime expires, and new jobs by may be submitted by other users that are assigned a higher priority than your job(s).</p> <p>The HPC-UGent infrastructure clusters use a fair-share scheduling policy (see HPC Policies). There is no guarantee on when a job will start, since it depends on a number of factors. One of these factors is the priority of the job, which is determined by:</p> <ul> <li> <p>Historical use: the aim is to balance usage over users, so     infrequent (in terms of total compute time used) users get a higher     priority</p> </li> <li> <p>Requested resources (amount of cores, walltime, memory, ...).     The more resources you request, the more likely it is the job(s) will     have to wait for a while until those resources become available.</p> </li> <li> <p>Time waiting in queue: queued jobs get a higher priority over time.</p> </li> <li> <p>User limits: this avoids having a single user use the entire     cluster. This means that each user can only use a part of the     cluster.</p> </li> <li> <p>Whether or not you are a member of a Virtual Organisation (VO).</p> <p>Each VO gets assigned a fair share target, which has a big impact on the job priority. This is done to let the job scheduler balance usage across different research groups.</p> <p>If you are not a member of a specific VO, you are sharing a fair share target with all other users who are not in a specific VO (which implies being in the (hidden) default VO). This can have a (strong) negative impact on the priority of your jobs compared to the jobs of users who are in a specific VO.</p> <p>See Virtual Organisations for more information on how to join a VO, or request the creation of a new VO if there is none yet for your research group.</p> </li> </ul> <p>Some other factors are how busy the cluster is, how many workernodes are active, the resources (e.g., number of cores, memory) provided by each workernode, ...</p> <p>It might be beneficial to request less resources (e.g., not requesting all cores in a workernode), since the scheduler often finds a \"gap\" to fit the job into more easily.</p> <p>Sometimes it happens that couple of nodes are free and a job would not start. Empty nodes are not necessary empty for your job(s). Just imagine, that an N-node-job (with a higher priority than your waiting job(s)) should run. It is quite unlikely that N nodes would be empty at the same moment to accommodate this job, so while fewer than N nodes are empty, you can see them as being empty. The moment the Nth node becomes empty the waiting N-node-job will consume these N free nodes.</p>"}, {"location": "running_batch_jobs/#specifying-the-cluster-on-which-to-run", "title": "Specifying the cluster on which to run", "text": "<p>To use other clusters, you can swap the <code>cluster</code> module. This is a special module that change what modules are available for you, and what cluster your jobs will be queued in.</p> <p>By default you are working on victini. To switch to, e.g., skitty you need to redefine the environment so you get access to all modules installed on the skitty cluster, and to be able to submit jobs to the skitty scheduler so your jobs will start on skitty instead of the default victini cluster.</p> <pre><code>$ module swap cluster/skitty\n</code></pre> <p>Note: the skitty modules may not work directly on the login nodes, because the login nodes do not have the same architecture as the skitty cluster, they have the same architecture as the victini cluster however, so this is why by default software works on the login nodes. See the section on Running software that is incompatible with host for why this is and how to fix this.</p> <p>To list the available cluster modules, you can use the <code>module avail cluster/</code> command:</p> <pre><code>$ module avail cluster/\n------------------------------------------------------------------------------------ \n/etc/modulefiles/vsc\n------------------------------------------------------------------------------------\n   cluster/doduo (S)    cluster/joltik (S)    cluster/kirlia (S)    \n   cluster/skitty (S)    cluster/swalot (S)    cluster/victini (S,L)\n\n  Where:\n   S:  Module is Sticky, requires --force to unload or purge\n   L:  Module is loaded\n\nIf you need software that is not listed, \nrequest it via https://www.ugent.be/hpc/en/support/software-installation-request\n</code></pre> <p>As indicated in the output above, each <code>cluster</code> module is a so-called sticky module, i.e., it will not be unloaded when <code>module purge</code> (see the section on purging modules) is used.</p> <p>The output of the various commands interacting with jobs (<code>qsub</code>, <code>stat</code>, ...) all depend on which <code>cluster</code> module is loaded.</p>"}, {"location": "running_batch_jobs/#monitoring-and-managing-your-jobs", "title": "Monitoring and managing your job(s)", "text": "<p>Using the job ID that <code>qsub</code> returned, there are various ways to monitor the status of your job. In the following commands, replace <code>12345</code> with the job ID <code>qsub</code> returned.</p> <pre><code>$ qstat 12345\n</code></pre> <p>To show on which compute nodes your job is running, at least, when it is running:</p> <pre><code>$ qstat -n 12345\n</code></pre> <p>To remove a job from the queue so that it will not run, or to stop a job that is already running.</p> <pre><code>$ qdel 12345\n</code></pre> <p>When you have submitted several jobs (or you just forgot about the job ID), you can retrieve the status of all your jobs that are submitted and are not yet finished using:</p> <pre><code>$ qstat\n:\nJob ID      Name    User      Time Use S Queue\n----------- ------- --------- -------- - -----\n123456 ....     mpi  vsc40000     0    Q short\n</code></pre> <p>Here:</p> <p>Job ID      the job's unique identifier</p> <p>Name        the name of the job</p> <p>User        the user that owns the job</p> <p>Time Use    the elapsed walltime for the job</p> <p>Queue       the queue the job is in</p> <p>The state S can be any of the following:</p>  State Meaning Q The job is queued and is waiting to start. R The job is currently running. E The job is currently exit after having run. C The job is completed after having run. H The job has a user or system hold on it and will not be eligible to run until the hold is removed. <p>User hold means that the user can remove the hold. System hold means that the system or an administrator has put the job on hold, very likely because something is wrong with it. Check with your helpdesk to see why this is the case.</p>"}, {"location": "running_batch_jobs/#examining-the-queue", "title": "Examining the queue", "text": "<p>There is currently (since May 2019) no way to get an overall view of the state of the cluster queues for the HPC-UGent infrastructure infrastructure, due to changes to the cluster resource management software (and also because a general overview is mostly meaningless since it doesn't give any indication of the resources requested by the queued jobs).</p>"}, {"location": "running_batch_jobs/#specifying-job-requirements", "title": "Specifying job requirements", "text": "<p>Without giving more information about your job upon submitting it with qsub, default values will be assumed that are almost never appropriate for real jobs.</p> <p>It is important to estimate the resources you need to successfully run your program, such as the amount of time the job will require, the amount of memory it needs, the number of CPUs it will run on, etc. This may take some work, but it is necessary to ensure your jobs will run properly.</p>"}, {"location": "running_batch_jobs/#generic-resource-requirements", "title": "Generic resource requirements", "text": "<p>The qsub command takes several options to specify the requirements, of which we list the most commonly used ones below.</p> <pre><code>$ qsub -l walltime=2:30:00\n</code></pre> <p>For the simplest cases, only the amount of maximum estimated execution time (called \"walltime\") is really important. Here, the job requests 2 hours, 30 minutes. As soon as the job exceeds the requested walltime, it will be \"killed\" (terminated) by the job scheduler. There is no harm if you slightly overestimate the maximum execution time. If you omit this option, the queue manager will not complain but use a default value (one hour on most clusters).</p> <p>The maximum walltime for HPC-UGent clusters is 72 hours.</p> <p>If you want to run some final steps (for example to copy files back) before the walltime kills your main process, you have to kill the main command yourself before the walltime runs out and then copy the file back. See the section on Running a command with a maximum time limit for how to do this.</p> <pre><code>$ qsub -l mem=4gb\n</code></pre> <p>The job requests 4 GB of RAM memory. As soon as the job tries to use more memory, it will be \"killed\" (terminated) by the job scheduler. There is no harm if you slightly overestimate the requested memory.</p> <p>The default memory reserved for a job on any given HPC-UGent cluster is the \"usable memory per node\" divided by the \"numbers of cores in a node\" multiplied by the requested processor core(s) (ppn). Jobs will request the default memory without defining memory for the job, either as a command line option or as a memory directive in the job script. Please note that using the default memory is recommended. For \"usable memory per node\" and \"number of cores in a node\" please consult https://www.ugent.be/hpc/en/infrastructure.</p> <pre><code>$ qsub -l nodes=5:ppn=2\n</code></pre> <p>The job requests 5 compute nodes with two cores on each node (ppn stands for \"processors per node\", where \"processors\" here actually means \"CPU cores\").</p> <pre><code>$ qsub -l nodes=1:westmere\n</code></pre> <p>The job requests just one node, but it should have an Intel Westmere processor. A list with site-specific properties can be found in the next section or in the User Portal (\"VSC hardware\" section)1 of the VSC website.</p> <p>These options can either be specified on the command line, e.g.</p> <pre><code>$ qsub -l nodes=1:ppn,mem=2gb fibo.pbs\n</code></pre> <p>or in the job script itself using the #PBS-directive, so \"fibo.pbs\" could be modified to:</p> <pre><code>#!/bin/bash -l\n#PBS -l nodes=1:ppn=1\n#PBS -l mem=2gb\ncd $PBS_O_WORKDIR\n./fibo.pl\n</code></pre> <p>Note that the resources requested on the command line will override those specified in the PBS file.</p>"}, {"location": "running_batch_jobs/#job-output-and-error-files", "title": "Job output and error files", "text": "<p>At some point your job finishes, so you may no longer see the job ID in the list of jobs when you run qstat (since it will only be listed for a few minutes after completion with state \"C\"). After your job finishes, you should see the standard output and error of your job in two files, located by default in the directory where you issued the qsub command.</p> <p>When you navigate to that directory and list its contents, you should see them:</p> <pre><code>$ ls -l\ntotal 1024\n-rw-r--r-- 1 vsc40000  609 Sep 11 10:54 fibo.pl\n-rw-r--r-- 1 vsc40000   68 Sep 11 10:53 fibo.pbs\n-rw------- 1 vsc40000   52 Sep 11 11:03 fibo.pbs.e123456\n-rw------- 1 vsc40000 1307 Sep 11 11:03 fibo.pbs.o123456\n</code></pre> <p>In our case, our job has created both output ('fibo.pbs.') and error files ('fibo.pbs.') containing info written to stdout and stderr respectively.</p> <p>Inspect the generated output and error files:</p> <pre><code>$ cat fibo.pbs.o123456\n...\n$ cat fibo.pbs.e123456\n...\n</code></pre>"}, {"location": "running_batch_jobs/#e-mail-notifications", "title": "E-mail notifications", "text": ""}, {"location": "running_batch_jobs/#generate-your-own-e-mail-notifications", "title": "Generate your own e-mail notifications", "text": "<p>You can instruct the HPC to send an e-mail to your e-mail address whenever a job begins, ends and/or aborts, by adding the following lines to the job script <code>fibo.pbs</code>:</p> <pre><code>#PBS -m b \n#PBS -m e \n#PBS -m a\n</code></pre> <p>or</p> <pre><code>#PBS -m abe\n</code></pre> <p>These options can also be specified on the command line. Try it and see what happens:</p> <pre><code>$ qsub -m abe fibo.pbs\n</code></pre> <p>The system will use the e-mail address that is connected to your VSC account. You can also specify an alternate e-mail address with the <code>-M</code> option:</p> <pre><code>$ qsub -m b -M john.smith@example.com fibo.pbs\n</code></pre> <p>will send an e-mail to john.smith@example.com when the job begins.</p>"}, {"location": "running_batch_jobs/#running-a-job-after-another-job", "title": "Running a job after another job", "text": "<p>If you submit two jobs expecting that should be run one after another (for example because the first generates a file the second needs), there might be a problem as they might both be run at the same time.</p> <p>So the following example might go wrong:</p> <pre><code>$ qsub job1.sh\n$ qsub job2.sh\n</code></pre> <p>You can make jobs that depend on other jobs. This can be useful for breaking up large jobs into smaller jobs that can be run in a pipeline. The following example will submit 2 jobs, but the second job (<code>job2.sh</code>) will be held (<code>H</code> status in <code>qstat</code>) until the first job successfully completes. If the first job fails, the second will be cancelled.</p> <pre><code>$ FIRST_ID=$ (qsub job1.sh)\n$ qsub -W depend=afterok:$FIRST_ID job2.sh\n</code></pre> <p><code>afterok</code> means \"After OK\", or in other words, after the first job successfully completed.</p> <p>It's also possible to use <code>afternotok</code> (\"After not OK\") to run the second job only if the first job exited with errors. A third option is to use <code>afterany</code> (\"After any\"), to run the second job after the first job (regardless of success or failure).</p> <ol> <li> <p>URL: https://vscdocumentation.readthedocs.io/en/latest/hardware.html \u21a9</p> </li> </ol>"}, {"location": "running_interactive_jobs/", "title": "Running interactive jobs", "text": ""}, {"location": "running_interactive_jobs/#introduction", "title": "Introduction", "text": "<p>Interactive jobs are jobs which give you an interactive session on one of the compute nodes. Importantly, accessing the compute nodes this way means that the job control system guarantees the resources that you have asked for.</p> <p>Interactive PBS jobs are similar to non-interactive PBS jobs in that they are submitted to PBS via the command qsub. Where an interactive job differs is that it does not require a job script, the required PBS directives can be specified on the command line.</p> <p>Interactive jobs can be useful to debug certain job scripts or programs, but should not be the main use of the HPC-UGent infrastructure. Waiting for user input takes a very long time in the life of a CPU and does not make efficient usage of the computing resources.</p> <p>The syntax for qsub for submitting an interactive PBS job is:</p> <pre><code>$ qsub -I &lt;... pbs directives ...&gt;\n</code></pre>"}, {"location": "running_interactive_jobs/#interactive-jobs-without-x-support", "title": "Interactive jobs, without X support", "text": "<p>Tip</p> <p>Find the code in \"~/examples/Running_interactive_jobs\"</p> <p>First of all, in order to know on which computer you're working, enter:</p> <pre><code>$ hostname -f\ngligar07.gastly.os\n</code></pre> <p>This means that you're now working on the login node <code>gligar07.gastly.os</code> of the cluster.</p> <p>The most basic way to start an interactive job is the following:</p> <pre><code>$ qsub -I\nqsub: waiting for job 123456 to start\nqsub: job 123456 ready\n</code></pre> <p>There are two things of note here.</p> <ol> <li> <p>The \"qsub\" command (with the interactive -I flag) waits until a     node is assigned to your interactive session, connects to the     compute node and shows you the terminal prompt on that node.</p> </li> <li> <p>You'll see that your directory structure of your home directory has     remained the same. Your home directory is actually located on a     shared storage system. This means that the exact same directory is     available on all login nodes and all compute nodes on all clusters.</p> </li> </ol> <p>In order to know on which compute-node you're working, enter again:</p> <pre><code>$ hostname -f\nnode3200.victini.gent.vsc\n</code></pre> <p>Note that we are now working on the compute-node called \"node3200.victini.gent.vsc\". This is the compute node, which was assigned to us by the scheduler after issuing the \"qsub -I\" command.</p> <p>Now, go to the directory of our second interactive example and run the program \"primes.py\". This program will ask you for an upper limit ($&gt; 1$) and will print all the primes between 1 and your upper limit:</p> <pre><code>$ cd ~/examples/Running_interactive_jobs\n$ ./primes.py\nThis program calculates all primes between 1 and your upper limit.\nEnter your upper limit (&gt;1): 50\nStart Time:  2013-09-11 15:49:06\n[Prime#1] = 1\n[Prime#2] = 2\n[Prime#3] = 3\n[Prime#4] = 5\n[Prime#5] = 7\n[Prime#6] = 11\n[Prime#7] = 13\n[Prime#8] = 17\n[Prime#9] = 19\n[Prime#10] = 23\n[Prime#11] = 29\n[Prime#12] = 31\n[Prime#13] = 37\n[Prime#14] = 41\n[Prime#15] = 43\n[Prime#16] = 47\nEnd Time:  2013-09-11 15:49:06\nDuration:  0 seconds.\n</code></pre> <p>You can exit the interactive session with:</p> <pre><code>$ exit\n</code></pre> <p>Note that you can now use this allocated node for 1 hour. After this hour you will be automatically disconnected. You can change this \"usage time\" by explicitly specifying a \"walltime\", i.e., the time that you want to work on this node. (Think of walltime as the time elapsed when watching the clock on the wall.)</p> <p>You can work for 3 hours by:</p> <pre><code>$ qsub -I -l walltime=03:00:00\n</code></pre> <p>If the walltime of the job is exceeded, the (interactive) job will be killed and your connection to the compute node will be closed. So do make sure to provide adequate walltime and that you save your data before your (wall)time is up (exceeded)! When you do not specify a walltime, you get a default walltime of 1 hour.</p>"}, {"location": "running_interactive_jobs/#interactive-jobs-with-graphical-support", "title": "Interactive jobs, with graphical support", "text": ""}, {"location": "running_interactive_jobs/#software-installation", "title": "Software Installation", "text": "<p>To display graphical applications from a Linux computer (such as the VSC clusters) on your machine, you need to install an X Window server on your local computer.</p> <p>The X Window system (commonly known as X11, based on its current major version being 11, or shortened to simply X) is the system-level software infrastructure for the windowing GUI on Linux, BSD and other UNIX-like operating systems. It was designed to handle both local displays, as well as displays sent across a network. More formally, it is a computer software system and network protocol that provides a basis for graphical user interfaces (GUIs) and rich input device capability for networked computers.</p> <p>Download the latest version of the XQuartz package on: http://xquartz.macosforge.org/landing/ and install the XQuartz.pkg package.</p> <p> </p> <p>The installer will take you through the installation procedure, just continue clicking Continue on the various screens that will pop-up until your installation was successful.</p> <p>A reboot is required before XQuartz will correctly open graphical applications.</p> <p> </p>"}, {"location": "running_interactive_jobs/#run-simple-example", "title": "Run simple example", "text": "<p>We have developed a little interactive program that shows the communication in 2 directions. It will send information to your local screen, but also asks you to click a button.</p> <p>Now run the message program:</p> <pre><code>$ cd ~/examples/Running_interactive_jobs\n./message.py\n</code></pre> <p>You should see the following message appearing.</p> <p> </p> <p>Click any button and see what happens.</p> <pre><code>-----------------------\n&lt; Enjoy the day! Mooh &gt;\n-----------------------\n     ^__^\n     (oo)\\_______\n     (__)\\       )\\/\\\n         ||----w |\n         ||     ||\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/", "title": "Running jobs with input/output data", "text": "<p>You have now learned how to start a batch job and how to start an interactive session. The next question is how to deal with input and output files, where your standard output and error messages will go to and where that you can collect your results.</p>"}, {"location": "running_jobs_with_input_output_data/#the-current-directory-and-output-and-error-files", "title": "The current directory and output and error files", "text": ""}, {"location": "running_jobs_with_input_output_data/#default-file-names", "title": "Default file names", "text": "<p>First go to the directory:</p> <pre><code>$ cd ~/examples/Running_jobs_with_input_output_data\n</code></pre> <p>List and check the contents with:</p> <pre><code>ls -l\ntotal 2304\n-rwxrwxr-x 1 vsc40000   682 Sep 13 11:34 file1.py\n-rw-rw-r-- 1 vsc40000   212 Sep 13 11:54 file1a.pbs\n-rw-rw-r-- 1 vsc40000   994 Sep 13 11:53 file1b.pbs\n-rw-rw-r-- 1 vsc40000   994 Sep 13 11:53 file1c.pbs\n-rw-r--r-- 1 vsc40000  1393 Sep 13 10:41 file2.pbs\n-rwxrwxr-x 1 vsc40000  2393 Sep 13 10:40 file2.py\n-rw-r--r-- 1 vsc40000  1393 Sep 13 10:41 file3.pbs\n-rwxrwxr-x 1 vsc40000  2393 Sep 13 10:40 file3.py\n</code></pre> <p>Now, let us inspect the contents of the first executable (which is just a Python script with execute permission).</p> <p>-- file1.py -- <pre><code>#!/usr/bin/env python\n#\n# VSC        : Flemish Supercomputing Centre\n# Tutorial   : Introduction to HPC\n# Description: Writing to the current directory, stdout and stderr\n#\nimport sys\n\n# Step #1: write to a local file in your current directory\nlocal_f = open(\"Hello.txt\", 'w+')\nlocal_f.write(\"Hello World!\\n\")\nlocal_f.write(\"I am writing in the file:&lt;Hello.txt&gt;.\\n\")\nlocal_f.write(\"in the current directory.\\n\")\nlocal_f.write(\"Cheers!\\n\")\nlocal_f.close()\n\n# Step #2: Write to stdout\nsys.stdout.write(\"Hello World!\\n\")\nsys.stdout.write(\"I am writing to &lt;stdout&gt;.\\n\")\nsys.stdout.write(\"Cheers!\\n\")\n\n# Step #3: Write to stderr\nsys.stderr.write(\"Hello World!\\n\")\nsys.stderr.write(\"This is NO ERROR or WARNING.\\n\")\nsys.stderr.write(\"I am just writing to &lt;stderr&gt;.\\n\")\nsys.stderr.write(\"Cheers!\\n\")\n</code></pre></p> <p>The code of the Python script, is self explanatory:</p> <ol> <li> <p>In step 1, we write something to the file <code>hello.txt</code> in the current     directory.</p> </li> <li> <p>In step 2, we write some text to stdout.</p> </li> <li> <p>In step 3, we write to stderr.</p> </li> </ol> <p>Check the contents of the first job script:</p> <p>-- file1a.pbs -- <pre><code>#!/bin/bash\n\n#PBS -l walltime=00:05:00\n\n# go to the (current) working directory (optional, if this is the\n# directory where you submitted the job)\ncd $PBS_O_WORKDIR  # the program itself\necho Start Job\ndate\n./file1.py\necho End Job\n</code></pre></p> <p>You'll see that there are NO specific PBS directives for the placement of the output files. All output files are just written to the standard paths.</p> <p>Submit it:</p> <pre><code>$ qsub file1a.pbs\n</code></pre> <p>After the job has finished, inspect the local directory again, i.e., the directory where you executed the qsub command:</p> <pre><code>ls -l\ntotal 3072\n-rw-rw-r-- 1 vsc40000   90 Sep 13 13:13 Hello.txt\n-rwxrwxr-x 1 vsc40000  693 Sep 13 13:03 file1.py*\n-rw-rw-r-- 1 vsc40000  229 Sep 13 13:01 file1a.pbs\n-rw------- 1 vsc40000   91 Sep 13 13:13 file1a.pbs.e123456\n-rw------- 1 vsc40000  105 Sep 13 13:13 file1a.pbs.o123456\n-rw-rw-r-- 1 vsc40000  143 Sep 13 13:07 file1b.pbs\n-rw-rw-r-- 1 vsc40000  177 Sep 13 13:06 file1c.pbs\n-rw-r--r-- 1 vsc40000 1393 Sep 13 10:41 file2.pbs\n-rwxrwxr-x 1 vsc40000 2393 Sep 13 10:40 file2.py*\n-rw-r--r-- 1 vsc40000 1393 Sep 13 10:41 file3.pbs\n-rwxrwxr-x 1 vsc40000 2393 Sep 13 10:40 file3.py*\n</code></pre> <p>Some observations:</p> <ol> <li> <p>The file <code>Hello.txt</code> was created in the current directory.</p> </li> <li> <p>The file <code>file1a.pbs.o123456</code> contains all the text that was written to     the standard output stream (\"stdout\").</p> </li> <li> <p>The file <code>file1a.pbs.e123456</code> contains all the text that was written to     the standard error stream (\"stderr\").</p> </li> </ol> <p>Inspect their contents ...\u00a0and remove the files</p> <pre><code>$ cat Hello.txt\n$ cat file1a.pbs.o123456\n$ cat file1a.pbs.e123456\n$ rm Hello.txt file1a.pbs.o123456 file1a.pbs.e123456\n</code></pre> <p>Tip</p> <p>Type <code>cat H</code> and press the Tab button (looks like Tab), and it expand will into <code>cat Hello.txt</code>.</p>"}, {"location": "running_jobs_with_input_output_data/#filenames-using-the-name-of-the-job", "title": "Filenames using the name of the job", "text": "<p>Check the contents of the job script and execute it.</p> <p>-- file1b.pbs -- <pre><code>#!/bin/bash\n\n#   Specify the \"name\" of the job\n#PBS -N my_serial_job         \n\ncd $PBS_O_WORKDIR  echo Start Job\ndate\n./file1.py\necho End Job\n</code></pre></p> <p>Inspect the contents again ...\u00a0and remove the generated files:</p> <pre><code>$ ls\nHello.txt file1a.pbs file1c.pbs file2.pbs file3.pbs my_serial_job.e123456\nfile1.py* file1b.pbs file2.py* file3.py* my_serial_job.o123456\n$ rm Hello.txt my_serial_job.*\n</code></pre> <p>Here, the option \"<code>-N</code>\" was used to explicitly assign a name to the job. This overwrote the JOBNAME variable, and resulted in a different name for the stdout and stderr files. This name is also shown in the second column of the \"<code>qstat</code>\" command. If no name is provided, it defaults to the name of the job script.</p>"}, {"location": "running_jobs_with_input_output_data/#user-defined-file-names", "title": "User-defined file names", "text": "<p>You can also specify the name of stdout and stderr files explicitly by adding two lines in the job script, as in our third example:</p> <p>-- file1c.pbs -- <pre><code>#!/bin/bash\n\n# redirect standard output (-o) and error (-e)\n#PBS -o stdout.$PBS_JOBID\n#PBS -e stderr.$PBS_JOBID\n\ncd $PBS_O_WORKDIR  echo Start Job\ndate\n./file1.py\necho End Job\n</code></pre></p>"}, {"location": "running_jobs_with_input_output_data/#where-to-store-your-data-on-the-hpc", "title": "Where to store your data on the HPC", "text": "<p>The HPC cluster offers their users several locations to store their data. Most of the data will reside on the shared storage system, but all compute nodes also have their own (small) local disk.</p>"}, {"location": "running_jobs_with_input_output_data/#pre-defined-user-directories", "title": "Pre-defined user directories", "text": "<p>Three different pre-defined user directories are available, where each directory has been created for different purposes. The best place to store your data depends on the purpose, but also the size and type of usage of the data.</p> <p>The following locations are available:</p> Variable Description Long-term storage slow filesystem, intended for smaller files $VSC_HOME              For your configuration files and other small files, see the section on your home directory.             The default directory is user/Gent/xxx/vsc40000.             The same file system is accessible from all sites, i.e., you'll see the same contents in $VSC_HOME on all sites.          $VSC_DATA              A bigger \"workspace\", for datasets, results, logfiles, etc. see the section on your data directory.             The default directory is data/Gent/xxx/vsc40000.             The same file system is accessible from all sites.          Fast temporary storage $VSC_SCRATCH_NODE              For temporary or transient data on the local compute node, where fast access is important; see the section on your scratch space.             This space is available per node. The default directory is /tmp. On different nodes, you'll see different content.          $VSC_SCRATCH              For temporary or transient data that has to be accessible from all nodes of a cluster (including the login nodes)              The default directory is scratch/Gent/xxx/vsc40000. This directory is cluster- or site-specific: On different sites, and sometimes on different clusters on the same site, you'll get a different directory with different content.          $VSC_SCRATCH_SITE              Currently the same as $VSC_SCRATCH, but could be used for a scratch space shared accross all clusters at a site in the future. See the section on your scratch space. $VSC_SCRATCH_GLOBAL              Currently the same as $VSC_SCRATCH, but could be used for a scratch space shared accross all clusters of the VSC in the future. See the section on your scratch space. $VSC_SCRATCH_CLUSTER              The scratch filesystem closest to the cluster.          $VSC_SCRATCH_ARCANINE              A separate (smaller) shared scratch filesystem, powered by SSDs. This scratch filesystem is intended for very I/O-intensive workloads. Note that this filesystem is not available on the cluster victini.          <p>Since these directories are not necessarily mounted on the same locations over all sites, you should always (try to) use the environment variables that have been created.</p> <p>We elaborate more on the specific function of these locations in the following sections.</p> <p>Note: <code>$VSC_SCRATCH_KYUKON</code> and <code>$VSC_SCRATCH</code> are the same directories (\"kyukon\" is the name of the storage cluster where the default shared scratch filesystem is hosted).</p> <p>For documentation about VO directories, see the section on VO directories.</p>"}, {"location": "running_jobs_with_input_output_data/#your-home-directory-vsc_home", "title": "Your home directory ($VSC_HOME)", "text": "<p>Your home directory is where you arrive by default when you login to the cluster. Your shell refers to it as \"~\" (tilde), and its absolute path is also stored in the environment variable $VSC_HOME. Your home directory is shared across all clusters of the VSC.</p> <p>The data stored here should be relatively small (e.g., no files or directories larger than a few megabytes), and preferably should only contain configuration files. Note that various kinds of configuration files are also stored here, e.g., by MATLAB, Eclipse, ...</p> <p>The operating system also creates a few files and folders here to manage your account. Examples are:</p> File or Directory Description .ssh/ This directory contains some files necessary for you to login to the cluster and to submit jobs on the cluster. Do not remove them, and do not alter anything if you don't know what you are doing! .bash_profile When you login (type username and password) remotely via ssh, .bash_profile is executed to configure your shell before the initial command prompt. .bashrc This script is executed every time you start a session on the cluster: when you login to the cluster and when a job starts. .bash_history This file contains the commands you typed at your shell prompt, in case you need them again."}, {"location": "running_jobs_with_input_output_data/#your-data-directory-vsc_data", "title": "Your data directory ($VSC_DATA)", "text": "<p>In this directory you can store all other data that you need for longer terms (such as the results of previous jobs, ...). It is a good place for, e.g., storing big files like genome data.</p> <p>The environment variable pointing to this directory is $VSC_DATA. This volume is shared across all clusters of the VSC. There are however no guarantees about the speed you will achieve on this volume. For guaranteed fast performance and very heavy I/O, you should use the scratch space instead. </p> <p>If you are running out of quota on your _$VSC_DATA filesystem you can request a VO. See on how to do this.</p>"}, {"location": "running_jobs_with_input_output_data/#your-scratch-space-vsc_scratch", "title": "Your scratch space ($VSC_SCRATCH)", "text": "<p>To enable quick writing from your job, a few extra file systems are available on the compute nodes. These extra file systems are called scratch folders, and can be used for storage of temporary and/or transient data (temporary results, anything you just need during your job, or your batch of jobs).</p> <p>You should remove any data from these systems after your processing them has finished. There are no guarantees about the time your data will be stored on this system, and we plan to clean these automatically on a regular base. The maximum allowed age of files on these scratch file systems depends on the type of scratch, and can be anywhere between a day and a few weeks. We don't guarantee that these policies remain forever, and may change them if this seems necessary for the healthy operation of the cluster.</p> <p>Each type of scratch has its own use:</p> <p>Node scratch ($VSC_SCRATCH_NODE).   Every node has its own scratch space, which is completely separated     from the other nodes. On some clusters, it will be on a local disk     in the node, while on other clusters it will be emulated through     another file server. In many cases, it will be significantly slower     than the cluster scratch as it typically consists of just a single     disk. Some drawsbacks are that the storage can only be accessed on that     particular node and that the capacity is often very limited (e.g.,     100 GB). The performance will depend a lot on the particular     implementation in the cluster. In many cases, it will be     significantly slower than the cluster scratch as it typically     consists of just a single disk. However, if that disk is local to     the node (as on most clusters), the performance will not depend on     what others are doing on the cluster.</p> <p>Cluster scratch ($VSC_SCRATCH).  To allow a job running on multiple nodes (or multiple jobs running     on separate nodes) to share data as files, every node of the cluster     (including the login nodes) has access to this shared scratch     directory. Just like the home and data directories, every user has     its own scratch directory. Because this scratch is also available     from the login nodes, you could manually copy results to your data     directory after your job has ended. Also, this type of scratch is     usually implemented by running tens or hundreds of disks in parallel     on a powerful file server with fast connection to all the cluster     nodes and therefore is often the fastest file system available on a     cluster.     You may not get the same file system on different clusters, i.e.,     you may see different content on different clusters at the same     institute. </p> <p>Site scratch ($VSC_SCRATCH_SITE).  At the time of writing, the site scratch is just the same volume as     the cluster scratch, and thus contains the same data. In the future     it may point to a different scratch file system that is available     across all clusters at a particular site, which is in fact the case     for the cluster scratch on some sites.</p> <p>Global scratch ($VSC_SCRATCH_GLOBAL).   At the time of writing, the global scratch is just the same volume     as the cluster scratch, and thus contains the same data. In the     future it may point to a scratch file system that is available     across all clusters of the VSC, but at the moment of writing there     are no plans to provide this.</p>"}, {"location": "running_jobs_with_input_output_data/#your-ugent-home-drive-and-shares", "title": "Your UGent home drive and shares", "text": "<p>In order to access data on your UGent share(s), you need to stage-in the data and stage-out afterwards. On the login nodes, it is possible to access your UGent home drive and shares. To allow this you need a ticket. This requires that you first authenticate yourself with your UGent username and password by running:</p> <pre><code>$ kinit yourugentusername@UGENT.BE\nPassword for yourugentusername@UGENT.BE:\n</code></pre> <p>Now you should be able to access your files running</p> <pre><code>$ ls /UGent/yourugentusername\nhome shares www\n</code></pre> <p>Please note the shares will only be mounted when you access this folder. You should specify your complete username - tab completion will not work.</p> <p>If you want to use the UGent shares longer than 24 hours, you should ask a ticket for up to a week by running</p> <pre><code>$ kinit yourugentusername@UGENT.BE -r 7d\n</code></pre> <p>You can verify your authentication ticket and expiry dates yourself by running klist</p> <pre><code>$ klist\n...\nValid starting     Expires            Service principal\n14/07/20 15:19:13  15/07/20 01:19:13  krbtgt/UGENT.BE@UGENT.BE\n    renew until 21/07/20 15:19:13\n\n</code></pre> <p>Your ticket is valid for 10 hours, but you can renew it before it expires.</p> <p>To renew your tickets, simply run</p> <pre><code>$ kinit -R\n</code></pre> <p>If you want your ticket to be renewed automatically up to the maximum expiry date, you can run</p> <pre><code>$ krenew -b -K 60\n</code></pre> <p>Each hour the process will check if your ticket should be renewed.</p> <p>We strongly advise to disable access to your shares once it is no longer needed:</p> <pre><code>$ kdestroy\n</code></pre> <p>If you get an error \"Unknown credential cache type while getting default ccache\" (or similar) and you use , then please deactivate conda before you use the commands in this chapter.</p> <pre><code>$ conda deactivate\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#ugent-shares-with-globus", "title": "UGent shares with globus", "text": "<p>In order to access your UGent home and shares inside the globus endpoint, you first have to generate authentication credentials on the endpoint. To do that, you have to ssh to the globus endpoint from a loginnode. You will be prompted for your UGent username and password to authenticate:</p> <pre><code>$ ssh globus\nUGent username:ugentusername\nPassword for ugentusername@UGENT.BE:\nShares are available in globus endpoint at /UGent/ugentusername/\nOverview of valid tickets:\nTicket cache: KEYRING:persistent:xxxxxxx:xxxxxxx\nDefault principal: ugentusername@UGENT.BE\n\nValid starting     Expires            Service principal\n29/07/20 15:56:43  30/07/20 01:56:43  krbtgt/UGENT.BE@UGENT.BE\n    renew until 05/08/20 15:56:40\nTickets will be automatically renewed for 1 week\nConnection to globus01 closed.\n</code></pre> <p>Your shares will then be available at /UGent/ugentusername/ under the globus VSC tier2 endpoint. Tickets will be renewed automatically for 1 week, after which you'll need to run this again. We advise to disable access to your shares within globus once access is no longer needed:</p> <pre><code>$ ssh globus01 destroy\nSuccesfully destroyed session\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#pre-defined-quotas", "title": "Pre-defined quotas", "text": "<p>Quota is enabled on these directories, which means that the amount of data you can store there is limited. This holds for both the total size of all files as well as the total number of files that can be stored. The system works with a soft quota and a hard quota. You can temporarily exceed the soft quota, but you can never exceed the hard quota. The user will get warnings as soon as he exceeds the soft quota.</p> <p>To see your a list of your current quota, visit the VSC accountpage: https://account.vscentrum.be. VO moderators can see a list of VO quota usage per member of their VO via https://account.vscentrum.be/django/vo/.</p> <p>The rules are:</p> <ol> <li> <p>You will only receive a warning when you have reached the soft limit     of either quota.</p> </li> <li> <p>You will start losing data and get I/O errors when you reach the     hard limit. In this case, data loss will occur since nothing can be     written anymore (this holds both for new files as well as for     existing files), until you free up some space by removing some     files. Also note that you will not be warned when data loss     occurs, so keep an eye open for the general quota warnings!</p> </li> <li> <p>The same holds for running jobs that need to write files: when you     reach your hard quota, jobs will crash.</p> </li> </ol> <p>We do realise that quota are often observed as a nuisance by users, especially if you're running low on it. However, it is an essential feature of a shared infrastructure. Quota ensure that a single user cannot accidentally take a cluster down (and break other user's jobs) by filling up the available disk space. And they help to guarantee a fair use of all available resources for all users. Quota also help to ensure that each folder is used for its intended purpose.</p>"}, {"location": "running_jobs_with_input_output_data/#writing-output-files", "title": "Writing Output files", "text": "<p>Tip</p> <p>Find the code of the exercises in \"~/examples/Running_jobs_with_input_output_data\"</p> <p>In the next exercise, you will generate a file in the $VSC_SCRATCH directory. In order to generate some CPU- and disk-I/O load, we will</p> <ol> <li> <p>take a random integer between 1 and 2000 and calculate all primes up     to that limit;</p> </li> <li> <p>repeat this action 30.000 times;</p> </li> <li> <p>write the output to the \"<code>primes_1.txt</code>\" output file in the     $VSC_SCRATCH-directory.</p> </li> </ol> <p>Check the Python and the PBS file, and submit the job: Remember that this is already a more serious (disk-I/O and computational intensive) job, which takes approximately 3 minutes on the HPC.</p> <pre><code>$ cat file2.py\n$ cat file2.pbs\n$ qsub file2.pbs\n$ qstat\n$ ls -l\n$ echo $VSC_SCRATCH\n$ ls -l $VSC_SCRATCH\n$ more $VSC_SCRATCH/primes_1.txt\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#reading-input-files", "title": "Reading Input files", "text": "<p>Tip</p> <p>Find the code of the exercise \"<code>file3.py</code>\" in \"~/examples/Running_jobs_with_input_output_data\".</p> <p>In this exercise, you will</p> <ol> <li> <p>Generate the file \"<code>primes_1.txt</code>\" again as in the previous     exercise;</p> </li> <li> <p>open the this file;</p> </li> <li> <p>read it line by line;</p> </li> <li> <p>calculate the average of primes in the line;</p> </li> <li> <p>count the number of primes found per line;</p> </li> <li> <p>write it to the \"<code>primes_2.txt</code>\" output file in the     $VSC_SCRATCH-directory.</p> </li> </ol> <p>Check the Python and the PBS file, and submit the job:</p> <pre><code>$ cat file3.py\n$ cat file3.pbs\n$ qsub file3.pbs\n$ qstat\n$ ls -l\n$ more $VSC_SCRATCH/primes_2.txt\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#how-much-disk-space-do-i-get", "title": "How much disk space do I get?", "text": ""}, {"location": "running_jobs_with_input_output_data/#quota", "title": "Quota", "text": "<p>The available disk space on the HPC is limited. The actual disk capacity, shared by all users, can be found on the \"Available hardware\" page on the website. (https://vscdocumentation.readthedocs.io/en/latest/hardware.html) As explained in the section on predefined quota, this implies that there are also limits to:</p> <ul> <li> <p>the amount of disk space; and</p> </li> <li> <p>the number of files</p> </li> </ul> <p>that can be made available to each individual HPC user.</p> <p>The quota of disk space and number of files for each HPC user is:</p> Volume Max. disk space Max. # Files HOME 3 GB 20000 DATA 25 GB 100000 SCRATCH 25 GB 100000 <p>Tip</p> <p>The first action to take when you have exceeded your quota is to clean up your directories. You could start by removing intermediate, temporary or log files. Keeping your environment clean will never do any harm.</p> <p>Tip</p> <p>If you obtained your VSC account via UGent, you can get (significantly) more storage quota in the DATA and SCRATCH volumes by joining a Virtual Organisation (VO), see the section on virtual organisations for more information. In case of questions, contact hpc@ugent.be.</p>"}, {"location": "running_jobs_with_input_output_data/#check-your-quota", "title": "Check your quota", "text": "<p>You can consult your current storage quota usage on the HPC-UGent infrastructure shared filesystems via the VSC accountpage, see the \"Usage\" section at https://account.vscentrum.be .</p> <p>VO moderators can inspect storage quota for all VO members via https://account.vscentrum.be/django/vo/.</p> <p>To check your storage usage on the local scratch filesystems on VSC sites other than UGent, you can use the \"<code>show_quota</code>\" command (when logged into the login nodes of that VSC site).</p> <p>Once your quota is (nearly) exhausted, you will want to know which directories are responsible for the consumption of your disk space. You can check the size of all subdirectories in the current directory with the \"<code>du</code>\" (Disk Usage) command:</p> <pre><code>$ du\n256 ./ex01-matlab/log\n1536 ./ex01-matlab\n768 ./ex04-python\n512 ./ex02-python\n768 ./ex03-python\n5632\n</code></pre> <p>This shows you first the aggregated size of all subdirectories, and finally the total size of the current directory \".\" (this includes files stored in the current directory).</p> <p>If you also want this size to be \"human readable\" (and not always the total number of kilobytes), you add the parameter \"-h\":</p> <pre><code>$ du -h\n256K ./ex01-matlab/log\n1.5M ./ex01-matlab\n768K ./ex04-python\n512K ./ex02-python\n768K ./ex03-python\n5.5M .\n</code></pre> <p>If the number of lower level subdirectories starts to grow too big, you may not want to see the information at that depth; you could just ask for a summary of the current directory:</p> <pre><code>$ du -s\n5632 .\n$ du -s -h\n</code></pre> <p>If you want to see the size of any file or top-level subdirectory in the current directory, you could use the following command:</p> <pre><code>$ du -s -h *\n1.5M ex01-matlab\n512K ex02-python\n768K ex03-python\n768K ex04-python\n256K example.sh\n1.5M intro-HPC.pdf\n</code></pre> <p>Finally, if you don't want to know the size of the data in your current directory, but in some other directory (e.g., your data directory), you just pass this directory as a parameter. The command below will show the disk use in your home directory, even if you are currently in a different directory:</p> <pre><code>$ du -h $VSC_HOME/*\n22M /user/home/gent/vsc400/vsc40000/dataset01\n36M /user/home/gent/vsc400/vsc40000/dataset02\n22M /user/home/gent/vsc400/vsc40000/dataset03\n3.5M /user/home/gent/vsc400/vsc40000/primes.txt\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#groups", "title": "Groups", "text": "<p>Groups are a way to manage who can access what data. A user can belong to multiple groups at a time. Groups can be created and managed without any interaction from the system administrators.</p> <p>Please note that changes are not instantaneous: it may take about an hour for the changes to propagate throughout the entire HPC infrastructure.</p> <p>To change the group of a directory and it's underlying directories and files, you can use:</p> <pre><code>$ chgrp -R groupname directory\n</code></pre>"}, {"location": "running_jobs_with_input_output_data/#joining-an-existing-group", "title": "Joining an existing group", "text": "<ol> <li> <p>Get the group name you want to belong to.</p> </li> <li> <p>Go to https://account.vscentrum.be/django/group/new and fill in     the section named \"Join group\". You will be asked to fill in the     group name and a message for the moderator of the group, where you     identify yourself. This should look something like in the image below.</p> </li> <li> <p>After clicking the submit button, a message will be sent to the     moderator of the group, who will either approve or deny the request.     You will be a member of the group shortly after the group moderator     approves your request.</p> </li> </ol> <p></p>"}, {"location": "running_jobs_with_input_output_data/#creating-a-new-group", "title": "Creating a new group", "text": "<ol> <li> <p>Go to https://account.vscentrum.be/django/group/new and scroll     down to the section \"Request new group\". This should look something     like in the image below.</p> </li> <li> <p>Fill out the group name. This cannot contain spaces.</p> </li> <li> <p>Put a description of your group in the \"Info\" field.</p> </li> <li> <p>You will now be a member and moderator of your newly created group.</p> </li> </ol> <p></p>"}, {"location": "running_jobs_with_input_output_data/#managing-a-group", "title": "Managing a group", "text": "<p>Group moderators can go to https://account.vscentrum.be/django/group/edit to manage their group (see the image below). Moderators can invite and remove members. They can also promote other members to moderator and remove other moderators.</p> <p></p>"}, {"location": "running_jobs_with_input_output_data/#inspecting-groups", "title": "Inspecting groups", "text": "<p>You can get details about the current state of groups on the HPC infrastructure with the following command (<code>example</code> is the name of the group we want to inspect):</p> <pre><code>$ getent group example\nexample:*:1234567:vsc40001,vsc40002,vsc40003\n</code></pre> <p>We can see that the VSC id number is 1234567 and that there are three members in the group: <code>vsc40001</code>, <code>vsc40002</code> and <code>vsc40003</code>.</p>"}, {"location": "running_jobs_with_input_output_data/#virtual-organisations", "title": "Virtual Organisations", "text": "<p>A Virtual Organisation (VO) is a special type of group. You can only be a member of one single VO at a time (or not be in a VO at all). Being in a VO allows for larger storage quota to be obtained (but these requests should be well-motivated).</p>"}, {"location": "running_jobs_with_input_output_data/#joining-an-existing-vo", "title": "Joining an existing VO", "text": "<ol> <li> <p>Get the VO id of the research group you belong to (this id is formedby the letters <code>gvo</code>, followed by 5 digits).</p> </li> <li> <p>Go to https://account.vscentrum.be/django/vo/join and fill in the     section named \"Join VO\". You will be asked to fill in the VO id and     a message for the moderator of the VO, where you identify yourself.     This should look something like in the image below.</p> </li> <li> <p>After clicking the submit button, a message will be sent to the     moderator of the VO, who will either approve or deny the request.</p> </li> </ol> <p></p>"}, {"location": "running_jobs_with_input_output_data/#creating-a-new-vo", "title": "Creating a new VO", "text": "<ol> <li> <p>Go to https://account.vscentrum.be/django/vo/new and scroll down     to the section \"Request new VO\". This should look something like in the image below.</p> </li> <li> <p>Fill why you want to request a VO.</p> </li> <li> <p>Fill out the both the internal and public VO name. These cannot     contain spaces, and should be 8-10 characters long. For example,     <code>genome25</code> is a valid VO name.</p> </li> <li> <p>Fill out the rest of the form and press submit. This will send a     message to the HPC administrators, who will then either approve or deny     the request.</p> </li> <li> <p>If the request is approved, you will now be a member and moderator     of your newly created VO.</p> </li> </ol> <p></p>"}, {"location": "running_jobs_with_input_output_data/#requesting-more-storage-space", "title": "Requesting more storage space", "text": "<p>If you're a moderator of a VO, you can request additional quota for the VO and its members.</p> <ol> <li> <p>Go to https://account.vscentrum.be/django/vo/edit and scroll down     to \"Request additional quota\". See the image below to see how this looks.</p> </li> <li> <p>Fill out how much additional storage you want. In the screenshot     below, we're asking for 500 GiB extra space for <code>VSC_DATA</code>, and for     1 TiB extra space on <code>VSC_SCRATCH_KYUKON</code>.</p> </li> <li> <p>Add a comment explaining why you need additional storage space and     submit the form.</p> </li> <li> <p>An HPC administrator will review your request and approve or deny it.</p> </li> </ol> <p></p>"}, {"location": "running_jobs_with_input_output_data/#setting-per-member-vo-quota", "title": "Setting per-member VO quota", "text": "<p>VO moderators can tweak how much of the VO quota each member can use. By default, this is set to 50% for each user, but the moderator can change this: it is possible to give a particular user more than half of the VO quota (for example 80%), or significantly less (for example 10%).</p> <p>Note that the total percentage can be above 100%: the percentages the moderator allocates per user are the maximum percentages of storage users can use.</p> <ol> <li> <p>Go to https://account.vscentrum.be/django/vo/edit and scroll down     to \"Manage per-member quota share\". See the image below to see how this looks.</p> </li> <li> <p>Fill out how much percent of the space you want each user to be able     to use. Note that the total can be above 100%. In the screenshot     below, there are four users. Alice and Bob can use up to 50% of the     space, Carl can use up to 75% of the space, and Dave can only use     10% of the space. So in total, 185% of the space has been assigned,     but of course only 100% can actually be used.</p> </li> </ol> <p></p>"}, {"location": "running_jobs_with_input_output_data/#vo-directories", "title": "VO directories", "text": "<p>When you're a member of a VO, there will be some additional directories on each of the shared filesystems available:</p> <p>VO scratch (<code>$VSC_SCRATCH_VO</code>):   A directory on the shared scratch filesystem shared by the members     of your VO, where additional storage quota can be provided (see the section on requesting more storage space).     You can use this as an alternative to your personal <code>$VSC_SCRATCH</code>     directory (see the section on your scratch space).</p> <p>VO data (<code>$VSC_DATA_VO</code>):   A directory on the shared data filesystem shared by the members of     your VO, where additional storage quota can be provided (see ). You     can use this as an alternative to your personal <code>$VSC_DATA</code>     directory (see the section on your data directory).</p> <p>If you put <code>_USER</code> after each of these variable names, you can see your personal folder in these filesystems. For example: <code>$VSC_DATA_VO_USER</code> is your personal folder in your VO data filesystem (this is equivalent to <code>$VSC_DATA_VO/$USER</code>), and analogous for <code>$VSC_SCRATCH_VO_USER</code>.</p>"}, {"location": "scoop/", "title": "SCOOP", "text": "<p>SCOOP (Scalable COncurrent Operations in Python) is a distributed task module allowing concurrent parallel programming on various environments, from heterogeneous grids to supercomputers. It is an alternative to the worker framework, see Multi-job submission.</p> <p>It can used for projects that require lots of (small) tasks to be executed.</p> <p>The <code>myscoop</code> script makes it very easy to use SCOOP, even in a multi-node setup.</p>"}, {"location": "scoop/#loading-the-module", "title": "Loading the module", "text": "<p>Before using <code>myscoop</code>, you first need to load the <code>vsc-mympirun-scoop</code> module. We don't specify a version here (this is an exception, for most other modules you should, see Using explicit version numbers) because newer versions might include important bug fixes or performance improvements.</p> <pre><code>$ module load vsc-mympirun-scoop\n</code></pre>"}, {"location": "scoop/#write-a-worker-script", "title": "Write a worker script", "text": "<p>A Python worker script implements both the main program, and (typically) the small task function that needs to be executed a large amount of times.</p> <p>This is done using the functionality provided by the <code>scoop</code> Python module, for example <code>futures.map</code> (see also https://scoop.readthedocs.org/).</p> <p>First, the necessary imports need to be specified:</p> <pre><code>import sys \nfrom scoop import futures\n</code></pre> <p>A Python function must be implemented for the core task, for example to compute the square of a number:</p> <pre><code>def square(x): \n    return x*x\n</code></pre> <p>The main function then applies this simple function to a range of values specified as an argument. Note that it should be guarded by a conditional (<code>if __name__ == \"=__main__\"</code>) to make sure it is only executed when executing the script (and not when importing from it):</p> <pre><code>f __name__ == \"__main__\":\n\n    # obtain n from first command line argument \n    n = int(sys.argv[1])\n\n    # compute the square of the first n numbers, in parallel using SCOOP functionality \n    squares = futures.map(square, range(n)) # note: returns an iterator\n\n    print(\"First %d squares: %s\" % (n, list(squares)))\n</code></pre>"}, {"location": "scoop/#executing-the-program", "title": "Executing the program", "text": "<p>To execute the Python script implementing the task and main function in a SCOOP environment, specify to the <code>python</code> command to use the <code>scoop</code> module:</p> <pre><code>$ python -m scoop squares.py 10000\n</code></pre>"}, {"location": "scoop/#using-myscoop", "title": "Using myscoop", "text": "<p>To execute the SCOOP program in an multi-node environment, where workers are spread across multiple physical systems, simply use <code>myscoop</code>: just specify the name of the Python module in which the SCOOP program is implemented, and specify further arguments on the command line.</p> <p>You will need to make sure that the path to where the Python module is located is listed in <code>$PYTHONPATH</code>.</p> <p>This is an example of a complete job script executing the SCOOP program in parallel in a multi-node job (i.e., 2 nodes with 8 cores each):</p> <p>-- squares_jobscript.pbs -- <pre><code>#!/bin/bash\n\n#PBS -l nodes=2:ppn=8\n\nmodule load vsc-mympirun-scoop\n\n# change to directory where job was submitted from\ncd $PBS_O_WORKDIR\n\n# assume squares.py is in current directory\nexport PYTHONPATH=.:$PYTHONPATH\n\n# compute first 10k squares, in parallel on available cores\nmyscoop --scoop-module=squares 10000\n</code></pre></p> <p>Note that you don't need to specify how many workers need to be used; the <code>myscoop</code> command figures this out by itself. This is because <code>myscoop</code> is a wrapper around <code>mympirun</code> (see Mympirun). In this example, 16 workers (one per available core) will be execute the 10000 tasks one by one until all squares are computed.</p> <p>To run the same command on the local system (e.g., a login node for testing), add the <code>--sched=local</code> option to <code>myscoop</code>.</p>"}, {"location": "scoop/#example-calculating", "title": "Example: calculating \u03c0", "text": "<p>A more practical example of a worker script is one to compute \u03c0 using a Monte-Carlo method (see also https://scoop.readthedocs.org/en/0.6/examples.html#computation-of).</p> <p>The <code>test</code> function implements a tiny task that is be executed <code>tries</code> number of times by each worker. Afterwards, the number of successful tests is determined using the Python <code>sum</code> function, and an approximate value of \u03c0 is computed and returned by <code>calcPi</code> so the main function can print it out.</p> <p>-- picalc.py -- <pre><code>from math import hypot\nfrom random import random\nfrom scoop import futures\n\nNAME = 'SCOOP_piCalc'\n\n# A range is used in this function for python3. If you are using python2,\n# an xrange might be more efficient.\ntry:\n    range_fn = xrange\nexcept:\n    range_fn = range\n\n\ndef test(tries):\n    return sum(hypot(random(), random()) &lt; 1 for i in range_fn(tries))\n\n# Calculates pi with a Monte-Carlo method. This function calls the function\n# test \"n\" times with an argument of \"t\". Scoop dispatches these\n# functions interactively accross the available resources.\ndef calcPi(workers, tries):\n    expr = futures.map(test, [tries] * workers)\n    piValue = 4. * sum(expr) / float(workers * tries)\n    return piValue\n\n\nif __name__ == '__main__':\n    import sys\n    nr_batches = 3000\n    batch_size = 5000\n\n    # Program name and two arguments\n    if len(sys.argv) == 3:\n        try:\n            nr_batches = int(sys.argv[1])\n            batch_size = int(sys.argv[2])\n        except ValueError as ex:\n            sys.stderr.write(\"ERROR: Two integers expected as arguments: %s\\n\" % ex)\n            sys.exit(1)\n    elif len(sys.argv) != 1:\n        sys.stderr.write(\"ERROR: Expects either zero or two integers as arguments.\\n\")\n        sys.exit(1)\n\n    print(\"PI=%f (in nr_batches=%d,batch_size=%d)\" % (calcPi(nr_batches, batch_size), nr_batches, batch_size))\n</code></pre> -- picalc_job_script.pbs -- <pre><code>#!/bin/bash\n#PBS -l nodes=2:ppn=16\n\nmodule load vsc-mympirun-scoop\n\n# change to directory where job was submitted from\ncd $PBS_O_WORKDIR\n\n# assume picalc.py is in current directory\nexport PYTHONPATH=.:$PYTHONPATH\n\n# run 10k batches/workers with a batch size of 5000\nmyscoop --scoop-module=picalc 10000 5000\n</code></pre></p>"}, {"location": "singularity/", "title": "Singularity", "text": ""}, {"location": "singularity/#what-is-singularity", "title": "What is Singularity?", "text": "<p>Singularity is an open-source computer program that performs operating-system-level virtualization (also known as containerisation).</p> <p>One of the main uses of Singularity is to bring containers and reproducibility to scientific computing and the high-performance computing (HPC) world. Using Singularity containers, developers can work in reproducible environments of their choosing and design, and these complete environments can easily be copied and executed on other platforms.</p> <p>For more general information about the use of Singularity, please see the official documentation at https://www.sylabs.io/docs/.</p> <p>This documentation only covers aspects of using Singularity on the infrastructure.</p>"}, {"location": "singularity/#restrictions-on-image-location", "title": "Restrictions on image location", "text": "<p>Some restrictions have been put in place on the use of Singularity. This is mainly done for performance reasons and to avoid that the use of Singularity impacts other users on the system.</p> <p>The Singularity image file must be located on either one of the scratch filesystems, the local disk of the workernode you are using or <code>/dev/shm</code>. The centrally provided <code>singularity</code> command will refuse to run using images that are located elsewhere, in particular on the <code>$VSC_HOME</code>, <code>/apps</code> or <code>$VSC_DATA</code> filesystems.</p> <p>In addition, this implies that running containers images provided via a URL (e.g., <code>shub://...</code> or <code>docker://...</code>) will not work.</p> <p>If these limitations are a problem for you, please let us know via .</p>"}, {"location": "singularity/#available-filesystems", "title": "Available filesystems", "text": "<p>All HPC-UGent shared filesystems will be readily available in a Singularity container, including the home, data and scratch filesystems, and they will be accessible via the familiar <code>$VSC_HOME</code>, <code>$VSC_DATA*</code> and <code>$VSC_SCRATCH*</code> environment variables.</p>"}, {"location": "singularity/#singularity-images", "title": "Singularity Images", "text": ""}, {"location": "singularity/#creating-singularity-images", "title": "Creating Singularity images", "text": "<p>Creating new Singularity images or converting Docker images, by default, requires admin privileges, which is obviously not available on the infrastructure. However, if you use the <code>--fakeroot</code> option, you can make new Singularity images or convert Docker images.</p> <p>When you make Singularity or convert Docker images you have some restrictions:</p> <ul> <li>Due to the nature of <code>--fakeroot</code> option, we recommend to write your     singularity image to a globally writable location, like <code>/tmp</code>, or     <code>/local</code> directories. Once the images is created, you should move it     to your desired destination.</li> </ul>"}, {"location": "singularity/#converting-docker-images", "title": "Converting Docker images", "text": "<p>For more information on converting existing Docker images to Singularity images, see https://www.sylabs.io/guides/3.4/user-guide/singularity_and_docker.html.</p> <p>We strongly recommend the use of Docker Hub, see https://hub.docker.com/ for more information.</p>"}, {"location": "singularity/#execute-our-own-script-within-our-container", "title": "Execute our own script within our container", "text": "<p>Copy testing image from <code>/apps/gent/tutorials/Singularity</code> to <code>$VSC_SCRATCH</code>:</p> <p>::: prompt :::</p> <p>Create a job script like:</p> <p>Create an example <code>myscript.sh</code>:</p> <p>::: code bash #!/bin/bash</p> <p># prime factors factor 1234567 :::</p>"}, {"location": "singularity/#tensorflow-example", "title": "Tensorflow example", "text": "<p>We already have a Tensorflow example image, but you can also convert the Docker image (see https://hub.docker.com/r/tensorflow/tensorflow) to a Singularity image yourself</p> <p>Copy testing image from <code>/apps/gent/tutorials</code> to <code>$VSC_SCRATCH</code>:</p> <p>::: prompt :::</p> <p>You can download <code>linear_regression.py</code> from the official Tensorflow repository.</p>"}, {"location": "singularity/#mpi-example", "title": "MPI example", "text": "<p>It is also possible to execute MPI jobs within a container, but the following requirements apply:</p> <ul> <li> <p>Mellanox IB libraries must be available from the container (install     the <code>infiniband-diags</code>, <code>libmlx5-1</code> and <code>libmlx4-1</code> OS packages)</p> </li> <li> <p>Use modules within the container (install the <code>environment-modules</code>     or <code>lmod</code> package in your container)</p> </li> <li> <p>Load the required module(s) before <code>singularity</code> execution.</p> </li> <li> <p>Set <code>C_INCLUDE_PATH</code> variable in your container if it is required     during compilation time     (<code>export C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu/:$C_INCLUDE_PATH</code>     for Debian flavours)</p> </li> </ul> <p>Copy the testing image from <code>/apps/gent/tutorials/Singularity</code> to <code>$VSC_SCRATCH</code></p> <p>::: prompt :::</p> <p>For example to compile an MPI example:</p> <p>::: prompt :::</p> <p>Example MPI job script:</p>"}, {"location": "torque_options/", "title": "TORQUE options", "text": ""}, {"location": "torque_options/#torque-submission-flags-common-and-useful-directives", "title": "TORQUE Submission Flags: common and useful directives", "text": "<p>Below is a list of the most common and useful directives.</p> Option System type Description -k All Send \"stdout\" and/or \"stderr\" to your home directory when the job runs  #PBS -k o or #PBS -k e or #PBS -koe -l All Precedes a resource request, e.g., processors, wallclock -M All Send an e-mail messages to an alternative e-mail address  #PBS -M me@mymail.be -m All Send an e-mail address when a job begins execution and/or ends or aborts  #PBS -m b or #PBS -m be or #PBS -m ba mem Shared Memory Memory &amp; Specifies the amount of memory you need for a job. #PBS -I mem=90gb mpiproces Clusters Number of processes per node on a cluster. This should equal number of processors on a node in most cases.  #PBS -l mpiprocs=4 -N All Give your job a unique name #PBS -N galaxies1234 -ncpus Shared Memory The number of processors to use for a shared memory job. #PBS ncpus=4 -r All ontrol whether or not jobs should automatically re-run from the start if the system crashes or is rebooted. Users with check points might not wish this to happen. #PBS -r n#PBS -r y select Clusters Number of compute nodes to use. Usually combined with the mpiprocs directive #PBS -l select=2 -V All Make sure that the environment in which the job runs is the same as the environment in which it was submitted  #PBS -V Walltime All The maximum time a job can run before being stopped. If not used a default of a few minutes is used. Use this flag to prevent jobs that go bad running for hundreds of hours. Format is HH:MM:SS #PBS -l walltime=12:00:00"}, {"location": "torque_options/#environment-variables-in-batch-job-scripts", "title": "Environment Variables in Batch Job Scripts", "text": "<p>TORQUE-related environment variables in batch job scripts.</p> <pre><code># Using PBS - Environment Variables:\n# When a batch job starts execution, a number of environment variables are\n# predefined, which include:\n#\n#      Variables defined on the execution host.\n#      Variables exported from the submission host with\n#                -v (selected variables) and -V (all variables).\n#      Variables defined by PBS.\n#\n# The following reflect the environment where the user ran qsub:\n# PBS_O_HOST    The host where you ran the qsub command.\n# PBS_O_LOGNAME Your user ID where you ran qsub.\n# PBS_O_HOME    Your home directory where you ran qsub.\n# PBS_O_WORKDIR The working directory where you ran qsub.\n#\n# These reflect the environment where the job is executing:\n# PBS_ENVIRONMENT       Set to PBS_BATCH to indicate the job is a batch job,\n#         or to PBS_INTERACTIVE to indicate the job is a PBS interactive job.\n# PBS_O_QUEUE   The original queue you submitted to.\n# PBS_QUEUE     The queue the job is executing from.\n# PBS_JOBID     The job's PBS identifier.\n# PBS_JOBNAME   The job's name.\n</code></pre> <p>IMPORTANT!! All PBS directives MUST come before the first line of executable code in your script, otherwise they will be ignored.</p> <p>When a batch job is started, a number of environment variables are created that can be used in the batch job script. A few of the most commonly used variables are described here.</p> Variable Description PBS_ENVIRONMENT set to PBS_BATCH to indicate that the job is a batch job; otherwise, set to PBS_INTERACTIVE to indicate that the job is a PBS interactive job. PBS_JOBID the job identifier assigned to the job by the batch system. This is the same number you see when you do qstat. PBS_JOBNAME the job name supplied by the user PBS_NODEFILE the name of the file that contains the list of the nodes assigned to the job . Useful for Parallel jobs if you want to refer the node, count the node etc. PBS_QUEUE the name of the queue from which the job is executed PBS_O_HOME value of the HOME variable in the environment in which qsub was executed PBS_O_LANG value of the LANG variable in the environment in which qsub was executed PBS_O_LOGNAME value of the LOGNAME variable in the environment in which qsub was executed PBS_O_PATH value of the PATH variable in the environment in which qsub was executed PBS_O_MAIL value of the MAIL variable in the environment in which qsub was executed PBS_O_SHELL value of the SHELL variable in the environment in which qsub was executed PBS_O_TZ value of the TZ variable in the environment in which qsub was executed PBS_O_HOST the name of the host upon which the qsub command is running PBS_O_QUEUE the name of the original queue to which the job was submitted PBS_O_WORKDIR the absolute path of the current working directory of the qsub command. This is the most useful. Use it in every job script. The first thing you do is, cd $PBS_O_WORKDIR after defining the resource list. This is because, pbs throw you to your $HOME directory. PBS_VERSION Version Number of TORQUE, e.g., TORQUE-2.5.1 PBS_MOMPORT active port for mom daemon PBS_TASKNUM number of tasks requested PBS_JOBCOOKIE job cookie PBS_SERVER Server Running TORQUE"}, {"location": "troubleshooting/", "title": "Troubleshooting", "text": ""}, {"location": "troubleshooting/#walltime-issues", "title": "Walltime issues", "text": "<p>If you get from your job output an error message similar to this:</p> <pre><code>=&gt;&gt; PBS: job killed: walltime &lt;value in seconds&gt; exceeded limit  &lt;value in seconds&gt;\n</code></pre> <p>This occurs when your job did not complete within the requested walltime. See section\u00a0on Specifying Walltime for more information about how to request the walltime. It is recommended to use checkpointing if the job requires 72 hours of walltime or more to be executed.</p>"}, {"location": "troubleshooting/#out-of-quota-issues", "title": "Out of quota issues", "text": "<p>Sometimes a job hangs at some point or it stops writing in the disk. These errors are usually related to the quota usage. You may have reached your quota limit at some storage endpoint. You should move (or remove) the data to a different storage endpoint (or request more quota) to be able to write to the disk and then resubmit the jobs. </p> <p>Another option is to request extra quota for your VO to the VO moderator/s. See section on Pre-defined user directories and Pre-defined quotas for more information about quotas and how to use the storage endpoints in an efficient way.</p>"}, {"location": "troubleshooting/#sec:connecting-issues", "title": "Issues connecting to login node", "text": "<p>If you are confused about the SSH public/private key pair concept, maybe the key/lock analogy in How do SSH keys work? can help.</p> <p>If you have errors that look like:</p> <pre><code>vsc40000@login.hpc.ugent.be: Permission denied\n</code></pre> <p>or you are experiencing problems with connecting, here is a list of things to do that should help:</p> <ol> <li> <p>Keep in mind that it an take up to an hour for your VSC account to     become active after it has been approved; until then, logging in     to your VSC account will not work.</p> </li> <li> <p>Make sure you are connecting from an IP address that is allowed to     access the VSC login nodes, see     section Connection restrictions     for more information.</p> </li> <li> <p>Please double/triple check your VSC login ID. It should look     something like vsc40000: the letters <code>vsc</code>, followed by exactly 5 digits.     Make sure it's the same one as the one on     https://account.vscentrum.be/.</p> </li> <li> <p>You previously connected to the HPC from another machine, but now have     another machine? Please follow the procedure for adding additional     keys in section Adding multiple SSH public keys. You may need to wait for     15-20 minutes until the SSH public key(s) you added become active.</p> </li> <li> <p>When using an SSH key in a non-default location, make sure you supply the path of the private key (and not the path of the public key) to <code>ssh</code>. <code>id_rsa.pub</code> is the usual filename of the public key, <code>id_rsa</code> is the usual filename of the private key. (See also section\u00a0Connect)</p> </li> <li> <p>If you have multiple private keys on your machine, please make sure     you are using the one that corresponds to (one of) the public key(s)     you added on https://account.vscentrum.be/.</p> </li> <li> <p>Please do not use someone else's private keys. You must never share     your private key, they're called private for a good reason.</p> </li> </ol> <p>If you've tried all applicable items above and it doesn't solve your problem, please contact hpc@ugent.be and include the following information:</p> <p>Please add <code>-vvv</code> as a flag to <code>ssh</code> like:</p> <pre><code>ssh -vvv vsc40000@login.hpc.ugent.be\n</code></pre> <p>and include the output of that command in the message.</p>"}, {"location": "troubleshooting/#security-warning-about-invalid-host-key", "title": "Security warning about invalid host key", "text": "<p>If you get a warning that looks like the one below, it is possible that someone is trying to intercept the connection between you and the system you are connecting to. Another possibility is that the host key of the system you are connecting to has changed.</p> <p>You will need to verify that the fingerprint shown in the dialog matches one of the following fingerprints:</p> <pre><code>- ssh-rsa 2048 10:2f:31:21:04:75:cb:ed:67:e0:d5:0c:a1:5a:f4:78\n- ssh-rsa 2048 SHA256:W8Wz0/FkkCR2ulN7+w8tNI9M0viRgFr2YlHrhKD2Dd0\n- ssh-ed25519 255 19:28:76:94:52:9d:ff:7d:fb:8b:27:b6:d7:69:42:eb\n- ssh-ed25519 256 SHA256:8AJg3lPN27y6i+um7rFx3xoy42U8ZgqNe4LsEycHILA\n- ssh-ecdsa 256 e6:d2:9c:d8:e7:59:45:03:4a:1f:dc:96:62:29:9c:5f\n- ssh-ecdsa 256 SHA256:C8TVx0w8UjGgCQfCmEUaOPxJGNMqv2PXLyBNODe5eOQ\n\n</code></pre> <p>Do not click \"Yes\" until you verified the fingerprint. Do not press \"No\" in any case.</p> <p>If it the fingerprint matches, click \"Yes\".</p> <p>If it doesn't (like in the example) or you are in doubt, take a screenshot, press \"Cancel\" and contact hpc@ugent.be.</p> <p>Note: it is possible that the <code>ssh-ed25519</code> fingerprint starts with <code>ssh-ed25519 255</code> rather than <code>ssh-ed25519 256</code> (or vice versa), depending on the PuTTY version you are using. It is safe to ignore this <code>255</code> versus <code>256</code> difference, but the part after should be identical.</p> <p> </p> <p>If you use X2Go client, you might get one of the following fingerprints:</p> <ul> <li>ssh-rsa 2048 53:25:8c:1e:72:8b:ce:87:3e:54:12:44:a7:13:1a:89:e4:15:b6:8e</li> <li>ssh-ed25519 255 e3:cc:07:64:78:80:28:ec:b8:a8:8f:49:44:d1:1e:dc:cc:0b:c5:6b</li> <li>ssh-ecdsa 256 67:6c:af:23:cc:a1:72:09:f5:45:f1:60:08:e8:98:ca:31:87:58:6c</li> </ul> <p>If you get a message \"Host key for server changed\", do not click \"No\" until you verified the fingerprint.</p> <p>If the fingerprint matches, click \"No\", and in the next pop-up screen (\"if you accept the new host key...\"), press \"Yes\".</p> <p>If it doesn't, or you are in doubt, take a screenshot, press \"Yes\" and contact hpc@ugent.be.</p>"}, {"location": "troubleshooting/#doswindows-text-format", "title": "DOS/Windows text format", "text": "<p>If you get errors like:</p> <pre><code>qsub fibo.pbs\nqsub: script is written in DOS/Windows text format\n</code></pre> <p>or</p> <pre><code>sbatch: error: Batch script contains DOS line breaks (\\r\\n)\n</code></pre> <p>It's probably because you transferred the files from a Windows computer. See the section about <code>dos2unix</code> in Linux tutorial to fix this error.</p>"}, {"location": "troubleshooting/#warning-message-when-first-connecting-to-new-host", "title": "Warning message when first connecting to new host", "text": "<p>If you use X2Go, then you might get another fingerprint, then make sure that the fingerprint is displayed is one of the following ones:</p> <ul> <li>ssh-rsa 2048 53:25:8c:1e:72:8b:ce:87:3e:54:12:44:a7:13:1a:89:e4:15:b6:8e</li> <li>ssh-ed25519 255 e3:cc:07:64:78:80:28:ec:b8:a8:8f:49:44:d1:1e:dc:cc:0b:c5:6b</li> <li>ssh-ecdsa 256 67:6c:af:23:cc:a1:72:09:f5:45:f1:60:08:e8:98:ca:31:87:58:6c</li> </ul> <p>If it does, type yes. If it doesn't, please contact support: hpc@ugent.be.</p> <p>The first time you make a connection to the login node, a Security Alert will appear and you will be asked to verify the authenticity of the login node.</p> <p>Make sure the fingerprint in the alert matches one of the following:</p> <pre><code>- ssh-rsa 2048 10:2f:31:21:04:75:cb:ed:67:e0:d5:0c:a1:5a:f4:78\n- ssh-rsa 2048 SHA256:W8Wz0/FkkCR2ulN7+w8tNI9M0viRgFr2YlHrhKD2Dd0\n- ssh-ed25519 255 19:28:76:94:52:9d:ff:7d:fb:8b:27:b6:d7:69:42:eb\n- ssh-ed25519 256 SHA256:8AJg3lPN27y6i+um7rFx3xoy42U8ZgqNe4LsEycHILA\n- ssh-ecdsa 256 e6:d2:9c:d8:e7:59:45:03:4a:1f:dc:96:62:29:9c:5f\n- ssh-ecdsa 256 SHA256:C8TVx0w8UjGgCQfCmEUaOPxJGNMqv2PXLyBNODe5eOQ\n</code></pre> <p>If it does, press Yes, if it doesn't, please contact hpc@ugent.be.</p> <p>Note: it is possible that the <code>ssh-ed25519</code> fingerprint starts with <code>ssh-ed25519 255</code> rather than <code>ssh-ed25519 256</code> (or vice versa), depending on the PuTTY version you are using. It is safe to ignore this <code>255</code> versus <code>256</code> difference, but the part after should be identical.</p> <p></p> <p>If you use X2Go, then you might get another fingerprint, then make sure that the fingerprint is displayed is one of the following ones:</p> <ul> <li>ssh-rsa 2048 53:25:8c:1e:72:8b:ce:87:3e:54:12:44:a7:13:1a:89:e4:15:b6:8e</li> <li>ssh-ed25519 255 e3:cc:07:64:78:80:28:ec:b8:a8:8f:49:44:d1:1e:dc:cc:0b:c5:6b</li> <li>ssh-ecdsa 256 67:6c:af:23:cc:a1:72:09:f5:45:f1:60:08:e8:98:ca:31:87:58:6c</li> </ul>"}, {"location": "troubleshooting/#memory-limits", "title": "Memory limits", "text": "<p>To avoid jobs allocating too much memory, there are memory limits in place by default. It is possible to specify higher memory limits if your jobs require this.</p>"}, {"location": "troubleshooting/#how-will-i-know-if-memory-limits-are-the-cause-of-my-problem", "title": "How will I know if memory limits are the cause of my problem?", "text": "<p>If your program fails with a memory-related issue, there is a good chance it failed because of the memory limits and you should increase the memory limits for your job.</p> <p>Examples of these error messages are: <code>malloc failed</code>, <code>Out of memory</code>, <code>Could not allocate memory</code> or in Java: <code>Could not reserve enough space for object heap</code>. Your program can also run into a <code>Segmentation fault</code> (or <code>segfault</code>) or crash due to bus errors.</p> <p>You can check the amount of virtual memory (in Kb) that is available to you via the <code>ulimit -v</code> command in your job script.</p>"}, {"location": "troubleshooting/#how-do-i-specify-the-amount-of-memory-i-need", "title": "How do I specify the amount of memory I need?", "text": "<p>See Generic resource requirements to set memory and other requirements, see Specifying memory requirements to finetune the amount of memory you request.</p>"}, {"location": "troubleshooting/#module-conflicts", "title": "Module conflicts", "text": "<p>Modules that are loaded together must use the same toolchain version: it is impossible to load two versions of the same module. In the following example, we try to load a module that uses the <code>intel-2018a</code> toolchain together with one that uses the <code>intel-2017a</code> toolchain:</p> <pre><code>$ module load Python/2.7.14-intel-2018a\n$ module load  HMMER/3.1b2-intel-2017a\nLmod has detected the following error: A different version of the 'intel' module is already loaded (see output of 'ml'). \nYou should load another 'HMMER' module for that is compatible with the currently loaded version of 'intel'. \nUse 'ml avail HMMER' to get an overview of the available versions.\n\nIf you don't understand the warning or error, contact the helpdesk at hpc@ugent.be \nWhile processing the following module(s):\n\n    Module fullname          Module Filename\n    ---------------          ---------------\n    HMMER/3.1b2-intel-2017a  /apps/gent/CO7/haswell-ib/modules/all/HMMER/3.1b2-intel-2017a.lua\n</code></pre> <p>This resulted in an error because we tried to load two different versions of the <code>intel</code> module.</p> <p>To fix this, check if there are other versions of the modules you want to load that have the same version of common dependencies. You can list all versions of a module with <code>module avail</code>: for <code>HMMER</code>, this command is <code>module avail HMMER</code>.</p> <p>Another common error is:</p> <pre><code>$ module load cluster/skitty\nLmod has detected the following error: A different version of the 'cluster' module is already loaded (see output of 'ml').\n\nIf you don't understand the warning or error, contact the helpdesk at hpc@ugent.be\n</code></pre> <p>This is because there can only be one <code>cluster</code> module active at a time. The correct command is <code>module swap cluster/skitty</code>. See also Specifying the cluster on which to run.</p>"}, {"location": "troubleshooting/#running-software-that-is-incompatible-with-host", "title": "Running software that is incompatible with host", "text": "<p>When running software provided through modules (see Modules), you may run into errors like:</p> <pre><code>$ module swap cluster/kirlia\nThe following have been reloaded with a version change: \n    1) cluster/victini =&gt; cluster/kirlia\n\n$ module load Python/2.7.14-intel-2018a\n$ python\n\nPlease verify that both the operating system and the processor support\nIntel(R) MOVBE, F16C, FMA, BMI, LZCNT and AVX2 instructions.\n</code></pre> <p>or errors like:</p> <pre><code>$ module swap cluster/doduo\n\nThe following have been reloaded with a version change: \n    1) cluster/victini =&gt; cluster/doduo\n\n$ module load Python/2.7.14-foss-2018a\n$ python\nIllegal instruction\n</code></pre> <p>When we swap to a different cluster, the available modules change so they work for that cluster. That means that if the cluster and the login nodes have a different CPU architecture, software loaded using modules might not work.</p> <p>If you want to test software on the login nodes, make sure the <code>cluster/victini</code> module is loaded (with <code>module swap cluster/victini</code>, see Specifying the cluster on which to run), since the login nodes and have the same CPU architecture.</p> <p>If modules are already loaded, and then we swap to a different cluster, all our modules will get reloaded. This means that all current modules will be unloaded and then loaded again, so they'll work on the newly loaded cluster. Here's an example of how that would look like:</p> <pre><code>$ module load Python/2.7.14-intel-2018a\n$ module swap cluster/swalot\n\nDue to MODULEPATH changes, the following have been reloaded:\n  1) GCCcore/6.4.0                   5) Tcl/8.6.8-GCCcore-6.4.0           9) iccifort/2018.1.163-GCC-6.4.0-2.28    13) impi/2018.1.163-iccifort-2018.1.163-GCC-6.4.0-2.28    17) ncurses/6.0-GCCcore-6.4.0\n  2) GMP/6.1.2-GCCcore-6.4.0         6) binutils/2.28-GCCcore-6.4.0      10) ifort/2018.1.163-GCC-6.4.0-2.28       14) intel/2018a                                           18) zlib/1.2.11-GCCcore-6.4.0\n  3) Python/2.7.14-intel-2018a       7) bzip2/1.0.6-GCCcore-6.4.0        11) iimpi/2018a                           15) libffi/3.2.1-GCCcore-6.4.0\n  4) SQLite/3.21.0-GCCcore-6.4.0     8) icc/2018.1.163-GCC-6.4.0-2.28    12) imkl/2018.1.163-iimpi-2018a           16) libreadline/7.0-GCCcore-6.4.0\n\nThe following have been reloaded with a version change:\n  1) cluster/victini =&gt; cluster/swalot\n</code></pre> <p>This might result in the same problems as mentioned above. When swapping to a different cluster, you can run <code>module purge</code> to unload all modules to avoid problems (see Purging all modules).</p>"}, {"location": "useful_linux_commands/", "title": "Useful Linux Commands", "text": ""}, {"location": "useful_linux_commands/#basic-linux-usage", "title": "Basic Linux Usage", "text": "<p>All the HPC clusters run some variant of the \"Red Hat Enterprise Linux\" operating system. This means that, when you connect to one of them, you get a command line interface, which looks something like this:</p> <pre><code>vsc40000@ln01[203] $\n</code></pre> <p>When you see this, we also say you are inside a \"shell\". The shell will accept your commands, and execute them.</p>            ls                    Shows you a list of files in the current directory                     cd                     Change current working directory                     rm                    Remove file or directory                     nano                    Text editor                     echo                    Prints its parameters to the screen          <p>Most commands will accept or even need parameters, which are placed after the command, separated by spaces. A simple example with the \"echo\" command:</p> <pre><code>$ echo This is a test\nThis is a test\n</code></pre> <p>Important here is the \"$\" sign in front of the first line. This should not be typed, but is a convention meaning \"the rest of this line should be typed at your shell prompt\". The lines not starting with the \"$\" sign are usually the feedback or output from the command.</p> <p>More commands will be used in the rest of this text, and will be explained then if necessary. If not, you can usually get more information about a command, say the item or command \"ls\", by trying either of the following:</p> <pre><code>$ ls --help \n$ man ls\n$  info ls \n</code></pre> <p>(You can exit the last two \"manuals\" by using the \"q\" key.) For more exhaustive tutorials about Linux usage, please refer to the following sites: http://www.linux.org/lessons/ http://linux.about.com/od/nwb_guide/a/gdenwb06.htm</p>"}, {"location": "useful_linux_commands/#how-to-get-started-with-shell-scripts", "title": "How to get started with shell scripts", "text": "<p>In a shell script, you will put the commands you would normally type at your shell prompt in the same order. This will enable you to execute all those commands at any time by only issuing one command: starting the script.</p> <p>Scripts are basically non-compiled pieces of code: they are just text files. Since they don't contain machine code, they are executed by what is called a \"parser\" or an \"interpreter\". This is another program that understands the command in the script, and converts them to machine code. There are many kinds of scripting languages, including Perl and Python.</p> <p>Another very common scripting language is shell scripting. In a shell script, you will put the commands you would normally type at your shell prompt in the same order. This will enable you to execute all those commands at any time by only issuing one command: starting the script.</p> <p>Typically in the following examples they'll have on each line the next command to be executed although it is possible to put multiple commands on one line. A very simple example of a script may be:</p> <pre><code>echo \"Hello! This is my hostname:\" \nhostname\n</code></pre> <p>You can type both lines at your shell prompt, and the result will be the following:</p> <pre><code>$ echo \"Hello! This is my hostname:\"\nHello! This is my hostname:\n$ hostname\ngligar07.gastly.os\n</code></pre> <p>Suppose we want to call this script \"foo\". You open a new file for editing, and name it \"foo\", and edit it with your favourite editor</p> <pre><code>$ nano foo\n</code></pre> <p>or use the following commands:</p> <pre><code>$ echo \"echo Hello! This is my hostname:\" &gt; foo\n$ echo hostname &gt;&gt; foo\n</code></pre> <p>The easiest ways to run a script is by starting the interpreter and pass the script as parameter. In case of our script, the interpreter may either be \"sh\" or \"bash\" (which are the same on the cluster). So start the script:</p> <pre><code>$ bash foo\nHello! This is my hostname:\ngligar07.gastly.os\n</code></pre> <p>Congratulations, you just created and started your first shell script!</p> <p>A more advanced way of executing your shell scripts is by making them executable by their own, so without invoking the interpreter manually. The system can not automatically detect which interpreter you want, so you need to tell this in some way. The easiest way is by using the so called \"shebang\" notation, explicitly created for this function: you put the following line on top of your shell script \"#!/path/to/your/interpreter\".</p> <p>You can find this path with the \"which\" command. In our case, since we use bash as an interpreter, we get the following path:</p> <pre><code>$ which bash\n/bin/bash\n</code></pre> <p>We edit our script and change it with this information:</p> <pre><code>#!/bin/bash echo \\\"Hello! This is my hostname:\\\" hostname\n</code></pre> <p>Note that the \"shebang\" must be the first line of your script! Now the operating system knows which program should be started to run the script.</p> <p>Finally, we tell the operating system that this script is now executable. For this we change its file attributes:</p> <pre><code>$  chmod +x foo\n</code></pre> <p>Now you can start your script by simply executing it:</p> <pre><code>$ ./foo\nHello! This is my hostname:\ngligar07.gastly.os\n</code></pre> <p>The same technique can be used for all other scripting languages, like Perl and Python.</p> <p>Most scripting languages understand that lines beginning with \"#\" are comments, and should be ignored. If the language you want to use does not ignore these lines, you may get strange results ...</p>"}, {"location": "useful_linux_commands/#linux-quick-reference-guide", "title": "Linux Quick reference Guide", "text": ""}, {"location": "useful_linux_commands/#archive-commands", "title": "Archive Commands", "text": "tar                    An archiving program designed to store and extract files from an archive known as a tar file.                     tar -cvf foo.tar foo/                    compress the contents of foo folder to foo.tar                     tar -xvf foo.tar                    extract foo.tar                     tar -xvzf foo.tar.gz                    extract gzipped foo.tar.gz"}, {"location": "useful_linux_commands/#basic-commands", "title": "Basic Commands", "text": "ls                    Shows you a list of files in the current directory                     cd                    Change the current directory                     rm                    Remove file or directory                     mv                    Move file or directory                     echo                    Display a line or text                     pwd                    Print working directory                     mkdir                    Create directories                     rmdir                    Remove directories"}, {"location": "useful_linux_commands/#editor", "title": "Editor", "text": "emacs                     nano                    Nano's ANOther editor, an enhanced free Pico clone                     vi                    A programmers text editor"}, {"location": "useful_linux_commands/#file-commands", "title": "File Commands", "text": "cat                     Read one or more files and print them to standard output                     cmp                    Compare two files byte by byte                     cp                    Copy files from a source to the same or different target(s)                     du                    Estimate disk usage of each file and recursively for directories                     find                    Search for files in directory hierarchy                     grep                    Print lines matching a pattern                     ls                    List directory contents                     mv                    Move file to different targets                     rm                    Remove files                     sort                    Sort lines of text files                     wc                    Print the number of new lines, words, and bytes in files"}, {"location": "useful_linux_commands/#help-commands", "title": "Help Commands", "text": "man                    Displays the manual page of a command with its name, synopsis, description, author, copyright etc."}, {"location": "useful_linux_commands/#network-commands", "title": "Network Commands", "text": "hostname                    show or set the system's host name                     ifconfig                    Display the current configuration of the network interface. It is also useful to get the information about IP address, subnet mask, set remote IP address, netmask etc.                     ping                    send ICMP ECHO_REQUEST to network hosts, you will get back ICMP packet if the host responds. This command is useful when you are in a doubt whether your computer is connected or not."}, {"location": "useful_linux_commands/#other-commands", "title": "Other Commands", "text": "logname                    Print user's login name                     quota                    Display disk usage and limits                     which                    Returns the pathnames of the files that would be executed in the current environment                     whoami                    Displays the login name of the current effective user"}, {"location": "useful_linux_commands/#process-commands", "title": "Process Commands", "text": "&amp;                    In order to execute a command in the background, place an ampersand (&amp;) on the command line at the end of the command. A user job number (placed in brackets) and a system process number are displayed. A system process number is the number by which the system identifies the job whereas a user job number is the number by which the user identifies the job                     at                    executes commands at a specified time                     bg                    Places a suspended job in the background                     crontab                    crontab is a file which contains the schedule of entries to run at specified times                     fg                    A process running in the background will be processed in the foreground                     jobs                    Lists the jobs being run in the background                     kill                    Cancels a job running in the background, it takes argument either the user job number or the system process number                     ps                    Reports a snapshot of the current processes                     top                    Display Linux tasks"}, {"location": "useful_linux_commands/#user-account-commands", "title": "User Account Commands", "text": "chmod                    Modify properties for users"}, {"location": "web_portal/", "title": "Using the HPC-UGent web portal", "text": "<p>The HPC-UGent web portal provides \"one stop shop\" for the HPC-UGent infrastructure. It is based on Open OnDemand (or <code>OoD</code> for short).</p> <p>Via this web portal you can upload and download files, create, edit, submit, and monitor jobs, run GUI applications, and connect via SSH, all via a standard web browser like Firefox, Chrome or Safari. You do not need to install or configure any client software, and no SSH key is required to connect to your VSC account via this web portal.\\ Please note that we do recommend to use our interactive and debug cluster (see chapter interactive and debug cluster) with <code>OoD</code>.</p> <p>To connect to the HPC-UGent infrastructure via the web portal, visit:</p> <p> https://login.hpc.ugent.be </p> <p>Note that you may only see a \"Submitting...\" message appear for a couple of seconds, which is perfectly normal.</p> <p>Through this web portal, you can:</p> <ul> <li> <p>browse through the files &amp; directories in your VSC account, and     inspect, manage or change them;</p> </li> <li> <p>consult active jobs (across all HPC-UGent Tier-2 clusters);</p> </li> <li> <p>submit new jobs to the HPC-UGent Tier-2 clusters, either from     existing job scripts or from job templates;</p> </li> <li> <p>start an interactive graphical user interface (a desktop     environment), either on the login nodes or on a cluster workernode;</p> </li> <li> <p>open a terminal session directly in your web browser;</p> </li> </ul> <p>More detailed information is available below, as well as in the Open OnDemand documentation. A walkthrough video is available on YouTube here.</p>"}, {"location": "web_portal/#pilot-access", "title": "Pilot access", "text": ""}, {"location": "web_portal/#known-issues-limitations", "title": "Known issues &amp; limitations", "text": ""}, {"location": "web_portal/#limited-resources", "title": "Limited resources", "text": "<p>All web portal sessions are currently served through a single separate login node, so the available resources are relatively limited. We will monitor the resources used by the active web portal sessions throughout the pilot phase to evaluate whether more resources are required.</p>"}, {"location": "web_portal/#login", "title": "Login", "text": "<p>When visiting the HPC-UGent web portal you will be automatically logged in via the VSC accountpage (see also Section\u00a0Applying for the account).</p>"}, {"location": "web_portal/#first-login", "title": "First login", "text": "<p>The first time you visit https://login.hpc.ugent.be permission will be requested to let the web portal access some of your personal information (VSC login ID, account status, login shell and institute name), as shown in this screenshot below:</p> <p> </p> <p>Please click \"Authorize\" here.</p> <p>This request will only be made once, you should not see this again afterwards.</p>"}, {"location": "web_portal/#start-page", "title": "Start page", "text": "<p>Once logged in, you should see this start page:</p> <p> </p> <p>This page includes a menu bar at the top, with buttons on the left providing access to the different features supported by the web portal, as well as a Help menu, your VSC account name, and a Log Out button on the top right, and the familiar HPC-UGent welcome message with a high-level overview of the HPC-UGent Tier-2 clusters.</p> <p>If your browser window is too narrow, the menu is available at the top right through the \"hamburger\" icon:</p> <p> </p>"}, {"location": "web_portal/#features", "title": "Features", "text": "<p>We briefly cover the different features provided by the web portal, going from left to right in the menu bar at the top.</p>"}, {"location": "web_portal/#file-browser", "title": "File browser", "text": "<p>Via the Files drop-down menu at the top left, you can browse through the files and directories in your VSC account using an intuitive interface that is similar to a local file browser, and manage, inspect or change them.</p> <p>The drop-down menu provides short-cuts to the different <code>$VSC_*</code> directories and filesystems you have access to. Selecting one of the directories will open a new browser tab with the File Explorer:</p> <p> </p> <p>Here you can:</p> <ul> <li> <p>Click a directory in the tree view on the left to open it;</p> </li> <li> <p>Use the buttons on the top to:</p> <ul> <li> <p>go to a specific subdirectory by typing in the path (via Go     To...);</p> </li> <li> <p>open the current directory in a terminal (shell) session (via     Open in Terminal);</p> </li> <li> <p>create a new file (via New File) or subdirectory (via New     Dir) in the current directory;</p> </li> <li> <p>upload files or directories from your local workstation into     your VSC account, in the currect directory (via Upload);</p> </li> <li> <p>show hidden files and directories, of which the name starts with     a dot (<code>.</code>) (via Show Dotfiles);</p> </li> <li> <p>show the owner and permissions in the file listing (via Show     Owner/Mode);</p> </li> </ul> </li> <li> <p>Double-click a directory in the file listing to open that directory;</p> </li> <li> <p>Select one or more files and/or directories in the file listing,     and:</p> <ul> <li> <p>use the View button to see the contents (use the button at the     top right to close the resulting popup window);</p> </li> <li> <p>use the Edit button to open a simple file editor in a new     browser tab which you can use to make changes to the selected     file and save them;</p> </li> <li> <p>use the Rename/Move button to rename or move the selected     files and/or directories to a different location in your VSC     account;</p> </li> <li> <p>use the Download button to download the selected files and     directories from your VSC account to your local workstation;</p> </li> <li> <p>use the Copy button to copy the selected files and/or     directories, and then use the Paste button to paste them in a     different location;</p> </li> <li> <p>use the (Un)Select All button to select (or unselect) all     files and directories in the current directory;</p> </li> <li> <p>use the Delete button to (permanently!) remove the selected files and     directories;</p> </li> </ul> </li> </ul> <p>For more information, see aslo https://www.osc.edu/resources/online_portals/ondemand/file_transfer_and_management.</p>"}, {"location": "web_portal/#job-management", "title": "Job management", "text": "<p>Via the Jobs menu item, you can consult your active jobs or submit new jobs using the Job Composer.</p> <p>For more information, see the sections below as well as https://www.osc.edu/resources/online_portals/ondemand/job_management.</p>"}, {"location": "web_portal/#active-jobs", "title": "Active jobs", "text": "<p>To get an overview of all your currently active jobs, use the Active Jobs menu item under Jobs.</p> <p>A new browser tab will be opened that shows all your current queued and/or running jobs:</p> <p> </p> <p>You can control which jobs are shown using the Filter input area, or select a particular cluster from the drop-down menu All Clusters, both at the top right.</p> <p>Jobs that are still queued or running can be deleted using the red button on the right.</p> <p>Completed jobs will also be visible in this interface, but only for a short amount of time after they have stopped running.</p> <p>For each listed job, you can click on the arrow ($&gt;$) symbol to get a detailed overview of that job, and get quick access to the corresponding output directory (via the Open in File Manager and Open in Terminal buttons at the bottom of the detailed overview).</p>"}, {"location": "web_portal/#job-composer", "title": "Job composer", "text": "<p>To submit new jobs, you can use the Job Composer menu item under Jobs. This will open a new browser tab providing an interface to create new jobs:</p> <p> </p> <p>This extensive interface allows you to create jobs from one of the available templates, or by copying an existing job.</p> <p>You can carefuly prepare your job and the corresponding job script via the Job Options button and by editing the job script (see lower right).</p> <p>Don't forget to actually submit your job to the system via the green Submit button!</p>"}, {"location": "web_portal/#job-templates", "title": "Job templates", "text": "<p>In addition, you can inspect provided job templates, copy them or even create your own templates via the Templates button on the top:</p> <p> </p>"}, {"location": "web_portal/#shell-access", "title": "Shell access", "text": "<p>Through the Shell Access button that is available under the Clusters menu item, you can easily open a terminal (shell) session into your VSC account, straight from your browser!</p> <p> </p> <p>Using this interface requires being familiar with a Linux shell environment (see Appendix\u00a0Useful Linux Commands).</p> <p>To exit the shell session, type <code>exit</code> followed by Enter and then close the browser tab.</p> <p>Note that you can not access a shell session after you closed a browser tab, even if you didn't exit the shell session first (unless you use terminal multiplexer tool like <code>screen</code> or <code>tmux</code>).</p>"}, {"location": "web_portal/#interactive-applications", "title": "Interactive applications", "text": ""}, {"location": "web_portal/#graphical-desktop-environment", "title": "Graphical desktop environment", "text": "<p>To create a graphical desktop environment, use on of the desktop on... node buttons under Interactive Apps menu item. For example:</p> <p> </p> <p>You can either start a desktop environment on a login node for some lightweight tasks, or on a workernode of one of the HPC-UGent Tier-2 clusters if more resources are required. Keep in mind that for desktop sessions on a workernode the regular queueing times are applicable dependent on requested resources.</p> <p>Do keep in mind that desktop environments on a cluster workernode are limited to a maximum of 72 hours, just like regular jobs are.</p> <p>To access the desktop environment, click the My Interactive Sessions menu item at the top, and then use the Launch desktop on ... node button if the desktop session is Running:</p> <p> </p>"}, {"location": "web_portal/#jupyter-notebook", "title": "Jupyter notebook", "text": "<p>Through the web portal you can easily start a Jupyter notebook on a workernode, via the Jupyter Notebook button under the Interactive Apps menu item.</p> <p> </p> <p>After starting the Jupyter notebook using the Launch button, you will see it being added in state Queued in the overview of interactive sessions (see My Interactive Sessions menu item):</p> <p> </p> <p>When your job hosting the Jupyter notebook starts running, the status will first change the Starting:</p> <p> </p> <p>and eventually the status will change to Running, and you will be able to connect to the Jupyter environment using the blue Connect to Jupyter button:</p> <p> </p> <p>This will launch the Jupyter environment in a new browser tab, where you can open an existing notebook by navigating to the directory where it located and clicking it, or using the New menu on the top right:</p> <p> </p> <p>Here's an example of a Jupyter notebook in action. Note that several non-standard Python packages (like numpy, scipy, pandas, matplotlib) are readily available:</p> <p> </p>"}, {"location": "web_portal/#restarting-your-web-server-in-case-of-problems", "title": "Restarting your web server in case of problems", "text": "<p>In case of problems with the web portal, it could help to restart the web server running in your VSC account.</p> <p>You can do this via the Restart Web Server button under the Help menu item:</p> <p> </p> <p>Of course, this only affects your own web portal session (not those of others).</p>"}, {"location": "x2go/", "title": "Graphical applications with X2Go", "text": "<p>X2Go is a graphical desktop software for Linux similar to VNC but with extra advantages. It does not require to execute a server in the login node and it is possible to setup a SSH proxy to connect to an specific login node. It can also be used to access Windows, Linux and macOS desktops. X2Go provides several advantages such:</p> <ol> <li> <p>A graphical remote desktop that works well over low bandwidth     connections.</p> </li> <li> <p>Copy/paste support from client to server and vice-versa.</p> </li> <li> <p>File sharing from client to server.</p> </li> <li> <p>Support for sound.</p> </li> <li> <p>Printer sharing from client to server.</p> </li> <li> <p>The ability to access single applications by specifying the name of     the desired executable like a terminal or an internet browser.</p> </li> </ol>"}, {"location": "x2go/#install-x2go-client", "title": "Install X2Go client", "text": "<p>X2Go is available for several operating systems. You can download the latest client from https://wiki.x2go.org/doku.php/doc:installation:x2goclient.</p> <p>X2Go requires a valid private SSH key to connect to the login node, this is described in How do SSH keys work?. This section also describes how to use X2Go client with a SSH agent. The SSH agent setup is optional but it is the easiest way to connect to the login nodes using several SSH keys and applications. Please see Using an SSH agent (optional) if you want to know how to setup an SSH agent in your system.</p>"}, {"location": "x2go/#create-a-new-x2go-session", "title": "Create a new X2Go session", "text": "<p>After the X2Go client installation just start the client. When you launch the client for the first time, it will start the new session dialogue automatically.</p> <p>There are two ways to connect to the login node:</p> <ul> <li> <p>Option A: A direct connection to \"login.hpc.ugent.be\". This is the simpler option,     the system will decide which login node to use based on a     load-balancing algorithm.</p> </li> <li> <p>Option B: You can use the node \"login.hpc.ugent.be\" as SSH proxy to connect to a     specific login node. Use this option if you want to resume an old     X2Go session.</p> </li> </ul>"}, {"location": "x2go/#option-a-direct-connection", "title": "Option A: direct connection", "text": "<p>This is the easier way to setup X2Go, a direct connection to the login node.</p> <p> </p> <ol> <li> <p>Include a session name. This will help you to identify the session     if you have more than one, you can choose any name (in our example     \"HPC login node\").</p> </li> <li> <p>Set the login hostname (In our case: \"login.hpc.ugent.be\")</p> </li> <li> <p>Set the Login name. In the example is \"vsc40000\" but you must change it by     your current VSC account.</p> </li> <li> <p>Set the SSH port (22 by default).</p> </li> <li> <p>Skip this step if you are using an SSH agent (see Install X2Go). If not add your     SSH private key into \"Use RSA/DSA key..\" field. In this case:</p> <ol> <li> <p>Click on the \"Use RSA/DSA..\" folder icon. This will open a file     browser.</p> <p> </p> </li> <li> <p>You should look for your private SSH key generated in Generating a public/private key pair. This file has     been stored in the directory \"~/.ssh/\" (by default \"id_rsa\").     \".ssh\" is an invisible directory, the Finder will not show it by     default. The easiest way to access the folder, is by pressing cmd+shift+g , which will allow you to enter the name of a directory, which     you would like to open in Finder. Here, type \"/.ssh\" and press     enter. Choose that file and click on open . </p> </li> </ol> </li> <li> <p>Check \"Try autologin\" option.</p> </li> <li> <p>Choose Session type to XFCE. Only the XFCE desktop is available for the     moment. It is also possible to choose single applications instead of     a full desktop, like the Terminal or Internet browser (you can change this option later     directly from the X2Go session tab if you want).</p> <ol> <li> <p>[optional]: Set a single application like Terminal instead of XFCE desktop.</p> <p> </p> </li> </ol> </li> <li> <p>[optional]: Change the session icon.</p> </li> <li> <p>Click the OK button after these changes.</p> </li> </ol>"}, {"location": "x2go/#option-b-use-the-login-node-as-ssh-proxy", "title": "Option B: use the login node as SSH proxy", "text": "<p>This option is useful if you want to resume a previous session or if you want to set explicitly the login node to use. In this case you should include a few more options. Use the same Option A setup but with these changes:</p> <p> </p> <ol> <li> <p>Include a session name. This will help you to identify the session     if you have more than one (in our example \"HPC UGent proxy login\").</p> </li> <li> <p>Set the login hostname. This is the login node that you want to use     at the end (In our case: \"gligar07.gastly.os\")</p> </li> <li> <p>Set \"Use Proxy server..\" to enable the proxy. Within \"Proxy section\"     set also these options:</p> <ol> <li> <p>Set Type \"SSH\", \"Same login\", \"Same Password\" and \"SSH agent\"     options.</p> </li> <li> <p>Set Host to \"login.hpc.ugent.be\" within \"Proxy Server\" section as well.</p> </li> <li> <p>Skip this step if you are using an SSH agent (see Install X2Go). Add your private     SSH key within \"RSA/DSA key\" field within \"Proxy Server\" as you     did for the server configuration (The \"RSA/DSA key\" field must     be set in both sections)</p> <p> </p> </li> <li> <p>Click the OK button after these changes.</p> </li> </ol> </li> </ol>"}, {"location": "x2go/#connect-to-your-x2go-session", "title": "Connect to your X2Go session", "text": "<p>Just click on any session that you already have to start/resume any session. It will take a few seconds to open the session the first time. It is possible to terminate a session if you logout from the current open session or if you click on the \"shutdown\" button from X2Go. If you want to suspend your session to continue working with it later just click on the \"pause\" icon.</p> <p> </p> <p>X2Go will keep the session open for you (but only if the login node is not rebooted).</p>"}, {"location": "x2go/#resume-a-previous-session", "title": "Resume a previous session", "text": "<p>If you want to re-connect to the same login node, or resume a previous session, you should know which login node were used at first place. You can get this information before logging out from your X2Go session. Just open a terminal and execute:</p> <pre><code>$ hostname\n</code></pre> <p></p> <p>This will give you the full login name (like \"gligar07.gastly.os\" but the hostname in your situation may be slightly different). You should set the same name to resume the session the next time. Just add this full hostname into \"login hostname\" section in your X2Go session (see Option B: use the login node as SSH proxy).</p>"}, {"location": "x2go/#connection-failed-with-x2go", "title": "Connection failed with X2Go", "text": "<p>If you get the error \"Connection failed session vscXXYYY-123-4567890123_xyzXFCE_dp32 terminated\" (or similar), It is possible that an old X2Go session remained on the login node. First, choose a different session type (for example TERMINAL), then start the X2Go session. A window will pop up, and you should see that a session is running. Select the session and terminate it. Then finish the session, choose again XFCE session (or whatever you use), then you should have your X2Go session. Since we have multiple login nodes, you might have to repeat these steps multiple times.</p>"}, {"location": "xdmod/", "title": "XDMoD portal", "text": "<p>The XDMoD web portal provides information about completed jobs, storage usage and the HPC UGent cloud infrastructure usage.</p> <p>To connect to the XDMoD portal, turn on your VPN connection to UGent and visit</p> <p> https://shieldon.ugent.be/xdmod </p> <p>Note that you may need to authorise XDMoD to obtain information from your VSC account through the VSC accountpage.</p> <p>After you log in for the first time, you can take the tour, where the web application shows you several features through a series of tips.</p> <p>Located in the upper right corner of the web page is the help button, taking you to the XDMoD User Manual. As things may change, we recommend checking out the provided documenation for information on XDMoD use:</p> <p> https://shieldon.ugent.be/xdmod/user_manual/index.php </p>"}, {"location": "2023/donphan-gallade/", "title": "New Tier-2 clusters: <code>donphan</code> and <code>gallade</code>", "text": "<p>In April 2023, two new clusters were added to the HPC-UGent Tier-2 infrastructure: <code>donphan</code> and <code>gallade</code>.</p> <p>This page provides some important information regarding these clusters, and how they differ from the clusters they are replacing (<code>slaking</code> and <code>kirlia</code>, respectively).</p> <p>If you have any questions on using <code>donphan</code> or <code>gallade</code>, you can contact the HPC-UGent team.</p> <p>For software installation requests, please use the request form.</p>"}, {"location": "2023/donphan-gallade/#donphan-debuginteractive-cluster", "title": "<code>donphan</code>: debug/interactive cluster", "text": "<p><code>donphan</code> is the new debug/interactive cluster.</p> <p>It replaces <code>slaking</code>, which will be retired on Monday 22 May 2023.</p> <p>It is primarily intended for interactive use: interactive shell sessions, using GUI applications through the HPC-UGent web portal, etc.</p> <p>This cluster consists of 12 workernodes, each with:</p> <ul> <li>2x 18-core Intel Xeon Gold 6240 (Cascade Lake @ 2.6 GHz) processor;</li> <li>one shared NVIDIA Ampere A2 GPU (16GB GPU memory)</li> <li>~738 GiB of RAM memory;</li> <li>1.6TB NVME local disk;</li> <li>HDR-100 InfiniBand interconnect;</li> <li>RHEL8 as operating system;</li> </ul> <p>To start using this cluster from a terminal session, first run: <pre><code>module swap cluster/donphan\n</code></pre></p> <p>You can also start (interactive) sessions on <code>donphan</code> using the HPC-UGent web portal.</p>"}, {"location": "2023/donphan-gallade/#differences-compared-to-slaking", "title": "Differences compared to <code>slaking</code>", "text": ""}, {"location": "2023/donphan-gallade/#cpus", "title": "CPUs", "text": "<p>The most important difference between <code>donphan</code> and <code>slaking</code> workernodes is in the CPUs: while <code>slaking</code> workernodes featured Intel Haswell CPUs, which support SSE*, AVX, and AVX2 vector instructions, <code>donphan</code> features Intel Cascade Lake CPUs, which also support AVX-512 instructions, on top of SSE*, AVX, and AVX2.</p> <p>Although software that was built on a <code>slaking</code> workernode with compiler options that enable architecture-specific optimizations (like GCC's <code>-march=native</code>, or Intel compiler's <code>-xHost</code>) should still run on a <code>donphan</code> workernode, it is recommended to recompile the software to benefit from the support for AVX-512 vector instructions.</p>"}, {"location": "2023/donphan-gallade/#cluster-size", "title": "Cluster size", "text": "<p>The <code>donphan</code> cluster is significantly bigger than <code>slaking</code>, both in terms of number of workernodes and number of cores per workernode, and hence the potential performance impact of oversubscribed cores (see below) is less likely to occur in practice.</p>"}, {"location": "2023/donphan-gallade/#user-limits-and-oversubscription-on-donphan", "title": "User limits and oversubscription on <code>donphan</code>", "text": "<p>By imposing strict user limits and using oversubscription on this cluster, we ensure that anyone can get a job running without having to wait in the queue, albeit with limited resources.</p> <p>The user limits for <code>donphan</code> include: * max. 5 jobs in queue; * max. 3 jobs running; * max. of 8 cores in total for running jobs; * max. 27GB of memory in total for running jobs;</p> <p>The job scheduler is configured with to allow oversubscription of the available cores, which means that jobs will continue to start even if all cores are already occupied by running jobs. While this prevents waiting time in the queue, it does imply that performance will degrade when all cores are occupied and additional jobs continue to start running.</p>"}, {"location": "2023/donphan-gallade/#shared-gpu-on-donphan-workernodes", "title": "Shared GPU on <code>donphan</code> workernodes", "text": "<p>Each <code>donphan</code> workernode includes a single NVIDIA A2 GPU that can be used for light compute workloads, and to accelerate certain graphical tasks.</p> <p>This GPU is shared across all jobs running on the workernode, and does not need to be requested explicitly (it is always available, similar to the local disk of the workernode).</p> <p>Warning</p> <p>Due to the shared nature of this GPU, you should assume that any data that is loaded in the GPU memory could potentially be accessed by other users, even after your processes have completed.</p> <p>There are no strong security guarantees regarding data protection when using this shared GPU!</p>"}, {"location": "2023/donphan-gallade/#gallade-large-memory-cluster", "title": "<code>gallade</code>: large-memory cluster", "text": "<p><code>gallade</code> is the new large-memory cluster.</p> <p>It replaces <code>kirlia</code>, which will be retired on Monday 22 May 2023.</p> <p>This cluster consists of 12 workernodes, each with:</p> <ul> <li>2x 64-core AMD EPYC 7773X (Milan-X @ 2.2 GHz) processor;</li> <li>~940 GiB of RAM memory;</li> <li>1.5TB NVME local disk;</li> <li>HDR-100 InfiniBand interconnect;</li> <li>RHEL8 as operating system;</li> </ul> <p>To start using this cluster from a terminal session, first run: <pre><code>module swap cluster/gallade\n</code></pre></p> <p>You can also start (interactive) sessions on <code>gallade</code> using the HPC-UGent web portal.</p>"}, {"location": "2023/donphan-gallade/#differences-compared-to-kirlia", "title": "Differences compared to <code>kirlia</code>", "text": ""}, {"location": "2023/donphan-gallade/#cpus_1", "title": "CPUs", "text": "<p>The most important difference between <code>gallade</code> and <code>kirlia</code> workernodes is in the CPUs: while <code>kirlia</code> workernodes featured Intel Cascade Lake CPUs, which support vector AVX-512 instructions (next to SSE*, AVX, and AVX2), <code>gallade</code> features AMD Milan-X CPUs, which implement the Zen3 microarchitecture and hence do not support AVX-512 instructions (but do support SSE*, AVX, and AVX2).</p> <p>As a result, software that was built on a <code>kirlia</code> workernode with compiler options that enable architecture-specific optimizations (like GCC's <code>-march=native</code>, or Intel compiler's <code>-xHost</code>) may not work anymore on a <code>gallade</code> workernode, and will produce <code>Illegal instruction</code> errors.</p> <p>Therefore, you may need to recompile software in order to use it on <code>gallade</code>. Even if software built on <code>kirlia</code> does still run on <code>gallade</code>, it is strongly recommended to recompile it anyway, since there may be signficant peformance benefits.</p>"}, {"location": "2023/donphan-gallade/#memory-per-core", "title": "Memory per core", "text": "<p>Although <code>gallade</code> workernodes have signficantly more RAM memory (~940 GiB) than <code>kirlia</code> workernodes had (~738 GiB), the average amount of memory per core is significantly lower on <code>gallade</code> than it was on <code>kirlia</code>, because a <code>gallade</code> workernode has 128 cores (so ~7.3 GiB per core on average), while a <code>kirlia</code> workernode had only 36 cores (so ~20.5 GiB per core on average).</p> <p>It is important to take this aspect into account when submitting jobs to <code>gallade</code>, especially when requesting all cores via <code>ppn=all</code>. You may need to explictly request more memory (see also here).</p>"}, {"location": "linux-tutorial/", "title": "Getting Started", "text": ""}, {"location": "linux-tutorial/#logging-in", "title": "Logging in", "text": "<p>To get started with the HPC-UGent infrastructure, you need to obtain a VSC account, see HPC manual. Keep in mind that you must keep your private key to yourself!</p> <p>You can look at your public/private key pair as a lock and a key: you give us the lock (your public key), we put it on the door, and then you can use your key to open the door and get access to the HPC infrastructure. Anyone who has your key can use your VSC account!</p> <p>Details on connecting to the HPC infrastructure are available in HPC manual connecting section.</p>"}, {"location": "linux-tutorial/#getting-help", "title": "Getting help", "text": "<p>To get help:</p> <ol> <li> <p>use the documentation available on the system, through the <code>help</code>,     <code>info</code> and <code>man</code> commands (use <code>q</code> to exit).     <pre><code>help cd\ninfo ls\nman cp\n</code></pre></p> </li> <li> <p>use Google</p> </li> <li> <p>contact hpc@ugent.be in case  of problems or questions (even for basic things!)</p> </li> </ol>"}, {"location": "linux-tutorial/#errors", "title": "Errors", "text": "<p>Sometimes when executing a command, an error occurs. Most likely there will be error output or a message explaining you this. Read this carefully and try to act on it. Try googling the error first to find any possible solution, but if you can't come up with something in 15 minutes, don't hesitate to mail hpc@ugent.be.</p>"}, {"location": "linux-tutorial/#basic-terminal-usage", "title": "Basic terminal usage", "text": "<p>The basic interface is the so-called shell prompt, typically ending with <code>$</code> (for <code>bash</code> shells).</p> <p>You use the shell by executing commands, and hitting <code>&lt;enter&gt;</code>. For example:</p> <pre><code>$ echo hello\nhello\n</code></pre> <p>You can go to the start or end of the command line using <code>Ctrl-A</code> or <code>Ctrl-E</code>.</p> <p>To go through previous commands, use <code>&lt;up&gt;</code> and <code>&lt;down&gt;</code>, rather than retyping them.</p>"}, {"location": "linux-tutorial/#command-history", "title": "Command history", "text": "<p>A powerful feature is that you can \"search\" through your command history, either using the <code>history</code> command, or using <code>Ctrl-R</code>:</p> <pre><code>$ history\n    1 echo hello\n\n# hit Ctrl-R, type 'echo' \n(reverse-i-search)`echo': echo hello\n</code></pre>"}, {"location": "linux-tutorial/#stopping-commands", "title": "Stopping commands", "text": "<p>If for any reason you want to stop a command from executing, press <code>Ctrl-C</code>. For example, if a command is taking too long, or you want to rerun it with different arguments.</p>"}, {"location": "linux-tutorial/#variables", "title": "Variables", "text": "<p>At the prompt we also have access to shell variables, which have both a name and a value.</p> <p>They can be thought of as placeholders for things we need to remember.</p> <p>For example, to print the path to your home directory, we can use the shell variable named <code>HOME</code>:</p> <pre><code>$ echo $HOME\n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>This prints the value of this variable.</p>"}, {"location": "linux-tutorial/#defining-variables", "title": "Defining variables", "text": "<p>There are several variables already defined for you when you start your session, such as <code>$HOME</code> which contains the path to your home directory.</p> <p>For a full overview of defined environment variables in your current session, you can use the <code>env</code> command. You can sort this output with <code>sort</code> to make it easier to search in:</p> <pre><code>$ env | sort\n...\nHOME=/user/home/gent/vsc400/vsc40000\n...\n</code></pre> <p>You can also use the <code>grep</code> command to search for a piece of text. The following command will output all VSC-specific variable names and their values:</p> <pre><code>$ env | sort | grep VSC</code></pre> <p>But we can also define our own. this is done with the <code>export</code> command (note: variables are always all-caps as a convention):</p> <pre><code>$ export MYVARIABLE=\"value\"</code></pre> <p>It is important you don't include spaces around the <code>=</code> sign. Also note the lack of <code>$</code> sign in front of the variable name.</p> <p>If we then do</p> <pre><code>$ echo $MYVARIABLE</code></pre> <p>this will output <code>value</code>. Note that the quotes are not included, they were only used when defining the variable to escape potential spaces in the value.</p>"}, {"location": "linux-tutorial/#changing-your-prompt-using-ps1", "title": "Changing your prompt using <code>$PS1</code>", "text": "<p>You can change what your prompt looks like by redefining the special-purpose variable <code>$PS1</code>.</p> <p>For example: to include the current location in your prompt:</p> <pre><code>$ export PS1='\\w $'\n~ $ cd test\n~/test $\n</code></pre> <p>Note that <code>~</code> is short representation of your home directory.</p> <p>To make this persistent across session, you can define this custom value for <code>$PS1</code> in your <code>.profile</code> startup script:</p> <pre><code>$ echo 'export PS1=\"\\w $ \" ' &gt;&gt; ~/.profile</code></pre>"}, {"location": "linux-tutorial/#using-non-defined-variables", "title": "Using non-defined variables", "text": "<p>One common pitfall is the (accidental) use of non-defined variables. Contrary to what you may expect, this does not result in error messages, but the variable is considered to be empty instead.</p> <p>This may lead to surprising results, for example:</p> <pre><code>$ export WORKDIR=/tmp/test\n$ pwd\n/user/home/gent/vsc400/vsc40000\n$ echo $HOME\n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>To understand what's going on here, see the section on <code>cd</code> below.</p> <p>The moral here is: be very careful to not use empty variables unintentionally.</p> <p>Tip for job scripts: use <code>set -e -u</code> to avoid using empty variables accidentally.</p> <p>The <code>-e</code> option will result in the script getting stopped if any command fails.</p> <p>The <code>-u</code> option will result in the script getting stopped if empty variables are used. (see https://ss64.com/bash/set.html for a more detailed explanation and more options)</p> <p>More information can be found at http://www.tldp.org/LDP/abs/html/variables.html.</p>"}, {"location": "linux-tutorial/#restoring-your-default-environment", "title": "Restoring your default environment", "text": "<p>If you've made a mess of your environment, you shouldn't waste too much time trying to fix it. Just log out and log in again and you will be given a pristine environment.</p>"}, {"location": "linux-tutorial/#basic-system-information", "title": "Basic system information", "text": "<p>Basic information about the system you are logged into can be obtained in a variety of ways.</p> <p>We limit ourselves to determining the hostname:</p> <pre><code>$ hostname\ngligar01.gligar.os\n\n$ echo $HOSTNAME\ngligar01.gligar.os\n</code></pre> <p>And querying some basic information about the Linux kernel:</p> <pre><code>$ uname -a\nLinux gligar01.gligar.os 2.6.32-573.8.1.el6.ug.x86_64 #1 SMP Mon Nov 16 15:12:09\n    CET 2015 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre>"}, {"location": "linux-tutorial/#exercises", "title": "Exercises", "text": "<ul> <li> <p>Print the full path to your home directory</p> </li> <li> <p>Determine the name of the environment variable to your personal     scratch directory</p> </li> <li> <p>What's the name of the system you're logged into? Is it the same for     everyone?</p> </li> <li> <p>Figure out how to print the value of a variable without including a     newline</p> </li> <li> <p>How do you get help on using the <code>man</code> command?</p> </li> </ul>"}, {"location": "linux-tutorial/beyond_the_basics/", "title": "Beyond the basics", "text": "<p>Now that you've seen some of the more basic commands, let's take a look at some of the deeper concepts and commands.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#inputoutput", "title": "Input/output", "text": "<p>To redirect output to files, you can use the redirection operators: <code>&gt;</code>, <code>&gt;&gt;</code>, <code>&amp;&gt;</code>, and <code>&lt;</code>.</p> <p>First, it's important to make a distinction between two different output channels:</p> <ol> <li> <p><code>stdout</code>: standard output channel, for regular output</p> </li> <li> <p><code>stderr</code>: standard error channel, for errors and warnings</p> </li> </ol>"}, {"location": "linux-tutorial/beyond_the_basics/#redirecting-stdout", "title": "Redirecting <code>stdout</code>", "text": "<p><code>&gt;</code> writes the (<code>stdout</code>) output of a command to a file and overwrites whatever was in the file before.</p> <pre><code>$ echo hello &gt; somefile\n$ cat somefile\nhello\n$ echo hello2 &gt; somefile\n$ cat somefile\nhello2\n</code></pre> <p><code>&gt;&gt;</code> appends the (<code>stdout</code>) output of a command to a file; it does not clobber whatever was in the file before:</p> <pre><code>$ echo hello &gt; somefile\n$ cat somefile \nhello\n$ echo hello2 &gt;&gt; somefile\n$ cat somefile\nhello\nhello2\n</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#reading-from-stdin", "title": "Reading from <code>stdin</code>", "text": "<p><code>&lt;</code> reads a file from standard input (piped or typed input). So you would use this to simulate typing into a terminal. <code>&lt; somefile.txt</code> is largely equivalent to <code>cat somefile.txt |</code>.</p> <p>One common use might be to take the results of a long-running command and store the results in a file, so you don't have to repeat it while you refine your command line. For example, if you have a large directory structure you might save a list of all the files you're interested in and then reading in the file list when you are done:</p> <pre><code>$ find . -name .txt &gt; files\n$ xargs grep banana &lt; files\n</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#redirecting-stderr", "title": "Redirecting <code>stderr</code>", "text": "<p>To redirect the <code>stderr</code> output (warnings, messages), you can use <code>2&gt;</code>, just like <code>&gt;</code></p> <pre><code>$ ls one.txt nosuchfile.txt 2&gt; errors.txt\none.txt\n$ cat errors.txt\nls: nosuchfile.txt: No such file or directory\n</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#combining-stdout-and-stderr", "title": "Combining <code>stdout</code> and <code>stderr</code>", "text": "<p>To combine both output channels (<code>stdout</code> and <code>stderr</code>) and redirect them to a single file, you can use <code>&amp;&gt;</code></p> <pre><code>$ ls one.txt nosuchfile.txt &amp;&gt; ls.out\n$ cat ls.out\nls: nosuchfile.txt: No such file or directory\none.txt\n</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#command-piping", "title": "Command piping", "text": "<p>Part of the power of the command line is to string multiple commands together to create useful results. The core of these is the pipe: <code>|</code>. For example, to see the number of files in a directory, we can pipe the (<code>stdout</code>) output of <code>ls</code> to <code>wc</code> (word count, but can also be used to count the number of lines with the <code>-l</code> flag).</p> <pre><code>$ ls | wc -l\n    42\n</code></pre> <p>A common pattern is to pipe the output of a command to <code>less</code> so you can examine or search the output:</p> <pre><code>$ find . | less</code></pre> <p>Or to look through your command history:</p> <pre><code>$ history | less</code></pre> <p>You can put multiple pipes in the same line. For example, which <code>cp</code> commands have we run?</p> <pre><code>$ history | grep cp | less</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#shell-expansion", "title": "Shell expansion", "text": "<p>The shell will expand certain things, including:</p> <ol> <li> <p><code>*</code> wildcard: for example <code>ls t*txt</code> will list all files starting     with 't' and ending in 'txt'</p> </li> <li> <p>tab completion: hit the <code>&lt;tab&gt;</code> key to make the shell complete your     command line; works for completing file names, command names, etc.</p> </li> <li> <p><code>$...</code> or <code>${...}</code>: environment variables will be replaced with     their value; example: <code>echo \"I am $USER\"</code> or <code>echo \"I am ${USER}\"</code></p> </li> <li> <p>square brackets can be used to list a number of options for a     particular characters;  example: <code>ls *.[oe][0-9]</code>.  This will list all     files starting with whatever characters (<code>*</code>), then a dot (<code>.</code>),     then either an 'o' or an 'e' (<code>[oe]</code>), then a character from '0' to     '9' (so any digit) (<code>[0-9]</code>). So this filename will match:     <code>anything.o5</code>, but this one won't: <code>anything.o52</code>.</p> </li> </ol>"}, {"location": "linux-tutorial/beyond_the_basics/#process-information", "title": "Process information", "text": ""}, {"location": "linux-tutorial/beyond_the_basics/#ps-and-pstree", "title": "<code>ps</code> and <code>pstree</code>", "text": "<p><code>ps</code> lists processes running. By default, it will only show you the processes running in the local shell. To see all of your processes running on the system, use:</p> <pre><code>$ ps -fu $USER</code></pre> <p>To see all the processes:</p> <pre><code>$ ps -elf</code></pre> <p>To see all the processes in a forest view, use:</p> <pre><code>$ ps auxf</code></pre> <p>The last two will spit out a lot of data, so get in the habit of piping it to <code>less</code>.</p> <p><code>pstree</code> is another way to dump a tree/forest view. It looks better than <code>ps auxf</code> but it has much less information so its value is limited.</p> <p><code>pgrep</code> will find all the processes where the name matches the pattern and print the process IDs (PID). This is used in piping the processes together as we will see in the next section.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#kill", "title": "<code>kill</code>", "text": "<p><code>ps</code> isn't very useful unless you can manipulate the processes. We do this using the <code>kill</code> command. Kill will send a message (SIGINT) to the process to ask it to stop.</p> <pre><code>$ kill 1234\n$ kill $(pgrep misbehaving_process)\n</code></pre> <p>Usually, this ends the process, giving it the opportunity to flush data to files, etc. However, if the process ignored your signal, you can send it a different message (SIGKILL) which the OS will use to unceremoniously terminate the process:</p> <pre><code>$ kill -9 1234\n</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#top", "title": "<code>top</code>", "text": "<p><code>top</code> is a tool to see the current status of the system. You've probably used something similar in Task Manager on Windows or Activity Monitor in macOS. <code>top</code> will update every second and has a few interesting commands.</p> <p>To see only your processes, type <code>u</code> and your username after starting <code>top</code>, (you can also do this with  <code>top -u $USER</code> ). The default is to sort the display by <code>%CPU</code>. To change the sort order, use <code>&lt;</code> and <code>&gt;</code> like arrow keys.</p> <p>There are a lot of configuration options in <code>top</code>, but if you're interested in seeing a nicer view, you can run <code>htop</code> instead. Be aware that it's not installed everywhere, while <code>top</code> is.</p> <p>To exit <code>top</code>, use <code>q</code> (for 'quit').</p> <p>For more information, see Brendan Gregg's excellent site dedicated to performance analysis.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#ulimit", "title": "ulimit", "text": "<p><code>ulimit</code> is a utility to get or set user limits on the machine. For example, you may be limited to a certain number of processes. To see all the limits that have been set, use:</p> <pre><code>$ ulimit -a</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#counting-wc", "title": "Counting: <code>wc</code>", "text": "<p>To count the number of lines, words, and characters (or bytes) in a file, use <code>wc</code> (word ount):</p> <pre><code>$ wc example.txt\n      90     468     3189   example.txt\n</code></pre> <p>The output indicates that the file named <code>example.txt</code> contains 90 lines, 468 words, and 3189 characters/bytes.</p> <p>To only count the number of lines, use <code>wc -l</code>:</p> <pre><code>$ wc -l example.txt\n      90    example.txt\n</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#searching-file-contents-grep", "title": "Searching file contents: <code>grep</code>", "text": "<p><code>grep</code> is an important command. It was originally an abbreviation for \"globally search a regular expression and print\" but it's entered the common computing lexicon and people use 'grep' to mean searching for anything. To use grep, you give a pattern and a list of files.</p> <pre><code>$ grep banana fruit.txt\n$ grep banana fruit_bowl1.txt fruit_bowl2.txt\n$ grep banana fruit*txt\n</code></pre> <p><code>grep</code> also lets you search for Regular Expressions, but these are not in scope for this introductory text.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#cut", "title": "<code>cut</code>", "text": "<p><code>cut</code> is used to pull fields out of files or pipes streams. It's a useful glue when you mix it with <code>grep</code> because <code>grep</code> can find the lines where a string occurs and <code>cut</code> can pull out a particular field. For example, to pull the first column (<code>-f 1</code>, the first field) from (an unquoted) CSV (comma-separated values, so <code>-d ','</code>: delimited by <code>,</code>) file, you can use the following:</p> <pre><code>$ cut -f 1 -d ',' mydata.csv</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#sed", "title": "<code>sed</code>", "text": "<p><code>sed</code> is the stream editor. It is used to replace text in a file or piped stream. In this way, it works like grep, but instead of just searching, it can also edit files. This is like \"Search and Replace\" in a text editor. <code>sed</code> has a lot of features, but almost everyone uses the extremely basic version of string replacement:</p> <pre><code>$ sed 's/oldtext/newtext/g' myfile.txt</code></pre> <p>By default, sed will just print the results. If you want to edit the file inplace, use <code>-i</code>, but be very careful that the results will be what you want before you go around destroying your data!</p>"}, {"location": "linux-tutorial/beyond_the_basics/#awk", "title": "<code>awk</code>", "text": "<p><code>awk</code> is a basic language that builds on <code>sed</code> to do much more advanced stream editing. Going in depth is far out of scope of this tutorial, but there are two examples that are worth knowing.</p> <p>First, <code>cut</code> is very limited in pulling fields apart based on whitespace. For example, if you have padded fields then <code>cut -f 4 -d ' '</code> will almost certainly give you a headache as there might be an uncertain number of spaces between each field. <code>awk</code> does better whitespace splitting. So, pulling out the fourth field in a whitespace delimited file is as follows:</p> <pre><code>$ awk '{print $4}' mydata.dat</code></pre> <p>You can use <code>-F ':'</code> to change the delimiter (F for field separator).</p> <p>The next example is used to sum numbers from a field:</p> <pre><code>$ awk -F ',' '{sum += $1} END {print sum}' mydata.csv</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#basic-shell-scripting", "title": "Basic Shell Scripting", "text": "<p>The basic premise of a script is to execute automate the execution of multiple commands. If you find yourself repeating the same commands over and over again, you should consider writing one script to do the same. A script is nothing special, it is just a text file like any other. Any commands you put in there will be executed from the top to bottom.</p> <p>However, there are some rules you need to abide by.</p> <p>Here is a very detailed guide should you need more information.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#shebang", "title": "Shebang", "text": "<p>The first line of the script is the so-called shebang (<code>#</code> is sometimes called hash and <code>!</code> is sometimes called bang). This line tells the shell which command should execute the script. In most cases, this will simply be the shell itself. The line itself looks a bit weird, but you can copy-paste this line as you need not worry about it further. It is however very important this is the very first line of the script! These are all valid shebangs, but you should only use one of them:</p> <p><pre><code>#!/bin/sh\n</code></pre> <pre><code>#!/bin/bash\n</code></pre> <pre><code>#!/usr/bin/env bash\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#conditionals", "title": "Conditionals", "text": "<p>Sometimes you only want certain commands to be executed when a certain condition is met. For example, only move files to a directory if that directory exists. The syntax: <pre><code>if [ -d directory ] &amp;&amp; [ -f file ]\nthen mv file directory fi\n\nOr you only want to do something if a file exists:\n\nif [ -f filename ] then echo \"it exists\" fi\n</code></pre> Or only if a certain variable is bigger than one: <pre><code>if [ $AMOUNT -gt 1 ]\nthen\necho \"More than one\"\n# more commands\nfi\n</code></pre> Several pitfalls exist with this syntax. You need spaces surrounding the brackets, the then needs to be at the beginning of a line. It is best to just copy this example and modify it.</p> <p>In the initial example, we used <code>-d</code> to test if a directory existed. There are several more checks.</p> <p>Another useful example, is to test if a variable contains a value (so it's not empty): <pre><code>if [ -z $PBS_ARRAYID ]\nthen\necho \"Not an array job, quitting.\"\nexit 1\nfi\n</code></pre></p> <p>the <code>-z</code> will check if the length of the variable's value is greater than zero.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#loops", "title": "Loops", "text": "<p>Are you copy-pasting commands? Are you doing the same thing with just different options? You most likely can simplify your script by using a loop.</p> <p>Let's look at a simple example: <pre><code>for i in 1 2 3\ndo\necho $i\ndone\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#subcommands", "title": "Subcommands", "text": "<p>Subcommands are used all the time in shell scripts. What they do is storing the output of a command in a variable. So this can later be used in a conditional or a loop for example.</p> <pre><code>CURRENTDIR=`pwd`  # using backticks\nCURRENTDIR=$(pwd)  # recommended (easier to type)\n</code></pre> <p>In the above example you can see the 2 different methods of using a subcommand. <code>pwd</code> will output the current working directory, and its output will be stored in the CURRENTDIR variable. The recommended way to use subcommands is with the <code>$()</code> syntax.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#errors", "title": "Errors", "text": "<p>Sometimes some things go wrong and a command or script you ran causes an error. How do you properly deal with these situations?</p> <p>Firstly a useful thing to know for debugging and testing is that you can run any command like this:</p> <pre><code>command 2&gt;&amp;1 output.log   # one single output file, both output and errors</code></pre> <p>If you add <code>2&gt;&amp;1 output.log</code> at the end of any command, it will combine <code>stdout</code> and <code>stderr</code>, outputting it into a single file named <code>output.log</code>.</p> <p>If you want regular and error output separated you can use:</p> <pre><code>command &gt; output.log 2&gt; output.err  # errors in a separate file</code></pre> <p>this will write regular output to <code>output.log</code> and error output to <code>output.err</code>.</p> <p>You can then look for the errors with <code>less</code> or search for specific text with <code>grep</code>.</p> <p>In scripts, you can use:</p> <pre><code>set -e</code></pre> <p>This will tell the shell to stop executing any subsequent commands when a single command in the script fails. This is most convenient as most likely this causes the rest of the script to fail as well.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#advanced-error-checking", "title": "Advanced error checking", "text": "<p>Sometimes you want to control all the error checking yourself, this is also possible. Everytime you run a command, a special variable <code>$?</code> is used to denote successful completion of the command. A value other than zero signifies something went wrong. So an example use case: <pre><code>command_with_possible_error\nexit_code=$?  # capture exit code of last command\nif [ $exit_code -ne 0 ]\nthen\necho \"something went wrong\"\nfi\n</code></pre></p>"}, {"location": "linux-tutorial/beyond_the_basics/#bashrc-login-script", "title": "<code>.bashrc</code> login script", "text": "<p>If you have certain commands executed every time you log in (which includes every time a job starts), you can add them to your <code>$HOME/.bashrc</code> file. This file is a shell script that gets executed every time you log in.</p> <p>Examples include:</p> <ul> <li> <p>modifying your <code>$PS1</code> (to tweak your shell prompt)</p> </li> <li> <p>printing information about the current/jobs environment (echoing     environment variables, etc.)</p> </li> <li> <p>selecting a specific cluster to run on with     <code>module swap cluster/...</code></p> </li> </ul> <p>Some recommendations:</p> <ul> <li> <p>Avoid using <code>module load</code> statements in your <code>$HOME/.bashrc</code> file</p> </li> <li> <p>Don't directly edit your <code>.bashrc</code> file: if there's an error in your     <code>.bashrc</code> file, you might not be able to log in again. To     prevent that, use another file to test your changes, then copy them     over when you tested the script.</p> </li> </ul>"}, {"location": "linux-tutorial/beyond_the_basics/#scripting-for-the-cluster", "title": "Scripting for the cluster", "text": "<p>When writing scripts to be submitted on the cluster there are some tricks you need to keep in mind.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#example-job-script", "title": "Example job script", "text": "<pre><code>#!/bin/bash\n#PBS -l nodes=1:ppn=1\n#PBS -N FreeSurfer_per_subject-time-longitudinal\n#PBS -l walltime=48:00:00\n#PBS -q long\n#PBS -m abe\n#PBS -j oe\nexport DATADIR=$VSC_DATA/example\n# $PBS_JOBID is unique for each job, so this creates a unique directory\nexport WORKDIR=$VSC_SCRATCH_NODE/$PBS_JOBID\nmkdir -p $WORKDIR\n# copy files to local storage\ncp -a $DATADIR/workfiles $WORKDIR/\n\n# load software we need\nmodule load FreeSurfer\ncd $WORKDIR\n# recon-all ... &amp;&gt; output.log  # this command takes too long, let's show a more practical example\necho $PBS_ARRAYID &gt; $WORKDIR/$PBS_ARRAYID.txt\n# create results directory if necessary\nmkdir -p $DATADIR/results\n# copy work files back\ncp $WORKDIR/$PBS_ARRAYID.txt $DATADIR/results/\n</code></pre>"}, {"location": "linux-tutorial/beyond_the_basics/#pbs-pragmas", "title": "PBS pragmas", "text": "<p>The scheduler needs to know about the requirements of the script, for example: how much memory will it use, and how long will it run. These things can be specified inside a script with what we call PBS pragmas.</p> <p>This pragma (a pragma is a special comment) tells PBS to use 1 node and core: <pre><code>#PBS -l nodes=1:ppn=1 # single-core\n</code></pre></p> <p>For parallel software, you can request multiple cores (OpenMP) and/or multiple nodes (MPI). Only use this when the software you use is capable of working in parallel. Here is an example: <pre><code>#PBS -l nodes=1:ppn=16  # single-node, multi-core\n#PBS -l nodes=5:ppn=16  # multi-node\n</code></pre></p> <p>We intend to submit it on the long queue: <pre><code>#PBS -q long\n</code></pre></p> <p>We request a total running time of 48 hours (2 days). <pre><code>#PBS -l walltime=48:00:00\n</code></pre></p> <p>We specify a desired name of our job: <pre><code>#PBS -N FreeSurfer_per_subject-time-longitudinal\n</code></pre> This specifies mail options: <pre><code>#PBS -m abe\n</code></pre></p> <ol> <li> <p><code>a</code> means mail is sent when the job is aborted.</p> </li> <li> <p><code>b</code> means mail is sent when the job begins.</p> </li> <li> <p><code>e</code> means mail is sent when the job ends.</p> </li> </ol> <p>Joins error output with regular output: <pre><code>#PBS -j oe\n</code></pre></p> <p>All of these options can also be specified on the command-line and will overwrite any pragmas present in the script.</p>"}, {"location": "linux-tutorial/beyond_the_basics/#exercises", "title": "Exercises", "text": "<ol> <li> <p>Create a file that contains this message: \"Hello, I am &lt;user&gt;\",     where <code>&lt;user&gt;</code> is replaced by your username. Don't cheat by using an     editor, use a command to create the file.</p> </li> <li> <p>Use another command to add this line to the same file: \"I am on     system &lt;hostname&gt; in directory &lt;current\u00a0directory&gt;\". Words     between <code>&lt;&gt;</code> should be replaced with their value (hint: use     environment variables).</p> </li> <li> <p>How many files and directories are in <code>/tmp</code>?</p> </li> <li> <p>What's the name of the 5th file/directory in alphabetical order in     <code>/tmp</code>?</p> </li> <li> <p>List all files that start with <code>t</code> in <code>/tmp</code>.</p> </li> <li> <p>Create a file containing \"My home directory &lt;home&gt; is available     using $HOME\". <code>&lt;home&gt;</code> should be replaced with your home directory,     but <code>$HOME</code> should remain as-is.</p> </li> <li> <p>How many processes are you currently running? How many are you     allowed to run? Where are they coming from?</p> </li> </ol>"}, {"location": "linux-tutorial/common_pitfalls/", "title": "Common Pitfalls", "text": ""}, {"location": "linux-tutorial/common_pitfalls/#files", "title": "Files", "text": ""}, {"location": "linux-tutorial/common_pitfalls/#location", "title": "Location", "text": "<p>If you receive an error message which contains something like the following: <pre><code>No such file or directory\n</code></pre></p> <p>It probably means that you haven't placed your files in the correct directory, or you have mistyped the file name or path.</p> <p>Try and figure out the correct location using <code>ls</code>, <code>cd</code> and using the different <code>$VSC_*</code> variables.</p>"}, {"location": "linux-tutorial/common_pitfalls/#spaces", "title": "Spaces", "text": "<p>Filenames should not contain any spaces! If you have a long filename you should use underscores or dashes (e.g., <code>very_long_filename</code>).</p> <pre><code>$ cat some file\nNo such file or directory 'some'\n</code></pre> <p>Spaces are permitted, however they result in surprising behaviour. To cat the file <code>'some file'</code> as above, you can escape the space with a backslash (\"<code>\\</code>\") or you can put the filename in quotes:</p> <pre><code>$ cat some\\ file\n...\n$ cat \"some file\"\n...\n</code></pre> <p>This is especially error prone if you are piping results of <code>find</code>:</p> <pre><code>$ find . -type f | xargs cat\nNo such file or directory name \u2019some\u2019\nNo such file or directory name \u2019file\u2019\n</code></pre> <p>This can be worked around using the <code>-print0</code> flag:</p> <pre><code>$ find . -type f -print0 | xargs -0 cat\n...\n</code></pre> <p>But, this is tedious, and you can prevent errors by simply colouring within the lines and not using spaces in filenames.</p>"}, {"location": "linux-tutorial/common_pitfalls/#missingmistyped-environment-variables", "title": "Missing/mistyped environment variables", "text": "<p>If you use a command like <code>rm -r</code> with environment variables you need to be careful to make sure that the environment variable exists. If you mistype an environment variable then it will resolve into a blank string. This means the following resolves to <code>rm -r ~/*</code> which will remove every file in your home directory!</p> <pre><code>$ rm -r ~/$PROJETC/*</code></pre>"}, {"location": "linux-tutorial/common_pitfalls/#typing-dangerous-commands", "title": "Typing dangerous commands", "text": "<p>A good habit when typing dangerous commands is to precede the line with <code>#</code>, the comment character. This will let you type out the command without fear of accidentally hitting enter and running something unintended.</p> <pre><code>$ #rm -r ~/$POROJETC/*</code></pre> <p>Then you can go back to the beginning of the line (<code>Ctrl-A</code>) and remove the first character (<code>Ctrl-D</code>) to run the command. You can also just press enter to put the command in your history so you can come back to it later (e.g., while you go check the spelling of your environment variables).</p>"}, {"location": "linux-tutorial/common_pitfalls/#permissions", "title": "Permissions", "text": "<pre><code>$ ls -l script.sh # File with correct permissions\n-rwxr-xr-x 1 vsc40000 vsc40000 2983 Jan 30 09:13 script.sh\n$ ls -l script.sh # File with incorrect permissions\n-rw-r--r-- 1 vsc40000 vsc40000 2983 Jan 30 09:13 script.sh\n</code></pre> <p>Before submitting the script, you'll need to add execute permissions to make sure it can be executed:</p> <pre><code>$ chmod +x script_name.sh</code></pre>"}, {"location": "linux-tutorial/common_pitfalls/#help", "title": "Help", "text": "<p>If you stumble upon an error, don't panic! Read the error output, it might contain a clue as to what went wrong. You can copy the error message into Google (selecting a small part of the error without filenames). It can help if you surround your search terms in double quotes (for example <code>\"No such file or directory\"</code>), that way Google will consider the error as one thing, and won't show results just containing these words in random order.</p> <p>If you need help about a certain command, you should consult its so-called \"man page\":</p> <pre><code>$ man command</code></pre> <p>This will open the manual of this command. This manual contains detailed explanation of all the options the command has. Exiting the manual is done by pressing 'q'.</p> <p>Don't be afraid to contact hpc@ugent.be. They are here to help and will do so for even the  smallest of problems!</p>"}, {"location": "linux-tutorial/common_pitfalls/#more-information", "title": "More information", "text": "<ol> <li> <p>Unix Power Tools - A fantastic  book about most of these tools (see also The Second Edition)</p> </li> <li> <p>http://linuxcommand.org/: A great place to start with many     examples. There is an associated book which gets a lot of good     reviews</p> </li> <li> <p>The Linux Documentation Project -     More guides on various topics relating to the Linux command line</p> </li> <li> <p>basic shell     usage</p> </li> <li> <p>Bash for     beginners</p> </li> <li> <p>MOOC</p> </li> </ol>"}, {"location": "linux-tutorial/common_pitfalls/#q-a", "title": "Q &amp; A", "text": "<p>Please don't hesitate to contact in case of questions or problems.</p>"}, {"location": "linux-tutorial/getting_started/", "title": "Getting Started", "text": ""}, {"location": "linux-tutorial/getting_started/#logging-in", "title": "Logging in", "text": "<p>To get started with the HPC-UGent infrastructure, you need to obtain a VSC account, see HPC manual. Keep in mind that you must keep your private key to yourself!</p> <p>You can look at your public/private key pair as a lock and a key: you give us the lock (your public key), we put it on the door, and then you can use your key to open the door and get access to the HPC infrastructure. Anyone who has your key can use your VSC account!</p> <p>Details on connecting to the HPC infrastructure are available in HPC manual connecting section.</p>"}, {"location": "linux-tutorial/getting_started/#getting-help", "title": "Getting help", "text": "<p>To get help:</p> <ol> <li> <p>use the documentation available on the system, through the <code>help</code>,     <code>info</code> and <code>man</code> commands (use <code>q</code> to exit).     <pre><code>help cd\ninfo ls\nman cp\n</code></pre></p> </li> <li> <p>use Google</p> </li> <li> <p>contact hpc@ugent.be in case  of problems or questions (even for basic things!)</p> </li> </ol>"}, {"location": "linux-tutorial/getting_started/#errors", "title": "Errors", "text": "<p>Sometimes when executing a command, an error occurs. Most likely there will be error output or a message explaining you this. Read this carefully and try to act on it. Try googling the error first to find any possible solution, but if you can't come up with something in 15 minutes, don't hesitate to mail hpc@ugent.be.</p>"}, {"location": "linux-tutorial/getting_started/#basic-terminal-usage", "title": "Basic terminal usage", "text": "<p>The basic interface is the so-called shell prompt, typically ending with <code>$</code> (for <code>bash</code> shells).</p> <p>You use the shell by executing commands, and hitting <code>&lt;enter&gt;</code>. For example:</p> <pre><code>$ echo hello\nhello\n</code></pre> <p>You can go to the start or end of the command line using <code>Ctrl-A</code> or <code>Ctrl-E</code>.</p> <p>To go through previous commands, use <code>&lt;up&gt;</code> and <code>&lt;down&gt;</code>, rather than retyping them.</p>"}, {"location": "linux-tutorial/getting_started/#command-history", "title": "Command history", "text": "<p>A powerful feature is that you can \"search\" through your command history, either using the <code>history</code> command, or using <code>Ctrl-R</code>:</p> <pre><code>$ history\n    1 echo hello\n\n# hit Ctrl-R, type 'echo' \n(reverse-i-search)`echo': echo hello\n</code></pre>"}, {"location": "linux-tutorial/getting_started/#stopping-commands", "title": "Stopping commands", "text": "<p>If for any reason you want to stop a command from executing, press <code>Ctrl-C</code>. For example, if a command is taking too long, or you want to rerun it with different arguments.</p>"}, {"location": "linux-tutorial/getting_started/#variables", "title": "Variables", "text": "<p>At the prompt we also have access to shell variables, which have both a name and a value.</p> <p>They can be thought of as placeholders for things we need to remember.</p> <p>For example, to print the path to your home directory, we can use the shell variable named <code>HOME</code>:</p> <pre><code>$ echo $HOME\n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>This prints the value of this variable.</p>"}, {"location": "linux-tutorial/getting_started/#defining-variables", "title": "Defining variables", "text": "<p>There are several variables already defined for you when you start your session, such as <code>$HOME</code> which contains the path to your home directory.</p> <p>For a full overview of defined environment variables in your current session, you can use the <code>env</code> command. You can sort this output with <code>sort</code> to make it easier to search in:</p> <pre><code>$ env | sort\n...\nHOME=/user/home/gent/vsc400/vsc40000\n...\n</code></pre> <p>You can also use the <code>grep</code> command to search for a piece of text. The following command will output all VSC-specific variable names and their values:</p> <pre><code>$ env | sort | grep VSC</code></pre> <p>But we can also define our own. this is done with the <code>export</code> command (note: variables are always all-caps as a convention):</p> <pre><code>$ export MYVARIABLE=\"value\"</code></pre> <p>It is important you don't include spaces around the <code>=</code> sign. Also note the lack of <code>$</code> sign in front of the variable name.</p> <p>If we then do</p> <pre><code>$ echo $MYVARIABLE</code></pre> <p>this will output <code>value</code>. Note that the quotes are not included, they were only used when defining the variable to escape potential spaces in the value.</p>"}, {"location": "linux-tutorial/getting_started/#changing-your-prompt-using-ps1", "title": "Changing your prompt using <code>$PS1</code>", "text": "<p>You can change what your prompt looks like by redefining the special-purpose variable <code>$PS1</code>.</p> <p>For example: to include the current location in your prompt:</p> <pre><code>$ export PS1='\\w $'\n~ $ cd test\n~/test $\n</code></pre> <p>Note that <code>~</code> is short representation of your home directory.</p> <p>To make this persistent across session, you can define this custom value for <code>$PS1</code> in your <code>.profile</code> startup script:</p> <pre><code>$ echo 'export PS1=\"\\w $ \" ' &gt;&gt; ~/.profile</code></pre>"}, {"location": "linux-tutorial/getting_started/#using-non-defined-variables", "title": "Using non-defined variables", "text": "<p>One common pitfall is the (accidental) use of non-defined variables. Contrary to what you may expect, this does not result in error messages, but the variable is considered to be empty instead.</p> <p>This may lead to surprising results, for example:</p> <pre><code>$ export WORKDIR=/tmp/test\n$ pwd\n/user/home/gent/vsc400/vsc40000\n$ echo $HOME\n/user/home/gent/vsc400/vsc40000\n</code></pre> <p>To understand what's going on here, see the section on <code>cd</code> below.</p> <p>The moral here is: be very careful to not use empty variables unintentionally.</p> <p>Tip for job scripts: use <code>set -e -u</code> to avoid using empty variables accidentally.</p> <p>The <code>-e</code> option will result in the script getting stopped if any command fails.</p> <p>The <code>-u</code> option will result in the script getting stopped if empty variables are used. (see https://ss64.com/bash/set.html for a more detailed explanation and more options)</p> <p>More information can be found at http://www.tldp.org/LDP/abs/html/variables.html.</p>"}, {"location": "linux-tutorial/getting_started/#restoring-your-default-environment", "title": "Restoring your default environment", "text": "<p>If you've made a mess of your environment, you shouldn't waste too much time trying to fix it. Just log out and log in again and you will be given a pristine environment.</p>"}, {"location": "linux-tutorial/getting_started/#basic-system-information", "title": "Basic system information", "text": "<p>Basic information about the system you are logged into can be obtained in a variety of ways.</p> <p>We limit ourselves to determining the hostname:</p> <pre><code>$ hostname\ngligar01.gligar.os\n\n$ echo $HOSTNAME\ngligar01.gligar.os\n</code></pre> <p>And querying some basic information about the Linux kernel:</p> <pre><code>$ uname -a\nLinux gligar01.gligar.os 2.6.32-573.8.1.el6.ug.x86_64 #1 SMP Mon Nov 16 15:12:09\n    CET 2015 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre>"}, {"location": "linux-tutorial/getting_started/#exercises", "title": "Exercises", "text": "<ul> <li> <p>Print the full path to your home directory</p> </li> <li> <p>Determine the name of the environment variable to your personal     scratch directory</p> </li> <li> <p>What's the name of the system you're logged into? Is it the same for     everyone?</p> </li> <li> <p>Figure out how to print the value of a variable without including a     newline</p> </li> <li> <p>How do you get help on using the <code>man</code> command?</p> </li> </ul>"}, {"location": "linux-tutorial/hpc_infrastructure/", "title": "More on the HPC infrastructure", "text": ""}, {"location": "linux-tutorial/hpc_infrastructure/#filesystems", "title": "Filesystems", "text": "<p>Multiple different shared filesystems are available on the HPC infrastructure, each with their own purpose. See section Where to store your data on the HPC for a list of available locations.</p>"}, {"location": "linux-tutorial/hpc_infrastructure/#vo-storage", "title": "VO storage", "text": "<p>If you are a member of a (non-default) virtual organisation (VO), see section Virtual Organisations, you have access to additional directories (with more quota) on the data and scratch filesystems, which you can share with other members in the VO.</p>"}, {"location": "linux-tutorial/hpc_infrastructure/#quota", "title": "Quota", "text": "<p>Space is limited on the cluster's storage. To check your quota, see section Pre-defined quota.</p> <p>To figure out where your quota is being spent, the <code>du</code> (isk sage) command can come in useful:</p> <pre><code>$ du -sh test\n59M test\n</code></pre> <p>Do not (frequently) run <code>du</code> on directories where large amounts of data are stored, since that will:</p> <ol> <li> <p>take a long time</p> </li> <li> <p>result in increased load on the shared storage since (the metadata     of) every file in those directories will have to be inspected.</p> </li> </ol>"}, {"location": "linux-tutorial/hpc_infrastructure/#modules", "title": "Modules", "text": "<p>Software is provided through so-called environment modules.</p> <p>The most commonly used commands are:</p> <ol> <li> <p><code>module avail</code>: show all available modules</p> </li> <li> <p><code>module avail &lt;software name&gt;</code>: show available modules for a     specific software name</p> </li> <li> <p><code>module list</code>: show list of loaded modules</p> </li> <li> <p><code>module load &lt;module name&gt;</code>: load a particular module</p> </li> </ol> <p>More information is available in section Modules.</p>"}, {"location": "linux-tutorial/hpc_infrastructure/#using-the-clusters", "title": "Using the clusters", "text": "<p>The use the clusters beyond the login node(s) which have limited resources, you should create job scripts and submit them to the clusters.</p> <p>Detailed information is available in section submitting your job.</p>"}, {"location": "linux-tutorial/hpc_infrastructure/#exercises", "title": "Exercises", "text": "<p>Create and submit a job script that computes the sum of 1-100 using Python, and prints the numbers to a unique output file in <code>$VSC_SCRATCH</code>.</p> <p>Hint: <code>python -c \"print(sum(range(1, 101)))\"</code></p> <ul> <li>How many modules are available for Python version 3.6.4?</li> <li>How many modules get loaded when you load the <code>Python/3.6.4-intel-2018a</code> module?</li> <li>Which <code>cluster</code> modules are available?</li> </ul> <ul> <li>What's the full path to your personal home/data/scratch directories?</li> <li>Determine how large your personal directories are.</li> <li>What's the difference between the size reported by <code>du -sh $HOME</code> and by <code>ls -ld $HOME</code>?</li> </ul>"}, {"location": "linux-tutorial/manipulating_files_and_directories/", "title": "Manipulating files and directories", "text": "<p>Being able to manage your data is an important part of using the HPC infrastructure. The bread and butter commands for doing this are mentioned here. It might seem annoyingly terse at first, but with practice you will realise that it's very practical to have such common commands short to type.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#file-contents-cat-head-tail-less-more", "title": "File contents: \"cat\", \"head\", \"tail\", \"less\", \"more\"", "text": "<p>To print the contents of an entire file, you can use <code>cat</code>; to only see the first or last N lines, you can use <code>head</code> or <code>tail</code>:</p> <pre><code>$ cat one.txt\n1\n2\n3\n4\n5\n\n$ head -2 one.txt\n1\n2\n\n$ tail -2 one.txt\n4\n5\n</code></pre> <p>To check the contents of long text files, you can use the <code>less</code> or <code>more</code> commands which support scrolling with \"&lt;up&gt;\", \"&lt;down&gt;\", \"&lt;space&gt;\", etc.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#copying-files-cp", "title": "Copying files: \"cp\"", "text": "<pre><code>$ cp source target\n</code></pre> <p>This is the <code>cp</code> command, which copies a file from source to target. To copy a directory, we use the <code>-r</code> option:</p> <pre><code>$ cp -r sourceDirectory target\n</code></pre> <p>A last more complicated example:</p> <pre><code>$ cp -a sourceDirectory target\n</code></pre> <p>Here we used the same <code>cp</code> command, but instead we gave it the <code>-a</code> option which tells cp to copy all the files and keep timestamps and permissions.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#creating-directories-mkdir", "title": "Creating directories: \"mkdir\"", "text": "<pre><code>$ mkdir directory\n</code></pre> <p>which will create a directory with the given name inside the current directory.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#renamingmoving-files-mv", "title": "Renaming/moving files: \"mv\"", "text": "<pre><code>$ mv source target\n</code></pre> <p><code>mv</code> will move the source path to the destination path. Works for both directories as files.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#removing-files-rm", "title": "Removing files: \"rm\"", "text": "<p>Note: there are NO backups, there is no 'trash bin'. If you remove files/directories, they are gone.</p> <pre><code>$ rm filename\n</code></pre> <p><code>rm</code> will remove a file or directory. (<code>rm -rf directory</code> will remove every file inside a given directory). WARNING: files removed will be lost forever, there are no backups, so beware when using this command!</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#removing-a-directory-rmdir", "title": "Removing a directory: \"rmdir\"", "text": "<p>You can remove directories using <code>rm -r directory</code>, however, this is error prone and can ruin your day if you make a mistake in typing. To prevent this type of error, you can remove the contents of a directory using <code>rm</code> and then finally removing the directory with:</p> <pre><code>$ rmdir directory\n</code></pre>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#changing-permissions-chmod", "title": "Changing permissions: \"chmod\"", "text": "<p>Every file, directory, and link has a set of permissions. These permissions consist of permission groups and permission types. The permission groups are:</p> <ol> <li> <p>User - a particular user (account)</p> </li> <li> <p>Group - a particular group of users (may be user-specific group with     only one member)</p> </li> <li> <p>Other - other users in the system</p> </li> </ol> <p>The permission types are:</p> <ol> <li> <p>Read - For files, this gives permission to read the contents of a     file</p> </li> <li> <p>Write - For files, this gives permission to write data to the file.     For directories it allows users to add or remove files to a     directory.</p> </li> <li> <p>Execute - For files this gives permission to execute a file as     through it were a script. For directories, it allows users to open     the directory and look at the contents.</p> </li> </ol> <p>Any time you run <code>ls -l</code> you'll see a familiar line of <code>-rwx------</code> or similar combination of the letters <code>r</code>, <code>w</code>, <code>x</code> and <code>-</code> (dashes). These are the permissions for the file or directory. (See also the  previous section on permissions)</p> <pre><code>$ ls -l\ntotal 1\n-rw-r--r--. 1 vsc40000 mygroup 4283648 Apr 12 15:13 articleTable.csv\ndrwxr-x---. 2 vsc40000 mygroup 40 Apr 12 15:00 Project_GoldenDragon\n</code></pre> <p>Here, we see that <code>articleTable.csv</code> is a file (beginning the line with <code>-</code>) has read and write permission for the user <code>vsc40000</code> (<code>rw-</code>), and read permission for the group <code>mygroup</code> as well as all other users (<code>r--</code> and <code>r--</code>).</p> <p>The next entry is <code>Project_GoldenDragon</code>. We see it is a directory because the line begins with a <code>d</code>. It also has read, write, and execute permission for the <code>vsc40000</code> user (<code>rwx</code>). So that user can look into the directory and add or remove files. Users in the <code>mygroup</code> can also look into the directory and read the files. But they can't add or remove files (<code>r-x</code>). Finally, other users can read files in the directory, but other users have no permissions to look in the directory at all (<code>---</code>).</p> <p>Maybe we have a colleague who wants to be able to add files to the directory. We use <code>chmod</code> to change the modifiers to the directory to let people in the group write to the directory:</p> <pre><code>$ chmod g+w Project_GoldenDragon\n$ ls -l\ntotal 1\n-rw-r--r--. 1 vsc40000 mygroup 4283648 Apr 12 15:13 articleTable.csv\ndrwxrwx---. 2 vsc40000 mygroup 40 Apr 12 15:00 Project_GoldenDragon\n</code></pre> <p>The syntax used here is <code>g+x</code> which means roup was given rite permission. To revoke it again, we use <code>g-w</code>. The other roles are <code>u</code> for user and <code>o</code> for other.</p> <p>You can put multiple changes on the same line: <code>chmod o-rwx,g-rxw,u+rx,u-w somefile</code> will take everyone's permission away except the user's ability to read or execute the file.</p> <p>You can also use the <code>-R</code> flag to affect all the files within a directory, but this is dangerous. It's best to refine your search using <code>find</code> and then pass the resulting list to <code>chmod</code> since it's not usual for all files in a directory structure to have the same permissions.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#access-control-lists-acls", "title": "Access control lists (ACLs)", "text": "<p>However, this means that all users in <code>mygroup</code> can add or remove files. This could be problematic if you only wanted one person to be allowed to help you administer the files in the project. We need a new group. To do this in the HPC environment, we need to use access control lists (ACLs):</p> <pre><code>$ setfacl -m u:otheruser:w Project_GoldenDragon\n$ ls -l Project_GoldenDragon\ndrwxr-x---+ 2 vsc40000 mygroup 40 Apr 12 15:00 Project_GoldenDragon\n</code></pre> <p>This will give the user <code>otheruser</code> permissions to write to <code>Project_GoldenDragon</code></p> <p>Now there is a <code>+</code> at the end of the line. This means there is an ACL attached to the directory. <code>getfacl Project_GoldenDragon</code> will print the ACLs for the directory.</p> <p>Note: most people don't use ACLs, but it's sometimes the right thing and you should be aware it exists.</p> <p>See https://linux.die.net/man/1/setfacl for more information.</p>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#zipping-gzipgunzip-zipunzip", "title": "Zipping: \"gzip\"/\"gunzip\", \"zip\"/\"unzip\"", "text": "<p>Files should usually be stored in a compressed file if they're not being used frequently. This means they will use less space and thus you get more out of your quota. Some types of files (e.g., CSV files with a lot of numbers) compress as much as 9:1. The most commonly used compression format on Linux is gzip. To compress a file using gzip, we use:</p> <pre><code>$ ls -lh myfile\n-rw-r--r--. 1 vsc40000 vsc40000 4.1M Dec 2 11:14 myfile\n$ gzip myfile\n$ ls -lh myfile.gz\n-rw-r--r--. 1 vsc40000 vsc40000 1.1M Dec 2 11:14 myfile.gz\n</code></pre> <p>Note: if you zip a file, the original file will be removed. If you unzip a file, the compressed file will be removed. To keep both, we send the data to <code>stdout</code> and redirect it to the target file:</p> <pre><code>$ gzip -c myfile &gt; myfile.gz\n$ gunzip -c myfile.gz &gt; myfile\n</code></pre>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#zip-and-unzip", "title": "\"zip\" and \"unzip\"", "text": "<p>Windows and macOS seem to favour the zip file format, so it's also important to know how to unpack those. We do this using unzip:</p> <pre><code>$ unzip myfile.zip\n</code></pre> <p>If we would like to make our own zip archive, we use zip:</p> <pre><code>$ zip myfiles.zip myfile1 myfile2 myfile3\n</code></pre>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#working-with-tarballs-tar", "title": "Working with tarballs: \"tar\"", "text": "<p>Tar stands for \"tape archive\" and is a way to bundle files together in a bigger file.</p> <p>You will normally want to unpack these files more often than you make them. To unpack a <code>.tar</code> file you use:</p> <pre><code>$ tar -xf tarfile.tar\n</code></pre> <p>Often, you will find <code>gzip</code> compressed <code>.tar</code> files on the web. These are called tarballs. You can recognize them by the filename ending in <code>.tar.gz</code>. You can uncompress these using <code>gunzip</code> and then unpacking them using <code>tar</code>. But <code>tar</code> knows how to open them using the <code>-z</code> option:</p> <pre><code>$ tar -zxf tarfile.tar.gz\n$ tar -zxf tarfile.tgz\n</code></pre>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#order-of-arguments", "title": "Order of arguments", "text": "<p>Note: Archive programs like <code>zip</code>, <code>tar</code>, and <code>jar</code> use arguments in the \"opposite direction\" of copy commands.</p> <pre><code># cp, ln: &lt;source(s)&gt; &lt;target&gt;\n$ cp source1 source2 source3 target\n$ ln -s source target\n\n# zip, tar: &lt;target&gt; &lt;source(s)&gt;\n$ zip zipfile.zip source1 source2 source3\n$ tar -cf tarfile.tar source1 source2 source3\n</code></pre> <p>If you use <code>tar</code> with the source files first then the first file will be overwritten. You can control the order of arguments of <code>tar</code> if it helps you remember:</p> <pre><code>$ tar -c source1 source2 source3 -f tarfile.tar</code></pre>"}, {"location": "linux-tutorial/manipulating_files_and_directories/#exercises", "title": "Exercises", "text": "<ol> <li> <p>Create a subdirectory in your home directory named <code>test</code> containing     a single, empty file named <code>one.txt</code>.</p> </li> <li> <p>Copy <code>/etc/hostname</code> into the <code>test</code> directory and then check what's     in it. Rename the file to <code>hostname.txt</code>.</p> </li> <li> <p>Make a new directory named <code>another</code> and copy the entire <code>test</code>     directory to it. <code>another/test/one.txt</code> should then be an empty     file.</p> </li> <li> <p>Remove the <code>another/test</code> directory with a single command.</p> </li> <li> <p>Rename <code>test</code> to <code>test2</code>. Move <code>test2/hostname.txt</code> to your home     directory.</p> </li> <li> <p>Change the permission of <code>test2</code> so only you can access it.</p> </li> <li> <p>Create an empty job script named <code>job.sh</code>, and make it executable.</p> </li> <li> <p>gzip <code>hostname.txt</code>, see how much smaller it becomes, then unzip it     again.</p> </li> </ol>"}, {"location": "linux-tutorial/navigating/", "title": "Navigating", "text": ""}, {"location": "linux-tutorial/navigating/#current-directory-pwd-and-pwd", "title": "Current directory: \"pwd\" and \"\\$PWD\"", "text": "<p>To print the current directory, use <code>pwd</code> or <code>$PWD</code>:</p> <pre><code>$ cd $HOME\n$ pwd\n/user/home/gent/vsc400/vsc40000\n$ echo \"The current directory is: $PWD\"\nThe current directory is: /user/home/gent/vsc400/vsc40000\n</code></pre>"}, {"location": "linux-tutorial/navigating/#listing-files-and-directories-ls", "title": "Listing files and directories: \"ls\"", "text": "<p>A very basic and commonly used command is <code>ls</code>, which can be used to list files and directories.</p> <p>In it's basic usage, it just prints the names of files and directories in the current directory. For example:</p> <pre><code>$ ls\nafile.txt some_directory\n</code></pre> <p>When provided an argument, it can be used to list the contents of a directory:</p> <pre><code>$ ls some_directory\none.txt two.txt\n</code></pre> <p>A couple of commonly used options include:</p> <ul> <li> <p>detailed listing using <code>ls -l</code>:     <pre><code>$ ls -l\ntotal 4224\n-rw-rw-r-- 1 vsc40000 vsc40000 2157404 Apr 12 13:17 afile.txt\ndrwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory</code></pre></p> </li> <li> <p>To print the size information in human-readable form, use the <code>-h</code>     flag:     <pre><code>$ ls -lh\ntotal 4.1M\n-rw-rw-r-- 1 vsc40000 vsc40000 2.1M Apr 12 13:16 afile.txt\ndrwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory</code></pre></p> </li> <li> <p>also listing hidden files using the <code>-a</code> flag:</p> <p><pre><code>$ ls -lah\ntotal 3.9M\ndrwxrwxr-x 3 vsc40000 vsc40000 512 Apr 12 13:11 .\ndrwx------ 188 vsc40000 vsc40000 128K Apr 12 12:41 ..\n-rw-rw-r-- 1 vsc40000 vsc40000 1.8M Apr 12 13:12 afile.txt\n-rw-rw-r-- 1 vsc40000 vsc40000 0 Apr 12 13:11 .hidden_file.txt\ndrwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory</code></pre></p> </li> <li> <p>ordering files by the most recent change using <code>-rt</code>:</p> <p><pre><code>$ ls -lrth\ntotal 4.0M\ndrwxrwxr-x 2 vsc40000 vsc40000 512 Apr 12 12:51 some_directory\n-rw-rw-r-- 1 vsc40000 vsc40000 2.0M Apr 12 13:15 afile.txt</code></pre></p> </li> </ul> <p>If you try to use <code>ls</code> on a file that doesn't exist, you will get a clear error message:</p> <pre><code>$ ls nosuchfile\nls: cannot access nosuchfile: No such file or directory\n</code></pre>"}, {"location": "linux-tutorial/navigating/#changing-directory-cd", "title": "Changing directory: \"cd\"", "text": "<p>To change to a different directory, you can use the <code>cd</code> command:</p> <pre><code>$ cd some_directory</code></pre> <p>To change back to the previous directory you were in, there's a shortcut: <code>cd -</code></p> <p>Using <code>cd</code> without an argument results in returning back to your home directory:</p> <pre><code>$ cd\n$ pwd\n/user/home/gent/vsc400/vsc40000\n</code></pre>"}, {"location": "linux-tutorial/navigating/#inspecting-file-type-file", "title": "Inspecting file type: \"file\"", "text": "<p>The <code>file</code> command can be used to inspect what type of file you're dealing with:</p> <pre><code>$ file afile.txt\nafile.txt: ASCII text\n\n$ file some_directory\nsome_directory: directory\n</code></pre>"}, {"location": "linux-tutorial/navigating/#absolute-vs-relative-file-paths", "title": "Absolute vs relative file paths", "text": "<p>An absolute filepath starts with <code>/</code> (or a variable which value starts with <code>/</code>), which is also called the root of the filesystem.</p> <p>Example: absolute path to your home directory: <code>/user/home/gent/vsc400/vsc40000</code>.</p> <p>A relative path starts from the current directory, and points to another location up or down the filesystem hierarchy.</p> <p>Example: <code>some_directory/one.txt</code> points to the file <code>one.txt</code> that is located in the subdirectory named <code>some_directory</code> of the current directory.</p> <p>There are two special relative paths worth mentioning:</p> <ul> <li> <p><code>.</code> is a shorthand for the current directory</p> </li> <li> <p><code>..</code> is a shorthand for the parent of the current directory</p> </li> </ul> <p>You can also use <code>..</code> when constructing relative paths, for example:</p> <pre><code>$ cd $HOME/some_directory\n$ ls ../afile.txt\n../afile.txt\n</code></pre>"}, {"location": "linux-tutorial/navigating/#permissions", "title": "Permissions", "text": "<p>Each file and directory has particular permissions set on it, which can be queried using <code>ls -l</code>.</p> <p>For example:</p> <pre><code>$ ls -l afile.txt\n-rw-rw-r-- 1 vsc40000 agroup 2929176 Apr 12 13:29 afile.txt\n</code></pre> <p>The <code>-rwxrw-r--</code> specifies both the type of file (<code>-</code> for files, <code>d</code> for directories (see first character)), and the permissions for user/group/others:</p> <ol> <li> <p>each triple of characters indicates whether the read (<code>r</code>), write     (<code>w</code>), execute (<code>x</code>) permission bits are set or not</p> </li> <li> <p>the 1st part <code>rwx</code> indicates that the owner \"vsc40000\" of the file has all     the rights</p> </li> <li> <p>the 2nd part <code>rw-</code> indicates the members of the group \"agroup\"     only have read/write permissions (not execute)</p> </li> <li> <p>the 3rd part <code>r--</code> indicates that other users only have read     permissions</p> </li> </ol> <p>The default permission settings for new files/directories are determined by the so-called umask setting, and are by default:</p> <ol> <li> <p>read-write permission on files for user/group (no execute),     read-only for others (no write/execute)</p> </li> <li> <p>read-write-execute permission for directories on user/group,     read/execute-only for others (no write)</p> </li> </ol> <p>See also the chmod command  later in this manual.</p>"}, {"location": "linux-tutorial/navigating/#finding-filesdirectories-find", "title": "Finding files/directories: \"find\"", "text": "<p><code>find</code> will crawl a series of directories and lists files matching given criteria.</p> <p>For example, to look for the file named <code>one.txt</code>:</p> <pre><code>$ cd $HOME\n$ find . -name one.txt\n./some_directory/one.txt\n</code></pre> <p>To look for files using incomplete names, you can use a wildcard <code>*</code>; note that you need to escape the <code>*</code> to avoid that Bash expands it into <code>afile.txt</code> by adding double quotes:</p> <pre><code>$ find . -name \"*.txt\"\n./.hidden_file.txt\n./afile.txt\n./some_directory/one.txt\n./some_directory/two.txt\n</code></pre> <p>A more advanced use of the <code>find</code> command is to use the <code>-exec</code> flag to perform actions on the found file(s), rather than just printing their paths (see <code>man find</code>).</p>"}, {"location": "linux-tutorial/navigating/#exercises", "title": "Exercises", "text": "<ul> <li> <p>Go to <code>/tmp</code>, then back to your home directory. How many different     ways to do this can you come up with?</p> </li> <li> <p>When was your home directory created or last changed?</p> </li> <li> <p>Determine the name of the last changed file in <code>/tmp</code>.</p> </li> <li> <p>See how home directories are organised. Can you access the home     directory of other users?</p> </li> </ul>"}, {"location": "linux-tutorial/uploading_files/", "title": "Uploading/downloading/editing files", "text": ""}, {"location": "linux-tutorial/uploading_files/#uploadingdownloading-files", "title": "Uploading/downloading files", "text": "<p>To transfer files from and to the HPC, see  the section about transferring files of the HPC manual</p>"}, {"location": "linux-tutorial/uploading_files/#dos2unix", "title": "<code>dos2unix</code>", "text": "<p>After uploading files from Windows, you may experience some problems due to the difference in line endings between Windows (carriage return + line feed) and Linux (line feed only), see also https://kuantingchen04.github.io/line-endings/.</p> <p>For example, you may see an error when submitting a job script that was edited on Windows:</p> <pre><code>sbatch: error: Batch script contains DOS line breaks (\\r\\n)\nsbatch: error: instead of expected UNIX line breaks (\\n).\n</code></pre> <p>To fix this problem, you should run the <code>dos2unix</code> command on the file:</p> <pre><code>$ dos2unix filename\n</code></pre>"}, {"location": "linux-tutorial/uploading_files/#symlinks-for-datascratch", "title": "Symlinks for data/scratch", "text": "<p>As we end up in the home directory when connecting, it would be convenient if we could access our data and VO storage. To facilitate this we will create symlinks to them in our home directory.  This will create 4 symbolic links  (they're like \"shortcuts\" on your desktop)  pointing to the respective storages:</p> <pre><code>$ cd $HOME\n$ ln -s $VSC_SCRATCH scratch\n$ ln -s $VSC_DATA data\n$ ls -l scratch data\nlrwxrwxrwx 1 vsc40000 vsc40000 31 Mar 27 2009 data -&gt;\n    /user/data/gent/vsc400/vsc40000\nlrwxrwxrwx 1 vsc40000 vsc40000 34 Jun 5 2012 scratch -&gt;\n    /user/scratch/gent/vsc400/vsc40000\n</code></pre>"}, {"location": "linux-tutorial/uploading_files/#editing-with-nano", "title": "Editing with <code>nano</code>", "text": "<p>Nano is the simplest editor available on Linux. To open Nano, just type <code>nano</code>. To edit a file, you use <code>nano the_file_to_edit.txt</code>. You will be presented with the contents of the file and a menu at the bottom with commands like <code>^O Write Out</code> The <code>^</code> is the Control key. So <code>^O</code> means <code>Ctrl-O</code>. The main commands are:</p> <ol> <li> <p>Open (\"Read\"): <code>^R</code></p> </li> <li> <p>Save (\"Write Out\"): <code>^O</code></p> </li> <li> <p>Exit: <code>^X</code></p> </li> </ol> <p>More advanced editors (beyond the scope of this page) are <code>vim</code> and <code>emacs</code>. A simple tutorial on how to get started with <code>vim</code> can be found at https://www.openvim.com/.</p>"}, {"location": "linux-tutorial/uploading_files/#copying-faster-with-rsync", "title": "Copying faster with <code>rsync</code>", "text": "<p><code>rsync</code> is a fast and versatile copying tool. It can be much faster than <code>scp</code> when copying large datasets. It's famous for its \"delta-transfer algorithm\", which reduces the amount of data sent over the network by only sending the differences between files.</p> <p>You will need to run <code>rsync</code> from a computer where it is installed. Installing <code>rsync</code> is the easiest on Linux: it comes pre-installed with a lot of distributions.</p> <p>For example, to copy a folder with lots of CSV files:</p> <pre><code>$ rsync -rzv testfolder vsc40000@login.hpc.ugent.be:data/</code></pre> <p>will copy the folder <code>testfolder</code> and its contents to <code>$VSC_DATA</code> on the , assuming the <code>data</code> symlink is present in your home directory, see  symlinks section.</p> <p>The <code>-r</code> flag means \"recursively\", the <code>-z</code> flag means that compression is enabled (this is especially handy when dealing with CSV files because they compress well) and the <code>-v</code> enables more verbosity (more details about what's going on).</p> <p>To copy large files using <code>rsync</code>, you can use the <code>-P</code> flag: it enables both showing of progress and resuming partially downloaded files.</p> <p>To copy files from the to your local computer, you can also use <code>rsync</code>:</p> <pre><code>$ rsync -rzv vsc40000@login.hpc.ugent.be:data/bioset local_folder</code></pre> <p>This will copy the folder <code>bioset</code> and its contents that on <code>$VSC_DATA</code> of the to a local folder named <code>local_folder</code>.</p> <p>See <code>man rsync</code> or https://linux.die.net/man/1/rsync for more information about rsync.</p>"}, {"location": "linux-tutorial/uploading_files/#exercises", "title": "Exercises", "text": "<ol> <li> <p>Download the file <code>/etc/hostname</code> to your local computer.</p> </li> <li> <p>Upload a file to a subdirectory of your personal <code>$VSC_DATA</code> space.</p> </li> <li> <p>Create a file named <code>hello.txt</code> and edit it using <code>nano</code>.</p> </li> </ol>"}, {"location": "sites/available_modules/", "title": "Available modules", "text": "<pre><code>$ module av 2&gt;&amp;1 | more\n--- /apps/gent/SL6/sandybridge/modules/all ---\nABAQUS/6.12.1-linux-x86_64\nAMOS/3.1.0-ictce-4.0.10\nant/1.9.0-Java-1.7.0_40\nASE/3.6.0.2515-ictce-4.1.13-Python-2.7.3\nASE/3.6.0.2515-ictce-5.5.0-Python-2.7.6\n...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., MATLAB) is installed on the HPC.</p> <pre><code>$ module av 2&gt;&amp;1 | grep -i -e \"matlab\"\nMATLAB/2010b\nMATLAB/2012b\nMATLAB/2013b\n</code></pre> <p>As you are not aware of the capitals letters in the module name, we looked for a case-insensitive name with the \"-i\" option.</p>"}, {"location": "sites/hpc_policies/", "title": "HPC Policies", "text": "<p>Everyone can get access and use the HPC-UGent supercomputing infrastructure and services. The conditions that apply depend on your affiliation.</p>"}, {"location": "sites/hpc_policies/#access-for-staff-and-academics", "title": "Access for staff and academics", "text": ""}, {"location": "sites/hpc_policies/#researchers-and-staff-affiliated-with-flemish-university-associations", "title": "Researchers and staff affiliated with Flemish university associations", "text": "<ul> <li> <p>Includes externally funded researchers registered in the     personnel database (FWO, SBO, VIB, IMEC, etc.).</p> </li> <li> <p>Includes researchers from all VSC partners.</p> </li> <li> <p>Usage is free of charge.</p> </li> <li> <p>Use your account credentials at your affiliated university     to request a VSC-id and connect.</p> </li> <li> <p>See Getting a HPC Account.</p> </li> </ul>"}, {"location": "sites/hpc_policies/#researchers-and-staff-affiliated-with-other-flemish-or-federal-research-institutes", "title": "Researchers and staff affiliated with other Flemish or federal research institutes", "text": "<ul> <li> <p>Includes researchers from e.g. INBO, ILVO, RBINS, etc.</p> </li> <li> <p>Usage subject to an agreement with Ghent University.</p> </li> <li> <p>Every institute gets 1,500\u20ac worth of compute time free of charge per year.</p> </li> <li> <p>Use your welkom account credentials to request a VSC-id and connect.</p> </li> </ul>"}, {"location": "sites/hpc_policies/#students", "title": "Students", "text": "<ul> <li> <p>Students can also use HPC-UGent (Bachelor or Master,     enrolled in an institute mentioned above).</p> </li> <li> <p>Same conditions apply, free of charge for all Flemish university associations.</p> </li> <li> <p>Use your university account credentials to request a VSC-id and connect.</p> </li> </ul>"}, {"location": "sites/hpc_policies/#access-for-industry", "title": "Access for industry", "text": "<p>Researchers and developers from industry are very welcome to use HPC-UGent services and infrastructure.</p>"}, {"location": "sites/hpc_policies/#our-offer", "title": "Our offer", "text": "<ul> <li> <p>Access to state-of-the-art supercomputing infrastructure.</p> </li> <li> <p>Dedicated helpdesk and user support.</p> </li> <li> <p>On-demand software installation.</p> </li> <li> <p>Regular training sessions.</p> </li> <li> <p>Buy compute time and storage in pay-what-you-use model.</p> </li> <li> <p>Advice on using other compute clusters in the VSC network.</p> </li> </ul>"}, {"location": "sites/hpc_policies/#access-models", "title": "Access models", "text": "<ul> <li> <p>Exploratory access:</p> <ul> <li>Explore our infrastructure and services for a 1-month period.</li> <li>No contract needed.</li> <li>Free of charge.</li> <li>Request your free trial by mail to hpc@ugent.be.</li> </ul> </li> <li> <p>Access via agreement:</p> <ul> <li>Subject to an agreement between your company and Ghent University.</li> <li>Check out a draft contract at Access for industry.</li> <li>Pay-what-you-use system: you only pay for the compute time and storage that you actually use.</li> <li>All prices are listed in the draft contract.</li> <li>Request a quote by mail to hpc@ugent.be.</li> </ul> </li> <li> <p>Getting access:</p> <ul> <li>Use your welkom account credentials to request a VSC-id and connect.</li> <li>See also Access for external parties</li> <li>For further details, contact hpc@ugent.be.</li> </ul> </li> <li> <p>Research partnership:</p> <ul> <li>Interested in collaborating in supercomputing with a UGent research group?</li> <li>We can help you look for a collaborative partner. Contact hpc@ugent.be.</li> </ul> </li> </ul>"}, {"location": "sites/antwerpen/available-modules/", "title": "Available modules", "text": "<pre><code>$ module av 2&gt;&amp;1 | more\n------------- /apps/antwerpen/modules/hopper/2015a/all ------------\nABINIT/7.10.2-intel-2015a\nADF/2014.05\nAdvisor/2015_update1\nBison/3.0.4-intel-2015a\nBoost/1.57.0-foss-2015a-Python-2.7.9\nBoost/1.57.0-intel-2015a-Python-2.7.9\nbzip2/1.0.6-foss-2015a\nbzip2/1.0.6-intel-2015a\n...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., LAMMPS) is installed on the HPC.</p> <pre><code>$ module av 2&gt;&amp;1 | grep -i -e \"LAMMPS\"\nLAMMPS/9Dec14-intel-2015a\nLAMMPS/30Oct14-intel-2014a\nLAMMPS/5Sep14-intel-2014a\n</code></pre> <p>As you are not aware of the capitals letters in the module name, we looked for a case-insensitive name with the \"-i\" option.</p>"}, {"location": "sites/gent/available-modules/", "title": "Available modules", "text": "<pre><code>$ module av 2&gt;&amp;1 | more\n--- /apps/gent/SL6/sandybridge/modules/all ---\nABAQUS/6.12.1-linux-x86_64\nAMOS/3.1.0-ictce-4.0.10\nant/1.9.0-Java-1.7.0_40\nASE/3.6.0.2515-ictce-4.1.13-Python-2.7.3\nASE/3.6.0.2515-ictce-5.5.0-Python-2.7.6\n...\n</code></pre> <p>Or when you want to check whether some specific software, some compiler or some application (e.g., MATLAB) is installed on the HPC.</p> <pre><code>$ module av 2&gt;&amp;1 | grep -i -e \"matlab\"\nMATLAB/2010b\nMATLAB/2012b\nMATLAB/2013b\n</code></pre> <p>As you are not aware of the capitals letters in the module name, we looked for a case-insensitive name with the \"-i\" option.</p>"}]}