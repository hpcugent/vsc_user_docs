{"config": {"lang": ["en"], "separator": "[\\_\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Introduction", "text": "<p>The VSC cloud platform uses the open-source software OpenStack, version \"Train\". This guide explains the specifics of the VSC environment, and provides a hands-on introduction to OpenStack. For reference, you should consult the OpenStack project's own documentation at https://docs.openstack.org.</p> <p>For all questions concerning the VSC cloud computing platform, please contact cloud@vscentrum.be. We welcome your feedback, comments and suggestions for improving the OpenStack VSC Tutorial.</p>"}, {"location": "access/", "title": "Access to the VSC Cloud", "text": "<p>Access to the VSC Cloud is linked to the central VSC account system (account.vscentrum.be), so you do not need a separate login or password. In order to use the cloud services,</p> <ul> <li> <p>you need an active VSC account and</p> </li> <li> <p>your account must be a member of one or more OpenStack projects.</p> </li> </ul> <p>New users can obtain an account by following the procedure described here. Once you have an account, contact if you want to start a new OpenStack project, or join an existing one.</p> <p>You can interact with the VSC Cloud using the OpenStack Dashboard, a web interface, or the OpenStack command line interface, which you can use from any system, and which is installed for you on the UGent login node login.hpc.ugent.be. You can log in to the Dashboard using the VSC accountpage, as illustrated in the next section. To get access from the command line interface, you'll need to obtain an application credential, as explained in section application credentials.</p> <p>These restrictions do not apply to someone who simply wishes to access an existing VM running in the cloud. VSC Cloud projects can decide themselves who gets access to their VM's, and how.</p>"}, {"location": "access/#dashboard-login", "title": "Dashboard Login", "text": "<p>You can access the OpenStack web interface, or Dashboard, via cloud.vscentrum.be.</p> <p>To log in, choose the (default) authentication method VSC Accountpage and click .</p> <p></p> <p>From here on, follow the standard procedure to log in to your VSC account, using your home institution's single sign-on system. You can find a detailed description in the HPC introduction at hpcugent.github.io/vsc_user_docs. The following chapters explain how to accomplish basic tasks using the Dashboard.</p>"}, {"location": "access/#application-credentials", "title": "Application Credentials", "text": "<p>If you want to use the OpenStack command line interface --- or, for advanced users, use the OpenStack APIs directly --- you need to identify yourself using an application credential. An application credential contains a secret piece of information which grants access to an OpenStack project on your behalf.</p> <p>You can create an application credential using the dashboard:</p> <ol> <li> <p>Log in to the dashboard, and, if you are a member of more than one     project, select the project for which you want to create an     application credential.</p> </li> <li> <p>Open the Identity tab, and click Application Credentials.</p> </li> <li> <p>You can now see an overview of your application credentials     (initially none). Click Create Application Credential.</p> </li> <li> <p>Fill out the Create Application Credential dialog:</p> <ol> <li> Name, Description Choose a name (mandatory) and description that remind you of the purpose of this credential. </li> <li> Secret We recommend to leave this empty, in which case OpenStack will generate a random secret for you. </li> <li> Expiration Date, Expiration Time It is good practice make the token expire. An expiration date limits the impact if the secret is accidentally exposed, and you can always create a new credential when an old one is expired. </li> <li> Roles A role defines a set of access rights. By selecting a subset of roles for this credential, you can limit the access rights granted by this credential. It is a good idea to select only the minimal set of roles required for the task you want to accomplish. </li> </ol> <p>Click Create Application Credential.</p> </li> <li> <p>A summary dialog with the credential's id, name, and secret is     displayed. If you close the window, you can't retrieve the secret     anymore, so you should save it now. A convenient solution is to     download the openrc file, a shell script that sets the appropriate     environment variables for the command line interface.</p> </li> </ol> <p>The newly created credential is now shown in the overview. If you accidentally expose a credential somewhere, you should delete it here to prevent unauthorized access to the system.</p>"}, {"location": "appendix/", "title": "Appendix", "text": ""}, {"location": "appendix/#vsc-tier-1-cloud-flavors-list", "title": "VSC Tier-1 Cloud flavors list", "text": "<pre><code>$ openstack flavor list\n+----+-----------------+--------+------+-----------+-------+-----------+\n| ID | Name            |    RAM | Disk | Ephemeral | VCPUs | Is Public |\n+----+-----------------+--------+------+-----------+-------+-----------+\n| 0  | CPUv1.nano      |     64 |    1 |         0 |     1 | True      |\n| 1  | CPUv1.tiny      |    512 |   10 |         0 |     1 | True      |\n| 10 | UPSv1.medium    |   4096 |   30 |         0 |     2 | True      |\n| 11 | UPSv1.large     |   8192 |   40 |         0 |     4 | True      |\n| 12 | UPSv1.2xlarge   |  61440 |   40 |         0 |    16 | True      |\n| 13 | GPUv2.small     |   2048 |   20 |         0 |     1 | True      |\n| 14 | GPUv2.medium    |   4096 |   30 |         0 |     2 | True      |\n| 15 | GPUv2.large     |   8192 |   40 |         0 |     4 | True      |\n| 16 | GPUv2.2xlarge   |  61440 |   40 |         0 |    16 | True      |\n| 17 | UPSv1.3xlarge   | 122880 |   80 |         0 |    16 | True      |\n| 18 | CPUv1.1_3xlarge | 184320 |   80 |         0 |    14 | True      |\n| 19 | CPUv1.4xlarge   | 368640 |   80 |         0 |    20 | True      |\n| 2  | CPUv1.small     |   2048 |   20 |         0 |     1 | True      |\n| 20 | GPUv3.small     |   2048 |   20 |         0 |     1 | True      |\n| 21 | GPUv3.medium    |   4096 |   30 |         0 |     2 | True      |\n| 22 | GPUv3.large     |   8192 |   40 |         0 |     4 | True      |\n| 23 | GPUv3.2xlarge   |  61440 |   40 |         0 |    16 | True      |\n| 3  | CPUv1.medium    |   4096 |   30 |         0 |     2 | True      |\n| 4  | CPUv1.large     |   8192 |   40 |         0 |     4 | True      |\n| 5  | CPUv1.xlarge    |  16384 |   40 |         0 |     8 | True      |\n| 6  | CPUv1.2xlarge   |  61440 |   40 |         0 |    16 | True      |\n| 7  | CPUv1.3xlarge   | 122880 |   80 |         0 |    16 | True      |\n| 8  | CPUv1.1_2xlarge |  61440 |   40 |         0 |     8 | True      |\n| 9  | UPSv1.small     |   2048 |   20 |         0 |     1 | True      |\n+----+-----------------+--------+------+-----------+-------+-----------+\n</code></pre>"}, {"location": "configure_instances/", "title": "Configure access and security for instance", "text": "<p>The security and accessibility of your cloud resources is governed by a few different aspects, which we discuss more detail in the following sections:</p> <ul> <li> <p>Instances must connect to the project's _vm network in order to get     external internet access (see section     _vm, _vsc and _nfs networks).</p> </li> <li> <p>Each cloud project can use one floating IP, a public IP address     which you'll need to link to the resources you want to access.     Optionally, if the project has requested access to VSC network it     will receive also three VSC floating IPs (see section     floating IP addresses).</p> </li> <li> <p>By default, the UGent firewall blocks most IP addresses and ports.     Only the port (TCP) range 50000-60000 for the public floating IP addresses     is open by default. Contact cloud@vscentrum.be if you need to access other ports from     the outside world.</p> </li> <li> <p>The OpenStack environment has its own internal firewalls, which     block most ports of your instances by default. If you want to access     specific ports of your instances, you must create \"Security Groups\"     which allow access to those ports (see section     security groups).</p> </li> <li> <p>You can use one or more SSH keys from your VSC account to access     your instances (see section     SSH key pairs).</p> </li> </ul> <p>For other access methods, or SSH authentication for a wider set of users, you'll need to set up some form of identity management yourself. This system administration task is beyond the scope of our tutorial.</p>"}, {"location": "configure_instances/#the-_vm-_vsc-and-_nfs-networks", "title": "The _vm, _vsc and _nfs networks", "text": "<p>Each project in the VSC cloud has its own network <code>&lt;projectname&gt;</code><code>_vm</code> and --- if the project uses shares and/or vsc networks --- <code>&lt;projectname&gt;</code><code>_nfs</code> and <code>&lt;projectname&gt;</code><code>_vsc</code> respectively. Each is a subnet of 254 addresses, with an ip range 10.10.x.0/24, where x is a number that depends on the project and network. To see the subnets for your project's networks, open the Network tab, and select Networks.</p> <p>Instances should use the _vm network for communication, and the _nfs network if they need access to shared file systems (see chapter shared file systems). On the other hand _vsc network is used to connect to or provide VSC services via VSC network and floating or dedicated project's VSC IPs. When an instance is created in OpenStack and connected to the _vm, _nfs or _vsc networks, it is automatically assigned a fixed local IP address in that network. This IP address is permanently associated with the instance until the instance is terminated.</p>"}, {"location": "configure_instances/#floating-ip-addresses", "title": "Floating IP addresses", "text": "<p>The _vm, _nfs and _vsc networks can only be reached from within the OpenStack environment. If you need to access an instance from the outside, you need to use one of your project's floating IP addresses, which are public IP addresses (193.190.80.0/25 IPs for _vm network) or VSC IP addresses (172.24.48.0/20 IPs for _vsc network). Unlike fixed IP addresses, floating IP addresses can have their associations modified at any time, regardless of the state of the instances involved.</p> <p>Do not release the floating IPs assigned to your project. The floating IPs are fixed to the project and it is not possible, as regular user, to re-allocate floating IPs. Please contact to VSC Tier1 Cloud support if you have released your project's floating IPs by mistake.</p> <p>This section explains how to make your instance accessible via a public IP address by two different methods. The preferred method for _vm network is to use port forwarding to access multiple instances using the same public IP address, but you can also use a \"floating IP association\" for quick tests or _vsc network.</p>"}, {"location": "configure_instances/#floating-ip-port-forwarding", "title": "Floating ip port forwarding", "text": "<p>OpenStack's networking API, called Neutron, makes it possible to forward different ports of the same floating ip to arbitrary ports in one of OpenStack's virtual networks. This is the recommended way to use floating ip's in the VSC cloud. For the floating IP's available in the VSC Cloud, the high port range 50000-60000 is open to the outside world, so it is most convenient to work with ports from this range. Contact if you need public access to another port for a specific ip address.</p> <p>You'll need to forward a separate port for every service you wish to reach. For example, if you want to access an instance using SSH, you'll need to create a port forwarding rule from a selected port of the floating IP, to the port in the _vm network where your instance's SSH server is listening (typically port 22).</p> <p>You can quickly set up such forwarding rules using <code>neutron_port_forward</code>, a command line tool available on the UGent login node, login.hpc.ugent.be. In order to use it, you must create an application credential for the role \"User\", and save it as an openrc file (see section application credentials on page ). Transfer the openrc file to your VSC storage space, so neutron_port_forward can read it. To set up new port forwarding rules, run the script providing the path to the openrc file as an argument to the -o option, and a file describing your port forwarding configuration as argument to the -m option:</p> <pre><code>neutron_port_forward -o &lt;openrc file&gt; -m &lt;ini-file&gt;\n</code></pre> <p>The following is an example configuration file:</p> <pre><code>[DEFAULT]\nfloatingip=193.190.85.40\nnetwork=_vm\n\n[classa]\npattern=classa-(+\u0323)\n22=52000:100:22\n5900=55900\n\n[classb]\npattern=classb-(+\u0323)\n80=52080\n</code></pre> <p>Here we define defaults for the floating ip and target network, and two classes. Instances are assigned to a class if their name matches the regular expression given in <code>pattern</code>. The value of <code>pattern</code> must be a valid Python regular expression, and the first capturing group (if any) must match an integer.</p> <p>Port forwarding rules are given in the form <code>target=source(:multiplier:offset)</code>. This will set up a forwarding rule from the floating IP port:</p> <p>(source + multiplier \u2217 i + offset) \u2192 target ,</p> <p>where i is the integer matched by the first capturing group, and \"target\" is a port of the fixed IP for the instance in the chosen network, in this case the _vm network. \"multiplier\" and \"offset\" are optional and default to 1 and 0 respectively. In our example, this results in the following set of port forwarding rules for the public IP address 193.190.85.40:</p> <pre><code>  52122   -&gt;\u00a0\u00a0 classa-1:22\n  52222   -&gt;\u00a0\u00a0 classa-2:22\n  ...     \n  55901   -&gt;\u00a0\u00a0 classa-1:5900\n  55902   -&gt;\u00a0\u00a0 classa-2:5900\n  ...     \n  52081   -&gt;\u00a0\u00a0 classb-1:80\n  52082   -&gt;\u00a0\u00a0 classb-2:80\n  ...     \n</code></pre> <p>This is another basic port forwarding configuration example without patterns, in this case just to connect via SSH using external port 52000 to a running VM called testvm:</p> <pre><code>[DEFAULT]\nfloatingip=193.190.85.40\nnetwork=_vm\n\n[testvm]\n22=52000\n</code></pre> <p>You can also see an overview of existing port forwarding rules for the ip addresses in your configuration file using neutron_port_forward --show. Each rule has an internal id, which you can see if you combine the options --show and --id as follows:</p> <pre><code>neutron_port_forward -o &lt;openrc file&gt; -m &lt;ini-file&gt; --show --id\n</code></pre> <p>To remove port forwarding rules, use the option <code>--remove=&lt;list of id's&gt;</code> with a comma-separated list of the id's of the rules you want to remove.</p> <p>Please note that when you remove and reinstantiate a VM, OpenStack also removes the port forwarding rules assigned to this VM automatically. If you intantiate again the same VM you should run <code>neutron_port_forward</code> and restore the port forwarding rules.</p> <p><code>neutron_port_forward</code> provides a few more options and advanced features, run the command with the <code>--help</code> option for more information.</p>"}, {"location": "configure_instances/#associate-a-floating-ip", "title": "Associate a floating ip", "text": "<p>A floating IP address can also be associated to an instance, just like the fixed IP addresses. Because this approach uses one of the few available floating ip addresses for every instance you want to connect to, you should only use it for testing purposes with _vm network or with _vsc network.</p> <p>If you want to use a floating ip for port forwarding as in the previous section, it cannot be associated to an instance at the same time.</p> <p>Use the following procedure to associate that address with a specific instance.</p> <ol> <li> <p>Open the Network tab.</p> </li> <li> <p>Click the Floating IPs tab, which shows the floating IP addresses     allocated to your project.</p> </li> <li> <p>In the Floating IPs list, click Associate next to the address you     want.</p> </li> <li> <p>In the Manage Floating IP Associations dialog box, choose the     following options:</p> <ul> <li> <p>IP Address This field is filled automatically.</p> </li> <li> <p>Port to be associated Select a port from the list. The list shows all the instances with their fixed IP addresses.</p> </li> </ul> </li> <li> <p>Click Associate.</p> </li> </ol> <p>Another way to associate a floating IP is after the user has already launched an instance which appears in the list of running instances in the Project-&gt;Compute-&gt;Instances tab:</p> <ol> <li> <p>Expand the drop-down menu on right next to the instance</p> </li> <li> <p>Select Associate Floating IP</p> <p></p> </li> <li> <p>A pop-up window will appear and under IP Address select from the     drop-down menu an IP address from the available pool.</p> <p></p> </li> <li> <p>Click Associate</p> </li> </ol> <p>If the IP has been successfully associated in the upper right corner of the browser screen will appear a green confirmation. If not successful a red notification will pop up that something went wrong.</p> <p>To disassociate an IP address from an instance, click the Disassociate button in the Actions column.</p> <p>Do not use the Release Floating IP option in the Actions column or on the overview page. This will remove the floating IP from the pool assigned to your project, something which you, as a regular user, cannot undo. If you've accidentally released a floating IP, contact to have it restored.</p>"}, {"location": "configure_instances/#security-groups", "title": "Security Groups", "text": "<p>OpenStack security groups are sets of IP filter rules that define networking access. You can then assign one or more security groups to your instances.</p> <p>In the VSC cloud, each project contains a default security group, which allows you to ping instances and connect using SSH on the default port 22. If you want to access other ports on your instances, create new security groups with the appropriate rules and assign them to the instances.</p>"}, {"location": "configure_instances/#ssh-key-pairs", "title": "SSH key pairs", "text": "<p>When an instance is launched, OpenStack can automatically install a public SSH key on it, so as to give anyone with the corresponding private key admin access. For this \"key pair injection1\" to work, the image that the instance is based on must contain the cloud-init package, or have in place another mechanism in place that will interact with the OpenStack metadata server to install the appropriate key. For general instructions on SSH keys, we refer to section Getting an HPC Account of our introduction to HPC.</p> <p>If you have generated a key pair with an external tool, you can import it into OpenStack. The key pair can be used for multiple instances that belong to a project. For more information, see section [import a key pair]](#import-a-key-pair).</p> <p>The public keys from your VSC account are automatically available in your VSC Cloud projects, so you can immediately inject one of your existing into your instances. Of course, you can also import new keys into OpenStack, which are not coupled to your VSC account. If you want to give other parties SSH access to VM's, you must manage the keys using some other method. upload SSH keys for other users to your VSC account.</p> <p>Every OpenStack user account has its own collection of SSH keys for every project. To share a public key between multiple users of the same project, each user needs to import it in the OpenStack project.</p>"}, {"location": "configure_instances/#add-a-key-pair", "title": "Add a key pair", "text": "<ol> <li> <p>Open the Compute tab.</p> </li> <li> <p>Click the Key Pairs tab, which shows the key pairs that are     available for this project.</p> </li> <li> <p>Click Create Key Pair.</p> </li> <li> <p>In the Create Key Pair dialog box, enter a name for your key pair,     and click Create Key Pair.</p> </li> <li> <p>Respond to the prompt to download the key pair.</p> </li> <li> <p>Save the *.pem file locally.</p> </li> <li> <p>To change its permissions so that only you can read and write to the     file, run the following command: <pre><code>chmod 0600 yourPrivateKey.pem\n</code></pre></p> </li> </ol> <p>Note</p> <p>If you are using the OpenStack Dashboard from a Windows computer, use PuTTYgen to load the *.pem file and convert and save it as *.ppk. For more information see the WinSCP web page for PuTTYgen, and chapter 2 of the introduction to HPC at VSC.</p> <ul> <li>To make the key pair known to SSH, run the ssh-add command.</li> </ul> <pre><code>ssh-add yourPrivateKey.pem\n</code></pre>"}, {"location": "configure_instances/#import-a-key-pair", "title": "Import a key pair", "text": "<ol> <li> <p>Open the Compute tab.</p> </li> <li> <p>Click the Key Pairs tab, which shows the key pairs that are     available for this project.</p> </li> <li> <p>Click Import Key Pair.</p> </li> <li> <p>In the Import Key Pair dialog box, enter the name of your key pair,     copy the public key into the Public Key box, and then click Import     Key Pair.</p> </li> </ol> <p>The Compute database registers the public key of the key pair.</p> <p>The OpenStack Dashboard lists the key pair on the Key Pairs tab.</p> <ol> <li> <p>The OpenStack documentation and interfaces consistently refer to \"SSH pairs\", but of course only the public key of each pair is stored in the OpenStack environment, while the private key should be kept secure by the owner.\u00a0\u21a9</p> </li> </ol>"}, {"location": "dashboard/", "title": "The OpenStack Dashboard", "text": "<p>After login, you can see the Overview tab of Horizon, the OpenStack Dashboard.</p> <p></p> <p>This chapter briefly describes the different components of the dashboard. You can read the official documentation at https://docs.openstack.org/horizon/latest/user/.</p> <p>The VSC cloud uses a customized dashboard. Some features mentioned in the official OpenStack documentation were intentionally removed, please contact if you need access to one of these disabled features.</p>"}, {"location": "dashboard/#project-tab", "title": "Project tab", "text": "<p>Resources (instances, data volumes, networks, ...) in OpenStack are organized into different projects, and every user is a member of one or more projects. Every project member has full access to all of the project's resources.</p> <p>From the Project tab, you can access the following categories:</p> <p>API Access View API endpoints.</p> <p>Compute</p> <ul> <li>Overview: View reports for the project.</li> <li> <p>Instances: View, launch, create a snapshot from, stop, pause, or      reboot instances, or connect to them through VNC.</p> </li> <li> <p>Images: View images and instance snapshots created by project     users, plus any images that are publicly available. Create,     edit, and delete images, and launch instances from images and     snapshots.</p> </li> <li> <p>Key Pairs: View, create, edit, import, and delete key pairs.</p> </li> <li> <p>Server Groups: Server groups provide a mechanism to group         servers according to certain policy.</p> </li> </ul> <p>Volumes</p> <ul> <li> <p>Volumes: View, create, edit, and delete volumes.</p> </li> <li> <p>Snapshots: View, create, edit, and delete volume snapshots.</p> </li> </ul> <p>Network</p> <ul> <li> <p>Networks: Create and manage public and private networks.</p> </li> <li> <p>Security Groups: View, create, edit, and delete security groups      and security group rules..</p> </li> <li> <p>Floating IPs: Allocate an IP address to or release it from a      project</p> </li> </ul> <p>Orchestration</p> <ul> <li> <p>Stacks: Use the REST API to orchestrate multiple composite cloud     applications.</p> </li> <li> <p>Resource types: Show a list of all the supported resource types     for HOT templates.</p> </li> <li> <p>Template versions: The version of a Heat template specifies the     format of the template and also the corresponding features that     will be validated and supported.</p> </li> <li> <p>Template generator: A graphical interface to build and edit     templates.</p> </li> </ul> <p>Shares</p> <ul> <li>Shares: Create and manage share.</li> </ul>"}, {"location": "dashboard/#identity-tab", "title": "Identity tab", "text": "<p>From the Identity tab, you can access the following categories:</p> <p>Projects</p> <p>View, create, assign users to, remove users from, and delete projects.</p> <p>Users</p> <p>View, create, enable, disable, and delete users.</p> <p>Application Credentials</p> <p>With application credentials, a user can grant applications limited access to their cloud resources.</p>"}, {"location": "flavors/", "title": "Instance types and flavors", "text": "<p>VSC Tier1 Cloud provides several virtual machine instance types and flavors to fit different use cases. Each instance type provides several flavor sizes to give different combinations of CPU, memory, GPU and network resources.</p>"}, {"location": "flavors/#instance-types", "title": "Instance Types", "text": "<p>The following table provides the current main instance types available from the VSC Tier1 Cloud infrastructure:</p> <p>:::</p> UPSv1 CPUv1 GPUv2 GPUv3 - AMD Epyc 7542 2.9GHz - Intel Xeon CPU E5-2670 2.60GHz - AMD Epyc 7542 2.9GHz - AMD Epyc 7542 2.9GHz - 25Gbit Ethernet - 10Gbit Ethernet - 25Gbit Ethernet - 25Gbit Ethernet - vCPU oversubscription 2:1 - Uninterruptible Power Supply (UPS) - Uninterruptible Power Supply (UPS) - 1 full GPU NVIDIA Tesla4 - 1 full GPU NVIDIA Ampere A2 <p>:::</p> <p>Each instance type is appropriate for different workloads: (CPUv1) for regular CPU usage, (GPUvx) for GPU computations, or (UPSv1) for VMs that need to be connected to an uninterruptible power supply. VMs using UPS will keep up and running even if the datacenter suffers an unexpected power cut. (CPUv1) and (GPUv2) virtual machines are not supported by an UPS and will go offline when an unexpected power cut occurs.</p> <p>VSC Tier-1 Cloud instance types also provide different kind of network performance specifications. All the instance types are able to connect to the available networks: public network, VSC network and shared filesystem network (NFS). Note that VSC and shared file system network access is only made available if explicitly requested in the project application.</p> <p>VSC network gives an optimal path towards other VSC sites. This is ideal for high performance connections between different clusters and services within VSC. E.g. when you intend to do high data volume reshuffling between VMs and other Tier-1 components.</p> <p>Cloud projects should request VSC network if they want to connect to VSC Data component (https://www.vscentrum.be/data) with iRODS and Globus from their Tier1 Cloud VMs.</p> <p>On the other hand, the shared filesystem network is required by the OpenStack shared filesystem service (Manila) (see chapter 10 for more information).</p>"}, {"location": "flavors/#flavor-sizes", "title": "Flavor Sizes", "text": "<p>A flavor size is a set of virtualized hardware resources to a virtual machine (VM) instance like system memory size (RAM), virtual cores (vCPUs) or the root filesystem size.</p> <p>The flavor's root disk size is the amount of disk space used by the root (/) partition, an ephemeral disk that the base image is copied into (see section launch an instance  for more information about VM persistent/non-persistent instances).</p> <p>The flavor's root ephemeral storage is only used when booting from a non-persistent VM, but is not used when booting from a persistent storage volume or persistent VM. The flavor's root ephemeral size is not taken into account to calculate the project's local storage quota either. You can also create a persistent volume and choose the desired filesystem size for your persistent VM during the instantiation. VM persistent volumes could be resized later if that is necessary (see chapter launch an instance  for more information).</p> <p>VSC Tier-1 Cloud VM flavors are grouped by instance types (see table). Several flavor sizes are available for each instance type, differing in the number of allocated vCPUs, RAM and storage size. Every GPU flavor in addition allocates one full GPU card. The various VM flavors can be used in different combinations to fit different workload hardware requirements.</p> <p>:::</p> Name RAM Root Disk vCPUs GPUs CPUv1.nano 64Kb 1Gb 1 0 CPUv1.tiny 512Kb 10Gb 1 0 UPSv1.medium 4Gb 30Gb 2 0 UPSv1.large 8Gb 40Gb 4 0 UPSv1.2xlarge 60Gb 40Gb 16 0 GPUv2.small 2Gb 20Gb 1 1 GPUv2.medium 4Gb 30Gb 2 1 GPUv2.large 8Gb 40Gb 4 1 GPUv2.2xlarge 60Gb 40Gb 16 1 UPSv1.3xlarge 120Gb 80Gb 16 0 CPUv1.1_3xlarge 180Gb 80Gb 14 0 CPUv1.4xlarge 360Gb 80Gb 20 0 CPUv1.small 2Gb 20Gb 1 0 GPUv3.small 2Gb 20Gb 1 1 GPUv3.medium 4Gb 30Gb 2 1 GPUv3.large 8Gb 40Gb 4 1 GPUv3.2xlarge 60Gb 40Gb 16 1 CPUv1.medium 4Gb 30Gb 2 0 CPUv1.large 8Gb 40Gb 4 0 CPUv1.xlarge 16Gb 40Gb 8 0 CPUv1.2xlarge 60Gb 40Gb 16 0 CPUv1.3xlarge 120Gb 80Gb 16 0 CPUv1.1_2xlarge 60Gb 40Gb 8 0 UPSv1.small 2Gb 20Gb 1 0 <p>:::</p> <p>E.g. The GPUv2.large OpenStack flavor will instantiate a VM with 4 AMD Epyc 7542 2.9GHz vCPUs, with 1 NVIDIA Tesla4 GPU, 8GB of RAM, and a 40GB root disk.</p>"}, {"location": "gpus/", "title": "GPUs", "text": "<p>VSC Tier-1 Cloud users can also deploy VMs with different kind of GPUs. A full GPU card is connected directly to the VM via PCI passthrough and it is not shared between VMs.</p> <p>See section Instance types and flavors for more information about the different GPUs available (<code>GPUv*</code> flavors).</p> <p>Nvidia GPUs require the proprietary Nvidia driver to work, here it is explained how to install and keep updated Nvidia drivers for each public OS available from VSC Tier-1 Cloud.</p>"}, {"location": "gpus/#ubuntu", "title": "Ubuntu", "text": "<ul> <li> <p>Add graphics drivers ppa repo: <pre><code>sudo add-apt-repository ppa:graphics-drivers/ppa\n</code></pre></p> </li> <li> <p>Install Ubuntu drivers app: <pre><code>sudo apt install ubuntu-drivers-common\n</code></pre></p> </li> <li> <p>Check available GPUs:</p> </li> </ul> <pre><code>ubuntu-drivers devices\n</code></pre> <pre><code>== /sys/devices/pci0000:00/0000:00:06.0 ==\nmodalias : pci:v000010DEd00001EB8sv000010DEsd000012A2bc03sc02i00\nvendor   : NVIDIA Corporation\nmodel    : TU104GL [Tesla T4]\ndriver   : nvidia-driver-470-server - distro non-free\ndriver   : nvidia-driver-515 - distro non-free\ndriver   : nvidia-driver-470 - distro non-free\ndriver   : nvidia-driver-525-server - distro non-free\ndriver   : nvidia-driver-418-server - distro non-free\ndriver   : nvidia-driver-510 - distro non-free\ndriver   : nvidia-driver-525 - distro non-free recommended\ndriver   : nvidia-driver-515-server - distro non-free\ndriver   : nvidia-driver-450-server - distro non-free\ndriver   : xserver-xorg-video-nouveau - distro free builtin\n</code></pre> <ul> <li> <p>Install latest Nvidia driver (change <code>525</code> with the latest version available in your case): <pre><code>sudo apt install nvidia-driver-525\n</code></pre></p> </li> <li> <p>Reboot your VM.</p> </li> <li>Check Nvidia driver and CUDA are available after the reboot: <pre><code>$ nvidia-smi\nThu Feb  2 16:47:42 2023\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 525.78.01    Driver Version: 525.78.01    CUDA Version: 12.0     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|===============================+======================+======================|\n|   0  Tesla T4            Off  | 00000000:00:06.0 Off |                    0 |\n| N/A   45C    P8    16W /  70W |      6MiB / 15360MiB |      0%      Default |\n|                               |                      |                  N/A |\n+-------------------------------+----------------------+----------------------+\n\n+-----------------------------------------------------------------------------+\n| Processes:                                                                  |\n|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |\n|        ID   ID                                                   Usage      |\n|=============================================================================|\n|    0   N/A  N/A       833      G   /usr/lib/xorg/Xorg                  4MiB |\n+-----------------------------------------------------------------------------+\n</code></pre></li> </ul>"}, {"location": "gpus/#alma-linuxcentosred-hat-8x", "title": "Alma Linux/CentOS/Red Hat 8.x", "text": "<ul> <li> <p>Add epel repo: <pre><code>sudo dnf install epel-release\n</code></pre></p> </li> <li> <p>Add Nvidia repo: <pre><code>sudo dnf config-manager --add-repo https://developer.download.nvidia.com/compute/cuda/repos/rhel8/x86_64/cuda-rhel8.repo\n</code></pre></p> </li> <li> <p>Install Nvidia driver and cuda: <pre><code>sudo dnf install nvidia-driver nvidia-driver-cuda nvidia-driver-NVML\n</code></pre></p> </li> <li> <p>Reboot your VM.</p> </li> <li>Check Nvidia driver and CUDA are available after the reboot: <pre><code>$ nvidia-smi\nThu Feb  2 15:36:40 2023       \n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 525.85.12    Driver Version: 525.85.12    CUDA Version: 12.0     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|===============================+======================+======================|\n|   0  Tesla T4            Off  | 00000000:00:06.0 Off |                    0 |\n| N/A   63C    P0    31W /  70W |      2MiB / 15360MiB |      8%      Default |\n|                               |                      |                  N/A |\n+-------------------------------+----------------------+----------------------+\n\n+-----------------------------------------------------------------------------+\n| Processes:                                                                  |\n|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |\n|        ID   ID                                                   Usage      |\n|=============================================================================|\n|  No running processes found                                                 |\n+-----------------------------------------------------------------------------+\n</code></pre></li> </ul>"}, {"location": "gpus/#debian-11", "title": "Debian 11", "text": "<ul> <li> <p>Install required repositories from Debian: <pre><code>sudo apt install software-properties-common linux-headers-$(uname -r) -y\nsudo add-apt-repository contrib\nsudo add-apt-repository non-free\nsudo apt install dirmngr ca-certificates software-properties-common apt-transport-https dkms curl -y\n</code></pre></p> </li> <li> <p>Import GPG key from Nvidia repo: <pre><code>curl -fSsL https://developer.download.nvidia.com/compute/cuda/repos/debian11/x86_64/3bf863cc.pub | sudo gpg --dearmor | sudo tee /usr/share/keyrings/nvidia-drivers.gpg &gt; /dev/null 2&gt;&amp;1\n</code></pre></p> </li> <li> <p>Import Nvidia repo: <pre><code>echo 'deb [signed-by=/usr/share/keyrings/nvidia-drivers.gpg] https://developer.download.nvidia.com/compute/cuda/repos/debian11/x86_64/ /' | sudo tee /etc/apt/sources.list.d/nvidia-drivers.list\nsudo apt update\nsudo apt install nvidia-driver cuda nvidia-smi nvidia-settings -y\n</code></pre></p> </li> <li> <p>Reboot your VM.</p> </li> <li>Check Nvidia driver and CUDA are available after the reboot: <pre><code>$ nvidia-smi\nWed Feb  8 16:32:36 2023       \n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 525.85.12    Driver Version: 525.85.12    CUDA Version: 12.0     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|===============================+======================+======================|\n|   0  NVIDIA A2           On   | 00000000:00:06.0 Off |                    0 |\n|  0%   46C    P0    20W /  60W |      0MiB / 15356MiB |      0%      Default |\n|                               |                      |                  N/A |\n+-------------------------------+----------------------+----------------------+\n\n+-----------------------------------------------------------------------------+\n| Processes:                                                                  |\n|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |\n|        ID   ID                                                   Usage      |\n|=============================================================================|\n|  No running processes found                                                 |\n+-----------------------------------------------------------------------------+\n</code></pre></li> </ul>"}, {"location": "heat_templates/", "title": "Orchestration Using Heat", "text": "<p>Heat is the name of the OpenStack orchestration engine, which can manage complete configurations of all servers, volumes, users, networks and routers that make up a cloud application. Instead of managing every component separately, we can create, start, stop or clean up our complete application in a single step. In OpenStack, such a collection of resources is called a stack.</p> <p>Heat has its own dashboard interface, which you can find under the tab. Official documentation for Heat and its dashboard interface can be found at the following locations:</p> <ul> <li> <p>https://docs.openstack.org/heat/latest</p> </li> <li> <p>https://docs.openstack.org/heat-dashboard/latest</p> </li> </ul>"}, {"location": "heat_templates/#heat-orchestration-template", "title": "Heat Orchestration Template", "text": "<p>A stack's resources and their mutual dependencies can be specified in a text file, called a Heat Orchestration Template. The syntax of these templates conforms to the yaml standard, for which many text editors provide specialized editing modes. The Template Guide in the Heat documentation contains a specification of the HOT format, as well as information on how to describe the various types of resources in a template.</p> <p>VSC provides some example templates at github.com/hpcugent/openstack-templates, which can serve as a starting point for your own templates, or as examples.</p> <p>The following example describes a stack consisting of a single VM:</p> <pre><code>heat_template_version: 2018-08-31\n\ndescription: &gt; This template instantiates a basic VM.\n\nparameters:\nuser_key:\ntype: string\nlabel: ssh_user_key\ndescription: Public user ssh key to be injected in the cluster VMs\nconstraints:\n- custom_constraint: nova.keypair\nvm_flavour:\ntype: string\nlabel: vm_flavour\ndescription: Flavour for the VM\nconstraints:\n- custom_constraint: nova.flavor\nvm_image:\ntype: string\nlabel: vm_image\ndescription: Required VM image\nconstraints:\n- custom_constraint: glance.image\nuser_network:\ntype: string\nlabel: user_network\ndescription: Add the required VM network\nconstraints:\n- custom_constraint: neutron.network\n\nresources:\nmy_server:\ntype: OS::Nova::Server\nproperties:\nname: MyServer\nmetadata:\n# Some metadata examples to be included in the VM\nserver: master\ncolor: red\nsecurity_groups: - default\nnetworks: - network: { get_param: user_network }\ntag: master_ip\nkey_name: { get_param: user_key }\nimage: { get_param: vm_image }\nflavor: { get_param: vm_flavour }\n</code></pre> <p>Our example contains four main sections:</p> <p>heat_template_version</p> <p>The HOT specification has evolved since its initial release. The key <code>heat_template_version</code> indicates the version of the syntax used in this template. It's value can be a release date or (in recent version) the name of the version.</p> <p>description</p> <p>Providing a description is optional, but recommended.</p> <p>parameters</p> <p>Another optional section, <code>parameters</code> allow users to configure various properties when instantiating a new stack, without having to edit the template itself. A parameter value can be used elsewhere in the template using the function <code>get_param</code>. In this example, we use parameters to choose an SSH key, instance size (\"flavor\"), image, and a network.</p> <p>resources</p> <p>This section contains all the resources used by the Stack. In this case, there is just a single VM instance (OS::Nova::Server).</p> <p>Optional additional sections are paremeter_groups, outputs, and .</p>"}, {"location": "heat_templates/#the-template-generator", "title": "The Template Generator", "text": "<p>The Heat dashboard provides a graphical interface where users can draw templates by dragging resources onto a canvas, and connecting them. Users can then download a template generated from this interface, or immediately instantiate it as a stack.</p> <p>Currently, there are a number of issues with the template generator, which require manual edits to the generated templates. Therefore, the template generator is currently not very useful. We will update this section as soon as these problems are solved.</p>"}, {"location": "heat_templates/#managing-stacks", "title": "Managing stacks", "text": "<p>The button in the tab takes you to the overview page where you can launch, suspend, resume and delete stacks.</p> <p></p> <p>The overview page contains a list of all currently existing stacks (either running or suspended), and buttons to perform the following actions:</p>"}, {"location": "heat_templates/#launch-a-stack", "title": "Launch a stack", "text": "<ol> <li>Click to open the following wizard:</li> </ol> <ol> <li> <p>Provide a template and --- optionally --- an environment for the     stack.</p> <ol> <li>Template Source</li> </ol> <p>You can provide a template using one of the following options:</p> <ol> <li> <p>File</p> <p>Provide a local file on your system.</p> </li> <li> <p>Direct Input</p> <p>Enter the template in a text field.</p> </li> <li> <p>URL</p> <p>Provide a URL to have OpenStack download the template from that location.</p> <p>In our example, we provide a URL from the repository https://github.com/hpcugent/openstack-templates, to instantiate the example from previous section. If you want to provide a template directly from GitHub, make sure to provide a \"Raw\" URL, <code>https://raw.githubusercontent.com/</code>....</p> </li> <li> <p>Environment Source</p> <p>Optionally, you can also provide an environment file. This is another [yaml]{.smallcaps} file, which contains customizations for your Heat templates, such as default values for parameters, or custom resource types you have created (see 'Environments' in the Heat template guide). You can provide a File or choose Direct Input.</p> </li> </ol> </li> <li> <p>If you click Next, OpenStack will process the template. You can now     enter a name for the stack, and provide values for all the template     parameters:</p> </li> </ol> <p></p> <ol> <li>Click Launch to instantiate the stack.</li> </ol>"}, {"location": "heat_templates/#preview-stack", "title": "Preview Stack", "text": "<p>starts a wizard similar to the \"Launch Stack\" wizard, but completing the wizard will only make the system perform a sanity check of your template, without instantiating the stack. If the check passes, you can inspect the parameters of the stack that would be created. The wizard does not allow you to enter input parameter values, so any mandatory input parameters should be provided in an environment.</p>"}, {"location": "heat_templates/#delete-stacks", "title": "Delete Stacks", "text": "<p>deletes all selected stacks from the list .</p> <p>Deleting a stack also deletes all of the resources (volumes, ports) created by that stack, unless a different policy was set in the property for those resources (see the Resources section in the HOT specification).</p>"}, {"location": "heat_templates/#more-actions", "title": "More Actions", "text": "<p>The button More Actions hides the following additional actions:</p> <p>Check Stacks verifies if the resources for selected stacks are still running.</p> <p>Suspend Stacks suspends all resources of the selected stacks.</p> <p>Resume Stacks resumes the selected (suspended) stacks.</p> <p>You can quickly suspend, resume or delete a single stack using the drop-down menu in the Actions column of the overview. This menu also contains the option Change Stack Template, which allows you to update a Stack by providing a new template.</p>"}, {"location": "introduction/", "title": "Introduction", "text": "<p>The VSC cloud platform uses the open-source software OpenStack, version \"Train\". This guide explains the specifics of the VSC environment, and provides a hands-on introduction to OpenStack. For reference, you should consult the OpenStack project's own documentation at https://docs.openstack.org.</p> <p>For all questions concerning the VSC cloud computing platform, please contact cloud@vscentrum.be. We welcome your feedback, comments and suggestions for improving the OpenStack VSC Tutorial.</p>"}, {"location": "launch_instance/", "title": "Launch and manage instances", "text": "<p>Instances are virtual machines that run inside the cloud. You can launch an instance from the following sources:</p> <ul> <li>Images uploaded to the Image service.</li> </ul> <p>Note</p> <p>Because images are read-only, any changes made while the instance is running will be lost when the instance is deleted, unless you choose to create a persistent volume for your instance when you launch it. Using a volume, the VM's state is saved, even when the current instance is deleted.</p> <ul> <li> <p>Images which you previously copied to a persistent volume. The     instance launches from the volume.</p> </li> <li> <p>Instance snapshots.</p> </li> </ul>"}, {"location": "launch_instance/#launch-an-instance", "title": "Launch an instance", "text": "<ol> <li> <p>Open the Compute tab and select the Instances category.</p> <p>The dashboard shows the list of existing instances with their name, IP addresses, flavor, status, power state, ...</p> </li> <li> <p>Click Launch Instance.</p> </li> <li> <p>In the Launch Instance dialog box, specify the following values:</p> </li> </ol> <p></p>"}, {"location": "launch_instance/#details-tab", "title": "Details tab", "text": ""}, {"location": "launch_instance/#instance-name", "title": "Instance Name", "text": "<p>Assign a name to the virtual machine.</p> <p>Tip</p> <p>The name you assign here becomes the initial host name of the server. If the name is longer than 63 characters, the Compute service truncates it automatically to ensure dnsmasq works correctly.</p> <p>After the server is built, if you change the server name in the API or change the host name directly, the names are not updated in the dashboard.</p> <p>Server names are not guaranteed to be unique when created so you could have two instances with the same host name.</p>"}, {"location": "launch_instance/#description", "title": "Description", "text": "<p>You can assign a brief description of the virtual machine.</p>"}, {"location": "launch_instance/#availability-zone", "title": "Availability Zone", "text": "<p>Large-scale OpenStack systems may consist of multiple availability zones, which are groups of hypervisors connected to different power sources. By assigning instances to different availability zones, users can protect themselves against power failures. However, the VSC cloud consists of just a single zone, called .</p>"}, {"location": "launch_instance/#count", "title": "Count", "text": "<p>To launch multiple instances, enter a value greater than . The default is 1.</p> <p></p>"}, {"location": "launch_instance/#source-tab", "title": "Source tab", "text": ""}, {"location": "launch_instance/#select-boot-source", "title": "Select Boot Source", "text": "<p>Your options are:</p> <ul> <li> <p>Image</p> </li> <li> <p>Image snapshot</p> </li> <li> <p>Volume</p> </li> <li> <p>Volume snapshot</p> <p>Depending on the type of boot source, the list of available items changes.</p> </li> </ul>"}, {"location": "launch_instance/#create-new-volume", "title": "Create New Volume", "text": "<p>If you enable this option when launching from an image or instance snapshot, the image or snapshot will be copied to a volume. This way, the state of your instance persists after shutdown and reboot.</p>"}, {"location": "launch_instance/#flavor-tab", "title": "Flavor tab", "text": "<p>Specify the size of the instance to launch.</p> <p>Note</p> <p>The flavor is selected based on the size of the image selected for launching an instance. For example, while creating an image, if you have entered the value in the Minimum RAM (MB) field as 2048, then on selecting the image, the default flavor is CPUv1.small (see section instance type for more information). If a :exclamation: warning sign is displayed next to a resource for one of the flavors, that means that this flavor would exceed the project's quota for that resource, and therefore is not available.</p>"}, {"location": "launch_instance/#networks-tab", "title": "Networks tab", "text": "<p>Add one or more networks to the instance.</p>"}, {"location": "launch_instance/#network-ports-tab", "title": "Network Ports tab", "text": "<p>Activate the ports that you want to assign to the instance.</p>"}, {"location": "launch_instance/#security-groups-tab", "title": "Security Groups tab", "text": "<p>Activate the security groups that you want to assign to the instance.</p> <p>Security groups are a kind of cloud firewall that define which incoming network traffic is forwarded to instances. See section configure access for more information. The default security group is assigned to the instance automatically.</p>"}, {"location": "launch_instance/#key-pair-tab", "title": "Key Pair tab", "text": "<p>Specify a key pair.</p> <p>If the image uses a static root password or a static key set (neither is recommended), you do not need to provide a key pair to launch the instance.</p>"}, {"location": "launch_instance/#configuration-tab", "title": "Configuration tab", "text": "<p>Specify a customization script that runs after your instance launches.</p>"}, {"location": "launch_instance/#server-groups-tab", "title": "Server Groups tab", "text": "<p>You can organize instances into groups with a scheduling policy. With an \"affinity\" policy, OpenStack will try to schedule those instances on the same hypervisors, which is useful for instances that need to communicate with each other a lot. With an \"anti-affinity\" policy, instances will be scheduled on different hypervisors, which you might use for instances that provide redundant copies of a single service.</p>"}, {"location": "launch_instance/#scheduler-hints-tab", "title": "Scheduler Hints tab", "text": "<p>By providing scheduler hints, you can get more fine grained control over which hypervisor your instances are scheduled on.</p>"}, {"location": "launch_instance/#metadata-tab", "title": "Metadata tab", "text": "<p>Add Metadata items to your instance.</p> <ul> <li>Click Launch Instance</li> </ul> <p>The instance starts on a compute node in the cloud.</p> <p>Note</p> <p>If you did not provide a key pair, security groups, or rules, users can access the instance only from inside the cloud through VNC. Even pinging the instance is not possible without an ICMP rule configured.</p> <p>You can also launch an instance from the Images or Volumes category when you launch an instance from an image or a volume respectively.</p> <p>When you launch an instance from an image, OpenStack creates a local copy of the image on the compute node where the instance starts.</p> <p>For details on creating images, see Creating images manually in the OpenStack Virtual Machine Image Guide.</p>"}, {"location": "launch_instance/#connect-to-an-instance-using-ssh", "title": "Connect to an instance using SSH", "text": "<p>Before you can connect to an instance using SSH, you must set up a floating IP for it, as discussed in section\u00a0floating-ip. Recall that only ports 50000 to 60000 of the floating IP's can be directly reached from outside the UGent network.</p> <p>Note</p> <p>When you try to connect to a new instance using a port that was previously forwarded to a different instance --- either due to a change in the port forwarding configuration, or because an old instance was deleted and replaced --- your SSH client will show an error message because the \"host key\" of the new instance doesn't match the known previous key. Section explains how to handle such errors.</p> <p>Note</p> <p>If you want to access ports outside the public range, you'll need to connect to the UGent login node login.hpc.ugent.be first, and hop to your instance from there. To make this work without storing the required private key for the instance in your VSC storage space, you need to set up an SSH agent with key forwarding locally, i.e.\u00a0on the machine where you store the private key of an authorized keypair for the instance. Section 2.1.4 of the HPC introduction explains how to set this up (hpcugent.github.io/vsc_user_docs).</p> <ul> <li>(Only if using a port blocked by the UGent firewall, see the note     above:) Use your VSC account to connect to the UGent login node,     using the <code>ssh -A</code> option to enable agent forwarding:</li> </ul> <pre><code>ssh -A vsc12345@login.hpc.ugent.be\n</code></pre> <ul> <li> <p>Copy the address of the floating IP where your instance can be     reached. In our example, the address is 193.190.85.40.</p> </li> <li> <p>Connect to the instance. Use OpenSSH's <code>-p</code> option to specify the     port where the instance's SSH server can be reached, e.g. for port     50022:</p> </li> </ul> <pre><code>ssh -A -p 50022 ubuntu@193.190.85.40\n</code></pre> <p>When you run the above command, your SSH client may display warnings or error messages. The section Host Keys Host Keys explains the meaning of these messages and how you should deal with them.</p> <p>Info</p> <p>The images we provide do not allow SSH logins for the root user. There is a default user instead, who can get administrative privileges using <code>sudo</code>. In our example, we have used the username <code>ubuntu</code> for Ubuntu images. Attempting to log in as root will return an error message with the proper user name.</p>"}, {"location": "launch_instance/#host-keys", "title": "Host keys", "text": "<p>When connecting to instances using SSH, you will sometimes see warnings or errors related to \"host keys\". This section briefly explains the meaning of those errors, and how to deal with them.</p> <p>When you try to connect to an instance, you use the private key of your SSH keypair to prove your identity to that instance. If you do not have access to the right secret key, you can not prove your identity, at which point the your instance's SSH server will deny access. In the same way, the server must prove its own identity to you, using its own keypair or \"host key\". Without such a verification procedure, third parties on the network between you and the instance could perform a so-called man-in-the-middle-attack, where they intercept the communication between you and the server you want to reach and steal valuable information.</p> <p>To prevent such man-in-the-middle attacks, the SSH client on your system stores the host key for every IP address you have connected to, and verifies the key the next time you try to connect to that address. If all goes well, this check is silently performed in the background, but there are a number of situations where the check fails. In this case, you have to look up the host key of your instance in the OpenStack dashboard to verify that the connection is secure.</p>"}, {"location": "launch_instance/#looking-up-an-instances-host-key", "title": "Looking up an instance's host key", "text": "<p>In order to verify a host key, it suffices to compare the key's fingerprint, a short alphanumerical sequence computed from the keys content. You can use the Dashboard to look up the host key fingerprint for an instance as follows:</p> <ol> <li> <p>Open the Compute tab and select the Instances category.</p> </li> <li> <p>Click on the name of the instance you want to connect to.</p> </li> <li> <p>Click Log</p> <p></p> </li> <li> <p>Click . You are taken to a new page with a long text listing.</p> </li> <li> <p>Search for the words -----BEGIN SSH HOST KEY FINGERPRINTS----- to     find the log file section containing the host key fingerprints, for     example:</p> </li> </ol> <pre><code>    &lt;14&gt;Jun 6 09:57:01 ec2:\n    #############################################################\n    &lt;14&gt;Jun 6 09:57:01 ec2: -----BEGIN SSH HOST KEY FINGERPRINTS-----\n    &lt;14&gt;Jun 6 09:57:01 ec2: 1024\n    SHA256:gCa0hZAaOnpzxYM5WnAZINuZTI5NAoqd41U/dtxeGKE root@my-instance\n    (DSA) &lt;14&gt;Jun 6 09:57:01 ec2: 256\n    SHA256:nyujUIF37c674FPSkDdz0xgAU6S39UWbmMzBPmdmCmg root@my-instance\n    (ECDSA) &lt;14&gt;Jun 6 09:57:01 ec2: 256\n    SHA256:Mcznquek1A3BFz6KEXSxsivpdkX1mY3LnymEA7C8Xxg root@my-instance\n    (ED25519) &lt;14&gt;Jun 6 09:57:01 ec2: 2048\n    SHA256:4DagYc9cZvANkSjbTL0pB+3ULqHg09zW4E8wvDrB4Do root@my-instance\n    (RSA) &lt;14&gt;Jun 6 09:57:01 ec2: -----END SSH HOST KEY\n    FINGERPRINTS----- &lt;14&gt;Jun 6 09:57:01 ec2:\n    #############################################################\n</code></pre> <p>In this example, the fingerprints are character sequences starting with \"SHA256\", such as the ECDSA key fingerprint SHA256:nyujUIF37c674FPSkDdz0xgAU6S39UWbmMzBPmdmCmg. The following sections describe the most common cases where you'll need these fingerprints.</p> <p>The following examples show output and commands for OpenSSH, the most common client on Linux and macOS. If you are working from a windows system using using PuTTY, we refer to PuTTY section of the windows version of the introduction to HPC for the corresponding warning messages.</p>"}, {"location": "launch_instance/#connecting-for-the-first-time", "title": "Connecting for the first time", "text": "<p>The first time you connect to a new ip address:port combination, your SSH client does not know the host key for this address, and therefore it can't verify the identity of the server. When using OpenSSH, the warning looks as follows (again using address 193.190.85.40 and port 50022 as an example):</p> <pre><code>The authenticity of host '[193.190.85.40]:50022\n([193.190.85.40]:50022)' can't be established. ECDSA key fingerprint\nis SHA256:nyujUIF37c674FPSkDdz0xgAU6S39UWbmMzBPmdmCmg. Are you sure you\nwant to continue connecting (yes/no)?\n</code></pre> <p>Verify the fingerprint in order to make sure that it is safe to proceed:</p> <ol> <li> <p>Look up the fingerprint of the instance you want to access,     according to the procedure described in the section .</p> </li> <li> <p>Verify that the fingerprint you find in the Dashboard matches the     fingerprint shown in the warning message.</p> <p>In this example, we see that the ECDSA key fingerprint reported by the SSH client matches the fingerprint of our instance from the previous section, namely</p> <p>SHA256:nyujUIF37c674FPSkDdz0xgAU6S39UWbmMzBPmdmCmg</p> </li> <li> <p>If the fingerprints are identical, type \"yes\" to log in.</p> </li> </ol> <p>Warning</p> <p>If the fingerprints do not match, type no, and contact cloud@vscentrum.be.</p>"}, {"location": "launch_instance/#new-instance-at-a-known-address", "title": "New instance at a known address", "text": "<p>Another case where the host key verification fails, is when you try to access a new instance at an IP address and port previously used by another instance. This can happen if you modify your port forwarding configuration, or if a running instance connected to a certain port is deleted and replaced by a new one. In this case, OpenSSH will show a warning such as this:</p> <pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS\nPOSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be\neavesdropping on you right now (man-in-the-middle attack)! It is also\npossible that a host key has just been changed. The fingerprint for the\nECDSA key sent by the remote host is\nSHA256:hI2HcqFxsCKwEauq2QvBmgDN4nCPjllaRsYoCb7tJQw. Please contact your\nsystem administrator. Add correct host key in [...]/.ssh/known_hosts\nto get rid of this message. Offending ECDSA key in\n[...]/.ssh/known_hosts:57 ECDSA host key for [193.190.85.40]:50322\nhas changed and you have requested strict checking. Host key\nverification failed.\n</code></pre> <p>The file known_hosts in your OpenSSH configuration directory contains a list of all hosts you have previously connected to, together with their host keys. The warning above tells you that the server you are connecting to is not using the same key anymore. In this case, you should take the following steps:</p> <ol> <li>Look up the fingerprint of the instance you want to access, according to the procedure described in the section Looking up an instance\u2019s host key.</li> <li>Verify that the fingerprint you find in the Dashboard matches the fingerprint shown in the warning message.</li> <li>If the fingerprint matches, the new key is legitimate. Remove the previous known key from the known_hosts file as follows (still using address 193.190.85.40 and port number 50322 as an example):</li> </ol> <p><pre><code>ssh-keygen -R [193.190.85.40]:50322\n</code></pre> This command causes OpenSSH to forget the previous key. On your next attempt to connect to that address, OpenSSH will treat it as a new host and ask you to verify the fingerprint as described in section Connecting for the first time.</p> <p>Warning</p> <p>If the fingerprint does not match, do not attempt to connect, and contact cloud@vscentrum.be.</p>"}, {"location": "launch_instance/#track-usage-for-instances", "title": "Track usage for instances", "text": "<p>You can track usage for instances for each project. You can track costs per month by showing meters like number of vCPUs, disks, RAM, and uptime for all your instances.</p> <ol> <li> <p>Open the Compute tab and select the Overview category.</p> </li> <li> <p>To query the instance usage for a period of time, select a time     range and click .</p> </li> <li> <p>To download a summary, click Download CSV Summary.</p> </li> </ol>"}, {"location": "launch_instance/#create-an-instance-snapshot", "title": "Create an instance snapshot", "text": "<ol> <li> <p>Open the Compute tab and select the Instances category.</p> </li> <li> <p>Select the instance from which to create a snapshot.</p> </li> <li> <p>In the actions column, click Create Snapshot.</p> </li> <li> <p>In the Create Snapshot dialog box, enter a name for the snapshot,     and click Create Snapshot.</p> </li> </ol> <p>The Images category shows the instance snapshot.</p> <p>To launch an instance from the snapshot, select the snapshot and click Launch. Proceed with launching an instance.</p>"}, {"location": "launch_instance/#manage-an-instance", "title": "Manage an instance", "text": "<ol> <li> <p>Open the Compute tab and select the Instances category.</p> </li> <li> <p>Select an instance.</p> </li> <li> <p>In the menu list in the actions column, select the state.</p> <p>You can resize or rebuild an instance. You can also choose to view the instance console log, edit instance or the security groups. Depending on the current state of the instance, you can pause, resume, suspend, soft or hard reboot, or terminate it.</p> </li> </ol>"}, {"location": "launch_instance/#difference-between-suspend-pause-shelve-shut-off-delete", "title": "Difference between suspend, pause, shelve, shut off, delete", "text": "<p>Pause</p> <p>Stores the state of the VM in the (RAM) memory.</p> <p>Suspend</p> <p>Stores the state of the VM on the disk, all memory is written to disk, and the server is stopped.</p> <p>Shut off</p> <p>The server is powered down by the user, either through the OpenStack Compute API, or from within the server by issuing a shutdown -h command. In this state the user retains all computational resources associated with the VM. The instance can be later restarted.</p> <p>Shelve</p> <p>Shelving stops the instance and takes a snapshot of it. Then depending on the value of the shelved_offload_time config option, the instance is either deleted from the hypervisor (0), never deleted (-1), or deleted after some period of time (&gt; 0). Shelve preserves all associated data and VM resources but does not retain anything in memory.</p> <p>Delete</p> <p>The VM is deleted and removed from OpenStack together with any associated processes and resources. However, for instances backed by a persistent volume, this volume is not deleted. When such an instance is deleted, you can restore it by launching a new instance from the volume, or delete the volume as well (see section delete a volume).</p> <p>For more details see the OpenStack documentation on Virtual Machine States and Transitions and Server concepts.</p>"}, {"location": "manage_images/", "title": "Upload and manage images", "text": "<p>A virtual machine image, referred to in this document simply as an image, is a single file that contains a virtual disk that has a bootable operating system installed on it. Images are used to create virtual machine instances within the cloud. The image files themselves are never modified, but you can copy the image into a persistent instance (see launch instance)</p> <p>As a user of the VSC cloud, you can upload and manage your own virtual machine images. For information about creating image files, see the OpenStack Virtual Machine Image Guide.</p> <p>Note</p> <p>Shared storage in the VSC cloud is connected to a separate network, which is only accessible from within the OpenStack environment. Therefore, if you want to access your VM from outside of OpenStack, and use the shared storage at the same time, you must make sure your VM image is configured use multiple network interface cards (NICs).</p> <p>You can choose who can access an image you have created. The following access policies for images exist:</p> <p>public</p> <p>Public images are provided by the VSC, and can be accessed by all users.</p> <p>private</p> <p>If you create a private image, only members of the same project have access.</p> <p>shared</p> <p>You can also choose to share your image with a list of other projects.</p> <p>community</p> <p>Community images are user-created images which are freely accessible to all other users.</p> <p>Tip</p> <p>You can also use the openstack and glance command-line clients or the Image service to manage images.</p>"}, {"location": "manage_images/#upload-an-image", "title": "Upload an image", "text": "<p>Follow this procedure to upload an image to a project:</p> <ol> <li> <p>Open the Compute tab and click Images category.</p> </li> <li> <p>Click Create Image.</p> <p>The Create An Image dialog box appears.</p> <p></p> </li> <li> <p>Enter the following values:</p> <ol> <li> <p>Image Name: Enter a name for the image.</p> </li> <li> <p>Image Description: Enter a brief description of the image.</p> </li> <li> <p>Image Source</p> <ul> <li>File: Browse for the image file on your file system and add it.</li> <li>Format: Select the image format (for example, QCOW2) for the image.</li> </ul> </li> <li> <p>Image Requirements</p> <ul> <li>Architecture: Specify the architecture. For example, for a 32-bit architecture or for a 64-bit architecture.</li> <li>Kernel, Ramdisk: Can be left empty, as this is determined by the image file.</li> <li>Minimum Disk (GB), Minimum RAM (MB): Choose suitable values, according to the requirements of your image's operating system.</li> </ul> </li> <li> Protected If set to Yes, users need to unlock the image before they are able to delete it. </li> <li> Metadata You can add resource metadata in this tab. The glance Metadata Catalog provides a list of metadata image definitions. </li> </ol> </li> <li> <p>Click Create Image. The image is queued to be uploaded. It might take some time     before the status changes from Queued to Active.</p> </li> </ol>"}, {"location": "manage_images/#update-an-image", "title": "Update an image", "text": "<p>Follow this procedure to update an existing image.</p> <ol> <li> <p>Open the project tab and click the Images category.</p> </li> <li> <p>Select the image that you want to edit.</p> </li> <li> <p>In the Actions column, open the drop-down menu and select Edit Image.</p> </li> <li> <p>In the Edit Image dialog box, you can perform various actions. For     example:</p> <ul> <li> <p>Change the name of the image.</p> </li> <li> <p>Change the description of the image.</p> </li> <li> <p>Change the format of the image.</p> </li> <li> <p>Change the minimum disk of the image.</p> </li> <li> <p>Change the minimum RAM of the image.</p> </li> <li> <p>Change the protected status of the image.</p> </li> <li> <p>Change the metadata of the image.</p> </li> </ul> </li> <li> <p>Click Edit Image.</p> </li> </ol>"}, {"location": "manage_volumes/", "title": "Create and manage volumes", "text": "<p>An OpenStack Volume is a block storage device which you attach to instances to enable persistent storage. You can attach a volume to a running instance or detach a volume and attach it to another instance at any time. You can also create a snapshot from a volume, or delete it.</p>"}, {"location": "manage_volumes/#create-a-volume", "title": "Create a volume", "text": "<ol> <li> <p>Open the Volumes tab and select the Volumes category.</p> </li> <li> <p>Click Create Volume.</p> <p>In the dialog box that opens, enter or select the following values.</p> <ul> <li> <p>Volume Name Specify a name for the volume.</p> </li> <li> <p>Description Optionally, provide a brief description for the volume.</p> </li> <li> <p>Volume Source Select one of the following options:</p> <ul> <li> <p>No source, empty volume: Creates an empty volume. An empty     volume does not contain a file system or a partition table.</p> </li> <li> <p>Snapshot: If you choose this option, a new field for Use     snapshot as a source displays. You can select the snapshot     from the list.</p> </li> <li> <p>Image: If you choose this option, a new field for Use image     as a source displays. You can select the image from the     list.</p> </li> <li> <p>Volume: If you choose this option, a new field for Use     volume as a source displays. You can select the volume from     the list. Options to use a snapshot or a volume as the     source for a volume are displayed only if there are existing     snapshots or volumes.</p> </li> </ul> </li> <li> <p>Type Select one of the following options:</p> <ul> <li> <p>tripleo: This is the default option for the projects, it     creates the volume in a regular hdd storage pool.</p> </li> <li> <p>fastpool (optional): It creates the volume in a high I/O     throughput storage pool. Fastpool has its own storage quota     and it is only accessible by project's request (contact if     you need more information).</p> </li> </ul> </li> <li> <p>Size (GB) The size of the volume in gibibytes (GiB).</p> </li> <li> <p>Availability Zone Select the Availability Zone from the list. By default, this value is set to the availability zone given by the cloud provider (for example, or ). For some cases, it could be .</p> </li> </ul> </li> <li> <p>Click Create Volume.</p> </li> </ol> <p>The dashboard shows the volume on the Volumes tab.</p>"}, {"location": "manage_volumes/#attach-a-volume-to-an-instance", "title": "Attach a volume to an instance", "text": "<p>After you create one or more volumes, you can attach them to instances. You can attach a volume to one instance at a time.</p> <ol> <li> <p>Open the Volumes tab and click Volumes category.</p> </li> <li> <p>Select the volume to add to an instance and click Manage Attahments.</p> </li> <li> <p>In the Manage Volume Attachments dialog box, select an instance.</p> </li> <li> <p>Enter the name of the device from which the volume is accessible by     the instance.</p> </li> </ol> <p>Note</p> <p>The actual device name might differ from the volume name because of hypervisor settings.</p> <ol> <li> <p>Click Attach Volume.</p> <p>The dashboard shows the instance to which the volume is now attached and the device name.</p> </li> </ol> <p>You can view the status of a volume in the Volumes tab of the dashboard. The volume is either Available or In-Use.</p> <p>Now you can mount, format, and use the volume from this instance.</p>"}, {"location": "manage_volumes/#detach-a-volume-from-an-instance", "title": "Detach a volume from an instance", "text": "<ol> <li> <p>Open the Volumes tab and select the Volumes category.</p> </li> <li> <p>Select the volume and click Manage Attachments.</p> </li> <li> <p>Click Detach Volume and confirm your changes.</p> </li> </ol> <p>A message indicates whether the action was successful.</p>"}, {"location": "manage_volumes/#create-a-snapshot-from-a-volume", "title": "Create a snapshot from a volume", "text": "<ol> <li> <p>Open the Volumes tab and select the Volumes category.</p> </li> <li> <p>Select a volume from which to create a snapshot.</p> </li> <li> <p>In the Actions column, click Create Snapshot.</p> </li> <li> <p>In the dialog box that opens, enter a snapshot name and a brief     description.</p> </li> <li> <p>Confirm your changes.</p> </li> </ol> <p>The dashboard shows the new volume snapshot in Volume Snapshots tab.</p>"}, {"location": "manage_volumes/#edit-a-volume", "title": "Edit a volume", "text": "<ol> <li> <p>Open the Volumes tab and select the Volumes category.</p> </li> <li> <p>Select the volume that you want to edit.</p> </li> <li> <p>In the Actions column, click Edit Volume.</p> </li> <li> <p>In the Edit Volume dialog box, update the name and description of     the volume.</p> </li> <li> <p>Click Edit Volume.</p> </li> </ol> <p>Tip</p> <p>You can extend a volume by using the Extend Volume option available in the More dropdown list and entering the new value for volume size.</p>"}, {"location": "manage_volumes/#delete-a-volume", "title": "Delete a volume", "text": "<p>When you delete an instance, the data in its attached volumes is not deleted.</p> <ol> <li> <p>Open the Volumes tab and select the Volumes category.</p> </li> <li> <p>Select the check boxes for the volumes that you want to delete.</p> </li> <li> <p>Click Detele Volumes and confirm your choice.</p> </li> </ol> <p>A message indicates whether the action was successful.</p>"}, {"location": "shares/", "title": "Shared file systems using Manila", "text": "<p>OpenStack's Manila service makes it possible to create and manage shared nfs file systems for virtual machines. This service is not automatically enabled for every VSC cloud project, so you should contact cloud@vscentrum.be if you want to use shared file systems in your project.</p>"}, {"location": "shares/#creating-a-shared-file-system", "title": "Creating a Shared File System", "text": "<p>Creating a shared file system using the Horizon interface is quite straightforward:</p> <ol> <li> <p>Open the Share tab, and click Shares. A list of existing shares (if     any) is shown.</p> </li> <li> <p>Click the Create Share button to open the following dialog:</p> </li> </ol> <p></p> <p>Fill out the following fields:</p> <ul> <li> <p>Share Name</p> <p>Choose a name.</p> </li> <li> <p>Description</p> <p>Optionally, add a description.</p> </li> <li> <p>Share Protocol</p> <p>Use the default nfs protocol.</p> </li> <li> <p>Size (GiB)</p> <p>Set the size of the shared file system to be created. The total available storage and the amount currently used are shown on the right.</p> </li> <li> <p>Share Type</p> <p>Here, you must select \"cephfsnfstype\" (the only choice).</p> </li> <li> <p>Metadata</p> <p>You can attach additional metadata to your shared file system, which can be queried later on.</p> <p>Other fields are not mandatory. By default, the shared file system will only be visible within the current project (Visibility: \"private\"). Be careful with the option \"Make visible for all': enabling it will set the visibility of your shared file system to \"public\", making it visible for any other project in the VSC cloud as well.</p> </li> <li> <p>Click Create to complete this step.</p> </li> </ul> <p>At this point, the shared file system exists within OpenStack, but it cannot be used until we define access rules for it.</p>"}, {"location": "shares/#defining-nfs-access-rules", "title": "Defining nfs access rules", "text": "<p>You must define rules that define which machines on the network may obtain read or write access to your shared file system. By default, in absence of any rules, a shared file system cannot be accessed by anyone.</p> <ol> <li> <p>Open the drop-down menu in the Actions column for your share,     and click Manage Rules.</p> </li> <li> <p>You can now see all Share Rules for this shared file system. For a     newly created file system, the list will be empty. Click Add     rule.</p> </li> <li> <p>Fill out the Add Rule dialog:</p> <p>Access Type</p> <p>Only \"ip\" is supported.</p> <p>Access Level</p> <p>Choose if you want to give read and write (\"rw\") or read-only (\"ro\") permission with this rule.</p> <p>Access To</p> <p>Here, you can specify an ip address, or an address range, to which the rule applies. The addresses should be specified according to the format of an NFS exports configuration file. The following table contains a few examples, assuming the project's _nfs network has the subnet 10.10.x.0/24, for some value of x (see section _nfs networks):</p> </li> </ol> <p>:::</p> <ul> <li> <p>10.10.x.13</p> <ul> <li>Allow this single ip address.</li> </ul> </li> <li> <p>0.0.0.0/0</p> <ul> <li>Allow any ip address.</li> </ul> </li> <li>10.10.x.0/24<ul> <li>Allow any ip address from the project's _nfs network. For a non-public shared file system this has the same effect as the previous rule, because such a shared file system can only be accessed from within our project's _nfs network anyway.</li> </ul> </li> <li> <p>10.10.x.0/28</p> <ul> <li>Allow addresses 10.10.x.0 until 10.10.x.15.</li> </ul> <p>Click Add to add the rule.</p> </li> </ul> <p>Your rule now appears in the list. You can add as many rules as you wish, to set the access level for different addresses or address ranges.</p>"}, {"location": "shares/#accessing-a-shared-file-system", "title": "Accessing a shared file system", "text": "<p>When the proper access rules for the shared file system are in place, you can access it from an instance with a matching ip. In order to be able to mount the shared file system, your instance needs</p> <ul> <li> <p>a nfs client,     installed by default on images provided by the VSC cloud, and</p> </li> <li> <p>access to the _nfs network. Because your instance likely has to     connect to the _vm network as well, your VM should have two     nic's. Again,     this is taken care of in the default images.</p> </li> </ul> <p>When you are ready to mount the network file system on an instance, look up the network location of your file system using the Dashboard:</p> <ol> <li> <p>Open the Share tab and click Shares. The list of all shared file     systems in your project is shown.</p> </li> <li> <p>Click the name of the shared file system you wish to access.</p> </li> <li> <p>In the section \"Share Overview\", look for the item Export     locations.</p> </li> <li> <p>Copy the content of the Path: field.</p> </li> </ol> <p>Once you know the location of your shared file system, you can mount it on any VM with the appropriate access rights, e.g.\u00a0to mount a shared file system with location 10.2.0.2:/volumes/_nogroup/918...a78 at mount point \\mnt:</p> <pre><code>sudo mount 10.2.0.2:/volumes/_nogroup/918...a78 /mnt\n</code></pre>"}, {"location": "terraform/", "title": "Orchestration Using Terraform", "text": "<p>HashiCorp Terraform https://www.terraform.io/ is an infrastructure as code tool (IaC), similar to OpenStack Heat orchestrator (See chapter using heat ). Users can deploy a data center infrastructure using a declarative configuration language known as HashiCorp Configuration Language (HCL), or using JSON. Terraform has some advantages over OpenStack Heat service. It is has a simple syntax, it can provision virtual infrastructures across multiple cloud providers (not only OpenStack) and it provides important features not supported by Heat at this moment, like network port forwarding rules (see floating-ip). This means that with Terraform, scripts like <code>neutron_port_forward</code> (see port forwarding script ) are no longer needed. Terraform is currently one of the most popular infrastructure automation tools available. VSC Cloud also provides some template examples that could be used to deploy virtual infrastructures within VSC Tier-1 Cloud in an automated way (https://github.com/hpcugent/openstack-templates/tree/master/terraform).</p> <p>Terraform client is available for different Operating Systems like Windows, Linux or macOS (https://www.terraform.io/downloads) but it is also available from UGent login node login.hpc.ugent.be.</p>"}, {"location": "terraform/#create-application-credentials-for-terraform", "title": "Create application credentials for Terraform", "text": "<p>Terraform uses OpenStack application credentials to authenticate to VSC Cloud Tier-1 public API. It is a good practice to generate a new application credential just to be used with Terraformframework. The process is the same described in section application credentials.</p> <p>Note</p> <p>Make sure you download the new application credential as yaml file instead of openRC.</p> <p>At this point you should have a clouds.yaml text file with these lines:</p> <pre><code># This is a clouds.yaml file, which can be used by OpenStack tools as a source\n# of configuration on how to connect to a cloud. If this is your only cloud,\n# just put this file in ~/.config/openstack/clouds.yaml and tools like\n# python-openstackclient will just work with no further config. (You will need\n# to add your password to the auth section)\n# If you have more than one cloud account, add the cloud entry to the clouds\n# section of your existing file and you can refer to them by name with\n# OS_CLOUD=openstack or --os-cloud=openstack\nclouds:\n  openstack:\n\n    auth:\n\n      auth_url: https://cloud.vscentrum.be:13000\n\n      application_credential_id: \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\napplication_credential_secret: \"xxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n\n\n\nregion_name: \"regionOne\"\n\n\ninterface: \"public\"\nidentity_api_version: 3\nauth_type: \"v3applicationcredential\"\n</code></pre> <p>As the file comments state, you should copy the current clouds.yaml to your VSC login node $HOME login.hpc.ugent.be: ~/.config/openstack/clouds.yaml, or locally if you have installed Terraform in your own laptop or computer. Terraform will use this file to authenticate to OpenStack API automatically.</p>"}, {"location": "terraform/#getting-terraform-examples", "title": "Getting Terraform examples", "text": "<p>You can connect to UGent login node <code>login.hpc.ugent.be</code> to use terraform. Login to the login node with your VSC account first:</p> <pre><code>ssh -A vscxxxxx@login.hpc.ugent.be\n</code></pre> <p>If this is the first time using Terraform, download the VSC Terraform examples from github from https://github.com/hpcugent/openstack-templates:</p> <pre><code>git clone https://github.com/hpcugent/openstack-templates\n</code></pre> <p>Make sure you have <code>~/.config/openstack/clouds.yaml</code> available from the login node (see previous section).</p> <p>Warning</p> <p>Do not share your application's credential file <code>clouds.yaml</code> or put this file in a public place.</p> <pre><code>chmod 600 ~/.config/openstack/clouds.yaml\n</code></pre>"}, {"location": "terraform/#generate-terraform-template-variables", "title": "Generate Terraform template variables", "text": "<p>Terraform requires some variables to know which resources are available from the cloud provider for the user or project. You do not have to include these variables manually, we have included a script to gather these variable IDs automatically. From the Terraform directory cloned from git in the previous step (see previous section), go to the scripts directory:</p> <pre><code>cd ~/openstack-templates/terraform/scripts\n</code></pre> <p>And now run the script (usually you only have to run this script once).</p> <pre><code>./modify_variable.sh\n</code></pre> <p>This step will take some seconds. The script will contact the VSC OpenStack public API to gather all the resources available for your project and fetch all the resource's IDs. Usually you only have to run this script once, unless something was changed/updated for your project's resources (like a new network or floating IPs) or if you want to deploy a new Terraform template from scratch.</p> <p>You will see some messages like this (IDs and IPs may change depending on your project's resources).</p> <pre><code>Variable OS_CLOUD is not set. Using openstack as a value.\nImage id: 749f4f24-7222-45fc-b571-996f5b68c28f. (Image name: CentOS-8-stream)\nFlavor name: CPUv1.small.\nRoot FS volume size based on flavor disk size: 20.\nVM network id: 4d72c0ec-c000-429e-89c6-8c3607a28b3d.\nVM subnet id: f0bc8307-568f-457d-adff-219005a054e2.\nNFS network id: 119d8617-4000-47c0-9c6e-589b3afce144.\nNFS subnet id: e4e07edd-39cf-42ea-9fe4-5bf2891d2592.\nVSC network id: f6eba915-06ad-4e50-bc4b-1538cdc39296.\nVSC subnet id: b5ed8dc2-6d3f-42d4-87f8-3ffee19c1a9c.\nUsing first ssh access key \"ssh-ed25519 AAAAC3Nz_A02TxLd9 lsimngar_varolaptop\\\".\nUsing floating ip id: 64f2705c-43ec-4bdf-864e-d18fee013e3f. (floating ip 193.190.80.3)\nUsing VSC floating ip: 172.24.49.7.\nUsing ssh forwarded ports: 56469 59112 54872 51280.\nUsing http forwarded port: 52247.\nModifying ../environment/main.tf file.\nModifying provider.tf files.\nSSH commands for VMs access:\n(myvm) ssh -p 56469 &lt;user&gt;@193.190.80.3\n(myvm-nginx) ssh -p 59112 &lt;user&gt;@193.190.80.3\n(myvm-vsc_net) ssh -p 54872 &lt;user&gt;@193.190.80.3\n(myvm-nfs_share) ssh -p 51280 &lt;user&gt;@193.190.80.3\n</code></pre> <p>After this step your Terraform templates will be ready to be deployed.</p> <p>Note</p> <p>Please note that the script shows you the ssh command to connect to each VM after instantiation (including the port which is generated automatically by the script). You can copy this list or you can review it later. Also note that you should use a valid user to connect to the VM, for instance for CentOS images is centos, for Ubuntu images is ubuntu and so on. You can also try to connect as root user, in that case the system will show you a message with the user that you should use.</p>"}, {"location": "terraform/#modify-default-terraform-modules", "title": "Modify default Terraform modules", "text": "<p>In section we have downloaded the Terraform module examples from the VSC repository. If you deploy these modules as it is it will deploy several VM examples by default such as:</p> <ol> <li> <p>myvm: simple VM with 20Gb persistent volume and ssh access with port     forwarding.</p> </li> <li> <p>myvm-nginx: Like previous example but with an ansible playbook to install nginx     and access to port 80 besides ssh.</p> </li> <li> <p>myvm-vsc_net: Similar to the first example but also includes a VSC network     interface (only available for some projects).</p> </li> <li> <p>myvm-nfs_share: Similar to the first example but it creates a NFS share filesystem     and it mounts it during instantiation (only available for some     projects).</p> </li> </ol> <p>But usually you do not want to deploy all these examples, you can just keep the required module and comment out the rest. You can do this from environment directory:</p> <pre><code>cd ~/openstack-templates/terraform/environment\n</code></pre> <p>And edit <code>main.tf</code> Terraform file with any text editor like vim or nano. If you want to deploy just the simple VM (first example) only keep these lines (remenber variable IDs may change depending on your project's resources):</p> <pre><code>module \"vm_with_pf_rules_with_ssh_access\" {\n  source   = \"../modules/vm_with_pf_rules_with_ssh_access\"\n\n  vm_name              = \"MyVM\"\n  floating_ip_id       = \"64f2705c-43ec-4bdf-864e-d18fee013e3f\"\n  vm_network_id        = \"4d72c0ec-c000-429e-89c6-8c3607a28b3d\"\n  vm_subnet_id         = \"f0bc8307-568f-457d-adff-219005a054e2\"\n  access_key           = \"ssh-ed25519 AAAAC3Nz_A02TxLd9 lsimngar_varolaptop\"\n  image_id             = \"d00d6dfd-998c-4bcb-bbf4-496ef84d5b64\"\n  flavor_name          = \"CPUv1.small\"\n  ssh_forwarded_port   = \"56469\"\n  root_fs_volume_size  = \"20\"\n}\n</code></pre> <p>And remove or comment out the rest of the lines. In the previous example Terraform will deploy a simple VM and use 20Gb for a persistent volume and port 56469 to connect via ssh (it also creates all required security groups).</p>"}, {"location": "terraform/#deploy-terraform-templates", "title": "Deploy Terraform templates", "text": "<p>If you have followed the previous steps now you can init and deploy your infrastucture to Tier-1 VSC cloud.</p> <p>You have to inititate Terraform first, if you didnt have deployed any template yet do this just once.</p> <p>Move to environment directory first:</p> <pre><code>cd ~/openstack-templates/terraform/environment\n</code></pre> <p>This command performs several different initialization steps in order to prepare the current working directory for use with Terraform:</p> <pre><code>terraform init\n</code></pre> <p>Now you can check and review your Terraform plan, from the same directory:</p> <pre><code>terraform plan\n</code></pre> <p>You will see a list of the resources required to deploy your infrastructure, Terraform also checks if there is any systax error in your templates. Your infrastructure is not deployed yet, review the plan and then just deploy it to VSC Tier-1 Cloud running:</p> <pre><code>terraform apply\n</code></pre> <p>Terraform will show your plan again and you will see this message:</p> <pre><code>..\n..\nDo you want to perform these actions?\nTerraform will perform the actions described above.\nOnly \u2019yes\u2019 will be accepted to approve.\nEnter a value:\n</code></pre> <p>Type yes and press enter and wait a few seconds or minutes. If everything is correct and if you have enough quota Terraform will show you a message after creating all the required resources.</p> <pre><code>..\n..\nmodule.vm_with_pf_rules_with_ssh_access.openstack_compute_instance_v2.instance_01:\nStill creating... [1m30s elapsed]\nmodule.vm_with_pf_rules_with_ssh_access.openstack_compute_instance_v2.instance_01:\nCreation complete after 1m35s [id=88c7d037-5c44-45b7-acce-f5e4e58b1c35]\nApply complete! Resources: 4 added, 0 changed, 0 destroyed.\n</code></pre> <p>Your cloud infrastrucuture is ready to be used.</p> <p>Tip</p> <p>It is important to keep a backup of your terraform directory, specially all the files within the environment directory: <code>~/openstack-templates/terraform/environment</code></p> <p>Terraform generates several files in this directory to keep track of any change in your infrastructure. If for some reason you lost or remove these files you will not able to modify or change the current Terraform plan (only directly from OpenStack).</p> <p>You can also modify and add more resources for the current templates. This task is out of the scope of this document, please refer to official Terraform documentation to add you own changes https://www.terraform.io/docs or ask to VSC Cloud admins via email at cloud@vscentrum.be.</p>"}, {"location": "title/", "title": "Title", "text": "<p>\\ Last updated: DATEPLACEHOLDER</p> <p>Alexander Vapirev (KU\u00a0Leuven), Thomas Danckaert (UAntwerpen), \u00c1lvaro Sim\u00f3n Garc\u00eda (UGent), Ewald Pauwels (UGent)</p> <p>Acknowledgement: VSCentrum.be</p> <p></p> <p>:::</p> <p>This document is a hands-on guide to the VSC cloud computing platform, which relies on the open-source software [OpenStack]. It should complement the official documentation at https://docs.openstack.org.</p> <p>For all questions concerning the VSC cloud computing platform, please contact cloud@vscentrum.be.</p> <p>We welcome your feedback, comments and suggestions for improving the OpenStack Tutorial.</p>"}]}